 conf/battle/battleground.conf               |   29 +
 conf/battle/client.conf                     |    2 +-
 conf/groups.conf                            |    7 +
 conf/maps_athena.conf                       |   18 +
 conf/msg_conf/map_msg.conf                  |    6 +
 db/battleground_db.yml                      |  296 ++--
 db/import/battleground_db.yml               |  482 ++++++
 db/import/item_db.yml                       |  499 ++++++
 db/import/map_cache.dat                     |  Bin 0 -> 28682 bytes
 db/import/map_index.txt                     |   36 +
 npc/battleground-extended/1-bg_ctf.txt      |  470 ++++++
 npc/battleground-extended/2-bg_tdm.txt      |  259 ++++
 npc/battleground-extended/3-bg_eoe.txt      |  749 +++++++++
 npc/battleground-extended/4-bg_conquest.txt | 2223 +++++++++++++++++++++++++++
 npc/battleground-extended/5-bg_kvm.txt      |  250 +++
 npc/battleground-extended/6-bg_sc.txt       | 1092 +++++++++++++
 npc/battleground-extended/7-bg_dom.txt      |  543 +++++++
 npc/battleground-extended/8-bg_rush.txt     |  529 +++++++
 npc/battleground-extended/bg_common.txt     |  524 +++++++
 npc/battleground-extended/bg_dealers.txt    |  770 ++++++++++
 npc/battleground-extended/bg_entering.txt   |  186 +++
 npc/re/scripts_athena.conf                  |    2 +-
 npc/scripts_athena.conf                     |   24 +-
 npc/scripts_custom.conf                     |   13 +
 src/custom/atcommand.inc                    |  293 ++++
 src/custom/atcommand_def.inc                |   11 +
 src/custom/battle_config_init.inc           |   12 +
 src/custom/battle_config_struct.inc         |    3 +
 src/custom/script.inc                       |  846 ++++++++++
 src/custom/script_def.inc                   |   29 +
 src/map/atcommand.cpp                       |    9 +-
 src/map/battle.cpp                          |   29 +-
 src/map/battle.hpp                          |    9 +
 src/map/battleground.cpp                    |  760 ++++++++-
 src/map/battleground.hpp                    |   56 +-
 src/map/buyingstore.cpp                     |   10 +-
 src/map/clif.cpp                            |  376 ++++-
 src/map/clif.hpp                            |   13 +-
 src/map/guild.cpp                           |   22 +-
 src/map/guild.hpp                           |    2 +-
 src/map/map.cpp                             |   15 +-
 src/map/map.hpp                             |   44 +-
 src/map/mob.cpp                             |    6 +-
 src/map/mob.hpp                             |    2 +-
 src/map/npc.cpp                             |   15 +-
 src/map/party.cpp                           |   59 +-
 src/map/pc.cpp                              |  103 +-
 src/map/pc.hpp                              |    8 +
 src/map/script.cpp                          |  176 ++-
 src/map/script_constants.hpp                |    8 +
 src/map/skill.cpp                           |  179 ++-
 src/map/status.cpp                          |   26 +-
 src/map/status.hpp                          |    4 +
 src/map/storage.cpp                         |   37 +-
 src/map/storage.hpp                         |    3 +-
 src/map/unit.cpp                            |    4 +
 src/map/vending.cpp                         |    3 +
 57 files changed, 11789 insertions(+), 392 deletions(-)

diff --git a/conf/battle/battleground.conf b/conf/battle/battleground.conf
index 05537ea85..68e565689 100644
--- a/conf/battle/battleground.conf
+++ b/conf/battle/battleground.conf
@@ -34,3 +34,32 @@ bg_update_interval: 1000
 // Before a player is warped into a Battleground from the Battleground Queue,
 // check to see if the player's current map has MF_NOWARP.
 bgqueue_nowarp_mapflag: no
+
+// Time in seconds to consider a idle character on BG. Characters on Idle mode can be kicked out of BG with @reportafk. Set 0 to disable.
+bg_idle_announce: 45
+
+// Time in seconds to kick a idle character from BG if idle. They will be warped to their respawn positions. Set 0 to disable.
+bg_idle_autokick: 90
+
+// Does the @reportafk command to kick AFK players from your BG team are limited to the Team Leader only? Note 1.
+bg_reportafk_leaderonly: no
+
+// Reserved Char ID for battleground Items. Default value is 999996
+bg_reserved_char_id: 999996
+
+// Reserved Char ID for items usables only on WoE or GvG maps.
+woe_reserved_char_id: 999999
+
+// When teleporting time before being attackable, if you don't move? (time is in milliseconds)
+bg_invincible_time: 5000
+
+// Minimum number of votes to change leader
+// with @voteleader
+// 0: all members should vote for change
+bg_min_vote_leader: 0
+
+// BG mode selection method
+// 0: Free access to all (not available)
+// 1: Rotation
+// 2: Vote (not available)
+bg_mode_selection: 1
\ No newline at end of file
diff --git a/conf/battle/client.conf b/conf/battle/client.conf
index cc1035a1e..5793f2f74 100644
--- a/conf/battle/client.conf
+++ b/conf/battle/client.conf
@@ -19,7 +19,7 @@ max_hair_style: 27
 min_hair_color: 0
 max_hair_color: 8
 min_cloth_color: 0 
-max_cloth_color: 4
+max_cloth_color: 500
 min_body_style: 0
 max_body_style: 1
 
diff --git a/conf/groups.conf b/conf/groups.conf
index 0d83b0361..d37fd80df 100644
--- a/conf/groups.conf
+++ b/conf/groups.conf
@@ -88,6 +88,13 @@ groups: (
 	commands: {
 		changedress: true
 		resurrect: true
+		listenbg: true
+		guildskill: true
+		order: true
+		leader: false
+		voteleader: true
+		reportafk: true
+		votekick: true
 	}
 	permissions: {
 		/* without this basic permissions regular players could not 
diff --git a/conf/maps_athena.conf b/conf/maps_athena.conf
index ee90ed2bc..d76a975c8 100644
--- a/conf/maps_athena.conf
+++ b/conf/maps_athena.conf
@@ -1485,3 +1485,21 @@ map: tur_d04ib
 
 //------------------------- Clone Maps ---------------------------
 //------------------------- Extra Maps ---------------------------
+
+// BG EXTENDED
+map: bg_ctf
+map: bg_tdm
+map: bg_eoe
+map: bg_con01
+map: bg_con02
+map: bg_con03
+map: bg_con04
+map: bg_con05
+map: bg_con06
+map: bg_kvm
+map: bg_sc
+map: bg_dom
+map: bg_rush01
+map: bg_rush02
+map: bg_rush03
+map: bg_rush04
diff --git a/conf/msg_conf/map_msg.conf b/conf/msg_conf/map_msg.conf
index a4e467628..8f3c30f57 100644
--- a/conf/msg_conf/map_msg.conf
+++ b/conf/msg_conf/map_msg.conf
@@ -466,6 +466,12 @@
 
 451: Cash Shop is disabled on this map.
 
+// BG
+452: [ %s ] Number of participations : 
+453: Battleground is not started, you cannot join a mode.
+454: You cannot enter Battleground because you are already inside with another account.
+455: [ Battleground ] ~ %s -- %s joined the queue -- @joinbg to join the battle.
+
 // Message System
 460: Please enter a valid language (usage: @langtype <language>).
 461: Language is now set to %s.
diff --git a/db/battleground_db.yml b/db/battleground_db.yml
index f32700dc0..1e3704592 100644
--- a/db/battleground_db.yml
+++ b/db/battleground_db.yml
@@ -58,154 +58,154 @@ Header:
   Type: BATTLEGROUND_DB
   Version: 1
 
-Body:
-  - Id: 1
-    Name: Tierra Gorge
-    MinPlayers: 6
-    MinLevel: 80
-    JobRestrictions:
-      Novice: true
-      SuperNovice: true
-      Novice_High: true
-      Baby: true
-      Super_Baby: true
-      Super_Novice_E: true
-      Super_Baby_E: true
-    Locations:
-      - Map: bat_a01
-        StartEvent: start#bat_a01::OnReadyCheck
-        TeamA:
-          RespawnX: 50
-          RespawnY: 374
-          QuitEvent: start#bat_a01::OnGuillaumeQuit
-          ActiveEvent: start#bat_a01::OnGuillaumeActive
-          Variable: $@TierraBG1_id1
-        TeamB:
-          RespawnX: 42
-          RespawnY: 16
-          QuitEvent: start#bat_a01::OnCroixQuit
-          ActiveEvent: start#bat_a01::OnCroixActive
-          Variable: $@TierraBG1_id2
-      - Map: bat_a02
-        StartEvent: start#bat_a02::OnReadyCheck
-        TeamA:
-          RespawnX: 50
-          RespawnY: 374
-          QuitEvent: start#bat_a02::OnGuillaumeQuit
-          ActiveEvent: start#bat_a02::OnGuillaumeActive
-          Variable: $@TierraBG2_id1
-        TeamB:
-          RespawnX: 42
-          RespawnY: 16
-          QuitEvent: start#bat_a02::OnCroixQuit
-          ActiveEvent: start#bat_a02::OnCroixActive
-          Variable: $@TierraBG2_id2
-  - Id: 2
-    Name: Flavius
-    MinPlayers: 6
-    MinLevel: 80
-    JobRestrictions:
-      Novice: true
-      SuperNovice: true
-      Novice_High: true
-      Baby: true
-      Super_Baby: true
-      Super_Novice_E: true
-      Super_Baby_E: true
-    Locations:
-      - Map: bat_b01
-        StartEvent: start#bat_b01::OnReadyCheck
-        TeamA:
-          RespawnX: 10
-          RespawnY: 290
-          QuitEvent: start#bat_b01::OnGuillaumeQuit
-          ActiveEvent: start#bat_b01::OnGuillaumeActive
-          Variable: $@FlaviusBG1_id1
-        TeamB:
-          RespawnX: 390
-          RespawnY: 10
-          QuitEvent: start#bat_b01::OnCroixQuit
-          ActiveEvent: start#bat_b01::OnCroixActive
-          Variable: $@FlaviusBG1_id2
-      - Map: bat_b02
-        StartEvent: start#bat_b02::OnReadyCheck
-        TeamA:
-          RespawnX: 10
-          RespawnY: 290
-          QuitEvent: start#bat_b02::OnGuillaumeQuit
-          ActiveEvent: start#bat_b02::OnGuillaumeActive
-          Variable: $@FlaviusBG2_id1
-        TeamB:
-          RespawnX: 390
-          RespawnY: 10
-          QuitEvent: start#bat_b02::OnCroixQuit
-          ActiveEvent: start#bat_b02::OnCroixActive
-          Variable: $@FlaviusBG2_id2
-  - Id: 3
-    Name: KVM (Level 80 and up)
-    MinPlayers: 5
-    MinLevel: 80
-    Locations:
-      - Map: bat_c01
-        StartEvent: KvM01_BG::OnStart
-        TeamA:
-          RespawnX: 52
-          RespawnY: 129
-          DeathEvent: KvM01_BG::OnGuillaumeDie
-          QuitEvent: KvM01_BG::OnGuillaumeQuit
-          ActiveEvent: KvM01_BG::OnGuillaumeActive
-          Variable: $@KvM01BG_id1
-        TeamB:
-          RespawnX: 147
-          RespawnY: 55
-          DeathEvent: KvM01_BG::OnCroixDie
-          QuitEvent: KvM01_BG::OnCroixQuit
-          ActiveEvent: KvM01_BG::OnCroixActive
-          Variable: $@KvM01BG_id2
-  - Id: 4
-    Name: KVM (Level 60~79)
-    MinPlayers: 5
-    MinLevel: 60
-    MaxLevel: 79
-    Locations:
-      - Map: bat_c02
-        StartEvent: KvM02_BG::OnStart
-        TeamA:
-          RespawnX: 52
-          RespawnY: 129
-          DeathEvent: KvM02_BG::OnGuillaumeDie
-          QuitEvent: KvM02_BG::OnGuillaumeQuit
-          ActiveEvent: KvM02_BG::OnGuillaumeActive
-          Variable: $@KvM02BG_id1
-        TeamB:
-          RespawnX: 147
-          RespawnY: 55
-          DeathEvent: KvM02_BG::OnCroixDie
-          QuitEvent: KvM02_BG::OnCroixQuit
-          ActiveEvent: KvM02_BG::OnCroixActive
-          Variable: $@KvM02BG_id2
-  - Id: 5
-    Name: KVM (Level 59 and below
-    MinPlayers: 5
-    MaxLevel: 59
-    Locations:
-      - Map: bat_c03
-        StartEvent: KvM03_BG::OnStart
-        TeamA:
-          RespawnX: 52
-          RespawnY: 129
-          DeathEvent: KvM03_BG::OnGuillaumeDie
-          QuitEvent: KvM03_BG::OnGuillaumeQuit
-          ActiveEvent: KvM03_BG::OnGuillaumeActive
-          Variable: $@KvM03BG_id1
-        TeamB:
-          RespawnX: 147
-          RespawnY: 55
-          DeathEvent: KvM03_BG::OnCroixDie
-          QuitEvent: KvM03_BG::OnCroixQuit
-          ActiveEvent: KvM03_BG::OnCroixActive
-          Variable: $@KvM03BG_id2
-
+#Body:
+#  - Id: 1
+#    Name: Tierra Gorge
+#    MinPlayers: 6
+#    MinLevel: 80
+#    JobRestrictions:
+#      Novice: true
+#      SuperNovice: true
+#      Novice_High: true
+#      Baby: true
+#      Super_Baby: true
+#      Super_Novice_E: true
+#      Super_Baby_E: true
+#    Locations:
+#      - Map: bat_a01
+#        StartEvent: start#bat_a01::OnReadyCheck
+#        TeamA:
+#          RespawnX: 50
+#          RespawnY: 374
+#          QuitEvent: start#bat_a01::OnGuillaumeQuit
+#          ActiveEvent: start#bat_a01::OnGuillaumeActive
+#          Variable: $@TierraBG1_id1
+#        TeamB:
+#          RespawnX: 42
+#          RespawnY: 16
+#          QuitEvent: start#bat_a01::OnCroixQuit
+#          ActiveEvent: start#bat_a01::OnCroixActive
+#          Variable: $@TierraBG1_id2
+#      - Map: bat_a02
+#        StartEvent: start#bat_a02::OnReadyCheck
+#        TeamA:
+#          RespawnX: 50
+#          RespawnY: 374
+#          QuitEvent: start#bat_a02::OnGuillaumeQuit
+#          ActiveEvent: start#bat_a02::OnGuillaumeActive
+#          Variable: $@TierraBG2_id1
+#        TeamB:
+#          RespawnX: 42
+#          RespawnY: 16
+#          QuitEvent: start#bat_a02::OnCroixQuit
+#          ActiveEvent: start#bat_a02::OnCroixActive
+#          Variable: $@TierraBG2_id2
+#  - Id: 2
+#    Name: Flavius
+#    MinPlayers: 6
+#    MinLevel: 80
+#    JobRestrictions:
+#      Novice: true
+#      SuperNovice: true
+#      Novice_High: true
+#      Baby: true
+#      Super_Baby: true
+#      Super_Novice_E: true
+#      Super_Baby_E: true
+#    Locations:
+#      - Map: bat_b01
+#        StartEvent: start#bat_b01::OnReadyCheck
+#        TeamA:
+#          RespawnX: 10
+#          RespawnY: 290
+#          QuitEvent: start#bat_b01::OnGuillaumeQuit
+#          ActiveEvent: start#bat_b01::OnGuillaumeActive
+#          Variable: $@FlaviusBG1_id1
+#        TeamB:
+#          RespawnX: 390
+#          RespawnY: 10
+#          QuitEvent: start#bat_b01::OnCroixQuit
+#          ActiveEvent: start#bat_b01::OnCroixActive
+#          Variable: $@FlaviusBG1_id2
+#      - Map: bat_b02
+#        StartEvent: start#bat_b02::OnReadyCheck
+#        TeamA:
+#          RespawnX: 10
+#          RespawnY: 290
+#          QuitEvent: start#bat_b02::OnGuillaumeQuit
+#          ActiveEvent: start#bat_b02::OnGuillaumeActive
+#          Variable: $@FlaviusBG2_id1
+#        TeamB:
+#          RespawnX: 390
+#          RespawnY: 10
+#          QuitEvent: start#bat_b02::OnCroixQuit
+#          ActiveEvent: start#bat_b02::OnCroixActive
+#          Variable: $@FlaviusBG2_id2
+#  - Id: 3
+#    Name: KVM (Level 80 and up)
+#    MinPlayers: 5
+#    MinLevel: 80
+#    Locations:
+#      - Map: bat_c01
+#        StartEvent: KvM01_BG::OnStart
+#        TeamA:
+#          RespawnX: 52
+#          RespawnY: 129
+#          DeathEvent: KvM01_BG::OnGuillaumeDie
+#          QuitEvent: KvM01_BG::OnGuillaumeQuit
+#          ActiveEvent: KvM01_BG::OnGuillaumeActive
+#          Variable: $@KvM01BG_id1
+#        TeamB:
+#          RespawnX: 147
+#          RespawnY: 55
+#          DeathEvent: KvM01_BG::OnCroixDie
+#          QuitEvent: KvM01_BG::OnCroixQuit
+#          ActiveEvent: KvM01_BG::OnCroixActive
+#          Variable: $@KvM01BG_id2
+#  - Id: 4
+#    Name: KVM (Level 60~79)
+#    MinPlayers: 5
+#    MinLevel: 60
+#    MaxLevel: 79
+#    Locations:
+#      - Map: bat_c02
+#        StartEvent: KvM02_BG::OnStart
+#        TeamA:
+#          RespawnX: 52
+#          RespawnY: 129
+#          DeathEvent: KvM02_BG::OnGuillaumeDie
+#          QuitEvent: KvM02_BG::OnGuillaumeQuit
+#          ActiveEvent: KvM02_BG::OnGuillaumeActive
+#          Variable: $@KvM02BG_id1
+#        TeamB:
+#          RespawnX: 147
+#          RespawnY: 55
+#          DeathEvent: KvM02_BG::OnCroixDie
+#          QuitEvent: KvM02_BG::OnCroixQuit
+#          ActiveEvent: KvM02_BG::OnCroixActive
+#          Variable: $@KvM02BG_id2
+#  - Id: 5
+#    Name: KVM (Level 59 and below
+#    MinPlayers: 5
+#    MaxLevel: 59
+#    Locations:
+#      - Map: bat_c03
+#        StartEvent: KvM03_BG::OnStart
+#        TeamA:
+#          RespawnX: 52
+#          RespawnY: 129
+#          DeathEvent: KvM03_BG::OnGuillaumeDie
+#          QuitEvent: KvM03_BG::OnGuillaumeQuit
+#          ActiveEvent: KvM03_BG::OnGuillaumeActive
+#          Variable: $@KvM03BG_id1
+#        TeamB:
+#          RespawnX: 147
+#          RespawnY: 55
+#          DeathEvent: KvM03_BG::OnCroixDie
+#          QuitEvent: KvM03_BG::OnCroixQuit
+#          ActiveEvent: KvM03_BG::OnCroixActive
+#          Variable: $@KvM03BG_id2
+#
 Footer:
   Imports:
   - Path: db/import/battleground_db.yml
diff --git a/db/import/battleground_db.yml b/db/import/battleground_db.yml
new file mode 100644
index 000000000..6ab492e0c
--- /dev/null
+++ b/db/import/battleground_db.yml
@@ -0,0 +1,482 @@
+# This file is a part of rAthena.
+#   Copyright(C) 2019 rAthena Development Team
+#   https://rathena.org - https://github.com/rathena
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program. If not, see <http://www.gnu.org/licenses/>.
+#
+###########################################################################
+# Battleground Queue Database
+###########################################################################
+#
+# Battleground Queue Settings
+#
+###########################################################################
+# - Id                Unique ID for the battleground type.
+#   Name              Name of the battleground. Must be the exact same as in the client for players to be able to join.
+#   MinPlayers        Minimum number of players required on each team. (Default: 1)
+#   MaxPlayers        Maximum number of players on each team. (Default: MAX_BG_MEMBERS / 2)
+#   MinLevel          Minimum level required to join the battleground. (Default: 1)
+#   MaxLevel          Maximum level to join the battleground. (Default: MAX_LEVEL value)
+#   Deserter          Amount of time in seconds a player is marked deserter. (Default: 600)
+#   StartDelay        Amount of time in seconds once a queue is filled before players are warped. (Default: 0)
+#   Join:             Which application type is accepted. The entryqueuelist.lub can visually disable these options.
+#     Solo            Able to join a queue as an individual. (Default: true)
+#     Party           Able to join a queue as a party. (Default: true)
+#     Guild           Able to join a queue as a guild. (Default: true)
+#   JobRestrictions   List of jobs that are unable to join the battleground.
+#   Locations:        Battleground location settings.
+#     - Map           The map on which the battleground will be played.
+#       StartEvent    NPC event triggered when the battleground starts.
+#       TeamA:        TeamA settings.
+#         RespawnX    X coordinate for warping on death.
+#         RespawnY    Y coordinate for warping on death.
+#         DeathEvent  NPC event triggered when a player dies.
+#         QuitEvent   NPC event triggered when a player quits.
+#         ActiveEvent NPC event triggered when a player joints an active battleground.
+#         Variable    Name of BG ID variable used in the battleground script.
+#       TeamB:        TeamB settings.
+#         RespawnX    X coordinate for warping on death.
+#         RespawnY    Y coordinate for warping on death.
+#         DeathEvent  NPC event triggered when a player dies.
+#         QuitEvent   NPC event triggered when a player quits.
+#         ActiveEvent NPC event triggered when a player joints an active battleground.
+#         Variable    Name of BG ID variable used in the battleground script.
+###########################################################################
+
+Header:
+  Type: BATTLEGROUND_DB
+  Version: 1
+
+Body:
+  - Id: 1
+    Name: Capture the Flag
+    MinPlayers: 2
+    MaxPlayers: 15
+    MinLevel: 80
+    Deserter: 300
+    StartDelay: 0
+    Color: 0xA0522D
+    Variable: BG_CTF
+    RewardWinner: 15
+    RewardDraw: 6
+    RewardLooser: 6
+    Join:
+      Solo: true
+      Party: false
+      Guild: false
+    Locations:
+      - Map: bg_ctf
+        StartEvent: Flavius_CTF::OnReady
+        PrematureEndEvent: Flavius_CTF::OnPrematureEnd
+        TeamA:
+          RespawnX: 228
+          RespawnY: 39
+          QuitEvent: Flavius_CTF::OnTeam1Quit
+          DeathEvent: Flavius_CTF::OnTeam1Die
+          ActiveEvent: Flavius_CTF::OnBGTeam1Active
+          Variable: $@BG_Team1
+          Palette: 376
+        TeamB:
+          RespawnX: 30
+          RespawnY: 38
+          QuitEvent: Flavius_CTF::OnTeam2Quit
+          DeathEvent: Flavius_CTF::OnTeam2Die
+          ActiveEvent: Flavius_CTF::OnBGTeam2Active
+          Variable: $@BG_Team2
+          Palette: 409
+  - Id: 2
+    Name: Team DeathMatch
+    MinPlayers: 2
+    MaxPlayers: 15
+    MinLevel: 80
+    Deserter: 300
+    StartDelay: 0
+    Color: 0x808000
+    Variable: BG_TDM
+    RewardWinner: 15
+    RewardDraw: 6
+    RewardLooser: 6
+    Join:
+      Solo: true
+      Party: false
+      Guild: false
+    Locations:
+      - Map: bg_tdm
+        StartEvent: Flavius_TD::OnReady
+        PrematureEndEvent: Flavius_TD::OnPrematureEnd
+        TeamA:
+          RespawnX: 44
+          RespawnY: 99
+          QuitEvent: Flavius_TD::OnTeam1Quit
+          DeathEvent: Flavius_TD::OnTeam1Die
+          ActiveEvent: Flavius_TD::OnBGTeam1Active
+          Variable: $@BG_Team1
+          Palette: 376
+        TeamB:
+          RespawnX: 100
+          RespawnY: 43
+          QuitEvent: Flavius_TD::OnTeam2Quit
+          DeathEvent: Flavius_TD::OnTeam2Die
+          ActiveEvent: Flavius_TD::OnBGTeam2Active
+          Variable: $@BG_Team2
+          Palette: 409
+  - Id: 3
+    Name: Eye of Storm
+    MinPlayers: 2
+    MaxPlayers: 15
+    MinLevel: 80
+    Deserter: 300
+    StartDelay: 0
+    Color: 0x4169E1
+    Variable: BG_EOE
+    RewardWinner: 9
+    RewardDraw: 6
+    RewardLooser: 3
+    Join:
+      Solo: true
+      Party: false
+      Guild: false
+    Locations:
+      - Map: bg_eoe
+        StartEvent: Tierra_EOS::OnReady
+        PrematureEndEvent: Tierra_EOS::OnPrematureEnd
+        TeamA:
+          RespawnX: 14
+          RespawnY: 15
+          QuitEvent: Tierra_EOS::OnTeam1Quit
+          DeathEvent: Tierra_EOS::OnTeam1Die
+          ActiveEvent: Tierra_EOS::OnBGTeam1Active
+          Variable: $@BG_Team1
+          Palette: 376
+        TeamB:
+          RespawnX: 189
+          RespawnY: 161
+          QuitEvent: Tierra_EOS::OnTeam2Quit
+          DeathEvent: Tierra_EOS::OnTeam2Die
+          ActiveEvent: Tierra_EOS::OnBGTeam2Active
+          Variable: $@BG_Team2
+          Palette: 409 
+  - Id: 4
+    Name: Conquest
+    MinPlayers: 2
+    MaxPlayers: 15
+    MinLevel: 80
+    Deserter: 300
+    StartDelay: 0
+    Color: 0xFFA500
+    Variable: BG_CON
+    RewardWinner: 10
+    RewardDraw: 0
+    RewardLooser: 5
+    Join:
+      Solo: true
+      Party: false
+      Guild: false
+    Locations:
+      - Map: bg_con01
+        StartEvent: Conquest::OnReady
+        PrematureEndEvent: Conquest::OnPrematureEnd
+        TeamA:
+          RespawnX: 264
+          RespawnY: 379
+          QuitEvent: Conquest::OnTeamQuit
+          ActiveEvent: Conquest::OnBGTeamActive
+          Variable: $@BG_Team1
+          Palette: 376
+        TeamB:
+          RespawnX: 295
+          RespawnY: 379
+          QuitEvent: Conquest::OnTeamQuit
+          ActiveEvent: Conquest::OnBGTeamActive
+          Variable: $@BG_Team2
+          Palette: 409 
+      - Map: bg_con02
+        StartEvent: Conquest::OnReady
+        PrematureEndEvent: Conquest::OnPrematureEnd
+        TeamA:
+          RespawnX: 90
+          RespawnY: 311
+          QuitEvent: Conquest::OnTeamQuit
+          ActiveEvent: Conquest::OnBGTeamActive
+          Variable: $@BG_Team1
+          Palette: 376
+        TeamB:
+          RespawnX: 113
+          RespawnY: 311
+          QuitEvent: Conquest::OnTeamQuit
+          ActiveEvent: Conquest::OnBGTeamActive
+          Variable: $@BG_Team2
+          Palette: 409 
+      - Map: bg_con03
+        StartEvent: Conquest::OnReady
+        PrematureEndEvent: Conquest::OnPrematureEnd
+        TeamA:
+          RespawnX: 28
+          RespawnY: 50
+          QuitEvent: Conquest::OnTeamQuit
+          ActiveEvent: Conquest::OnBGTeamActive
+          Variable: $@BG_Team1
+          Palette: 376
+        TeamB:
+          RespawnX: 87
+          RespawnY: 50
+          QuitEvent: Conquest::OnTeamQuit
+          ActiveEvent: Conquest::OnBGTeamActive
+          Variable: $@BG_Team2
+          Palette: 409 
+      - Map: bg_con04
+        StartEvent: Conquest::OnReady
+        PrematureEndEvent: Conquest::OnPrematureEnd
+        TeamA:
+          RespawnX: 30
+          RespawnY: 381
+          QuitEvent: Conquest::OnTeamQuit
+          ActiveEvent: Conquest::OnBGTeamActive
+          Variable: $@BG_Team1
+          Palette: 376
+        TeamB:
+          RespawnX: 126
+          RespawnY: 357
+          QuitEvent: Conquest::OnTeamQuit
+          ActiveEvent: Conquest::OnBGTeamActive
+          Variable: $@BG_Team2
+          Palette: 409 
+      - Map: bg_con05
+        StartEvent: Conquest::OnReady
+        PrematureEndEvent: Conquest::OnPrematureEnd
+        TeamA:
+          RespawnX: 298
+          RespawnY: 339
+          QuitEvent: Conquest::OnTeamQuit
+          ActiveEvent: Conquest::OnBGTeamActive
+          Variable: $@BG_Team1
+          Palette: 376
+        TeamB:
+          RespawnX: 298
+          RespawnY: 308
+          QuitEvent: Conquest::OnTeamQuit
+          ActiveEvent: Conquest::OnBGTeamActive
+          Variable: $@BG_Team2
+          Palette: 409 
+      - Map: bg_con06
+        StartEvent: Conquest::OnReady
+        PrematureEndEvent: Conquest::OnPrematureEnd
+        TeamA:
+          RespawnX: 313
+          RespawnY: 154
+          QuitEvent: Conquest::OnTeamQuit
+          ActiveEvent: Conquest::OnBGTeamActive
+          Variable: $@BG_Team1
+          Palette: 376
+        TeamB:
+          RespawnX: 330
+          RespawnY: 154
+          QuitEvent: Conquest::OnTeamQuit
+          ActiveEvent: Conquest::OnBGTeamActive
+          Variable: $@BG_Team2
+          Palette: 409 
+  - Id: 5
+    Name: Kreiger Von Midgard
+    MinPlayers: 2
+    MaxPlayers: 15
+    MinLevel: 80
+    Deserter: 300
+    StartDelay: 0
+    Color: 0x00BFFF
+    Variable: BG_KVM
+    RewardWinner: 9
+    RewardDraw: 6
+    RewardLooser: 3
+    Join:
+      Solo: true
+      Party: false
+      Guild: false
+    Locations:
+      - Map: bg_kvm
+        StartEvent: KvM01_BG::OnReady
+        PrematureEndEvent: KvM01_BG::OnPrematureEnd
+        TeamA:
+          RespawnX: 53
+          RespawnY: 128
+          QuitEvent: KvM01_BG::OnTeam1Quit
+          DeathEvent: KvM01_BG::OnTeam1Die
+          ActiveEvent: KvM01_BG::OnBGTeam1Active
+          Variable: $@BG_Team1
+          Palette: 376
+        TeamB:
+          RespawnX: 146
+          RespawnY: 55
+          QuitEvent: KvM01_BG::OnTeam2Quit
+          DeathEvent: KvM01_BG::OnTeam2Die
+          ActiveEvent: KvM01_BG::OnBGTeam2Active
+          Variable: $@BG_Team2
+          Palette: 409 
+  - Id: 6
+    Name: Stone Control
+    MinPlayers: 2
+    MaxPlayers: 15
+    MinLevel: 80
+    Deserter: 300
+    StartDelay: 0
+    Color: 0x9ACD32
+    Variable: BG_SC
+    RewardWinner: 15
+    RewardDraw: 6
+    RewardLooser: 6
+    Join:
+      Solo: true
+      Party: false
+      Guild: false
+    Locations:
+      - Map: bg_sc
+        StartEvent: Flavius_SC::OnReady
+        PrematureEndEvent: Flavius_SC::OnPrematureEnd
+        TeamA:
+          RespawnX: 172
+          RespawnY: 122
+          QuitEvent: Flavius_SC::OnTeam1Quit
+          DeathEvent: Flavius_SC::OnTeam1Die
+          ActiveEvent: Flavius_SC::OnBGTeam1Active
+          Variable: $@BG_Team1
+          Palette: 376
+        TeamB:
+          RespawnX: 28
+          RespawnY: 57
+          QuitEvent: Flavius_SC::OnTeam2Quit
+          DeathEvent: Flavius_SC::OnTeam2Die
+          ActiveEvent: Flavius_SC::OnBGTeam2Active
+          Variable: $@BG_Team2
+          Palette: 409 
+  - Id: 7
+    Name: Domination
+    MinPlayers: 2
+    MaxPlayers: 15
+    MinLevel: 80
+    Deserter: 300
+    StartDelay: 0
+    Color: 0xE16941
+    Variable: BG_DOM
+    RewardWinner: 9
+    RewardDraw: 6
+    RewardLooser: 3
+    Join:
+      Solo: true
+      Party: false
+      Guild: false
+    Locations:
+      - Map: bg_dom
+        StartEvent: Tierra_DOM::OnReady
+        PrematureEndEvent: Tierra_DOM::OnPrematureEnd
+        TeamA:
+          RespawnX: 172
+          RespawnY: 122
+          QuitEvent: Tierra_DOM::OnTeamQuit
+          DeathEvent: Tierra_DOM::OnTeamDie
+          ActiveEvent: Tierra_DOM::OnBGTeam1Active
+          Variable: $@BG_Team1
+          Palette: 376
+        TeamB:
+          RespawnX: 28
+          RespawnY: 57
+          QuitEvent: Tierra_DOM::OnTeamQuit
+          DeathEvent: Tierra_DOM::OnTeamDie
+          ActiveEvent: Tierra_DOM::OnBGTeam2Active
+          Variable: $@BG_Team2
+          Palette: 409 
+  - Id: 8
+    Name: Rush
+    MinPlayers: 2
+    MaxPlayers: 15
+    MinLevel: 80
+    Deserter: 300
+    StartDelay: 0
+    Color: 0xDDA0DD
+    Variable: BG_RUSH
+    RewardWinner: 10
+    RewardDraw: 5
+    RewardLooser: 5
+    Join:
+      Solo: true
+      Party: false
+      Guild: false
+    Locations:
+      - Map: bg_rush01
+        StartEvent: Rush::OnReady
+        PrematureEndEvent: Rush::OnPrematureEnd
+        TeamA:
+          RespawnX: 202
+          RespawnY: 230
+          QuitEvent: Rush::OnTeam1Quit
+          ActiveEvent: Rush::OnBGTeamActive
+          Variable: $@BG_Team1
+          Palette: 376
+        TeamB:
+          RespawnX: 202
+          RespawnY: 226
+          QuitEvent: Rush::OnTeam2Quit
+          ActiveEvent: Rush::OnBGTeamActive
+          Variable: $@BG_Team2
+          Palette: 409
+      - Map: bg_rush02
+        StartEvent: Rush::OnReady
+        PrematureEndEvent: Rush::OnPrematureEnd
+        TeamA:
+          RespawnX: 146
+          RespawnY: 50
+          QuitEvent: Rush::OnTeam1Quit
+          ActiveEvent: Rush::OnBGTeamActive
+          Variable: $@BG_Team1
+          Palette: 376
+        TeamB:
+          RespawnX: 146
+          RespawnY: 46
+          QuitEvent: Rush::OnTeam2Quit
+          ActiveEvent: Rush::OnBGTeamActive
+          Variable: $@BG_Team2
+          Palette: 409
+      - Map: bg_rush03
+        StartEvent: Rush::OnReady
+        PrematureEndEvent: Rush::OnPrematureEnd
+        TeamA:
+          RespawnX: 60
+          RespawnY: 13
+          QuitEvent: Rush::OnTeam1Quit
+          ActiveEvent: Rush::OnBGTeamActive
+          Variable: $@BG_Team1
+          Palette: 376
+        TeamB:
+          RespawnX: 64
+          RespawnY: 13
+          QuitEvent: Rush::OnTeam2Quit
+          ActiveEvent: Rush::OnBGTeamActive
+          Variable: $@BG_Team2
+          Palette: 409
+      - Map: bg_rush04
+        StartEvent: Rush::OnReady
+        PrematureEndEvent: Rush::OnPrematureEnd
+        TeamA:
+          RespawnX: 270
+          RespawnY: 292
+          QuitEvent: Rush::OnTeam1Quit
+          ActiveEvent: Rush::OnBGTeamActive
+          Variable: $@BG_Team1
+          Palette: 376
+        TeamB:
+          RespawnX: 270
+          RespawnY: 288
+          QuitEvent: Rush::OnTeam2Quit
+          ActiveEvent: Rush::OnBGTeamActive
+          Variable: $@BG_Team2
+          Palette: 409
+          
diff --git a/db/import/item_db.yml b/db/import/item_db.yml
new file mode 100644
index 000000000..a2b195a31
--- /dev/null
+++ b/db/import/item_db.yml
@@ -0,0 +1,499 @@
+# This file is a part of rAthena.
+#   Copyright(C) 2019 rAthena Development Team
+#   https://rathena.org - https://github.com/rathena
+#
+# This program is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program. If not, see <http://www.gnu.org/licenses/>.
+#
+###########################################################################
+# Item Database
+###########################################################################
+#
+# Item Settings
+#
+###########################################################################
+# - Id                      Item ID.
+#   AegisName               Server name to reference the item in scripts and lookups, should use no spaces.
+#   Name                    Name in English for displaying as output.
+#   Type                    Item type. (Default: Etc)
+#   SubType                 Weapon or Ammo type. (Default: 0)
+#   Buy                     Buying price. When not specified, becomes double the sell price. (Default: 0)
+#   Sell                    Selling price. When not specified, becomes half the buy price. (Default: 0)
+#   Weight                  Item weight. Each 10 is 1 weight. (Default: 0)
+#   Attack                  Weapon's attack. (Default: 0)
+#   MagicAttack             Weapon's magic attack. (Default: 0)
+#   Defense                 Armor's defense. (Default: 0)
+#   Range                   Weapon's attack range. (Default: 0)
+#   Slots                   Available slots in item. (Default: 0)
+#   Jobs                    Jobs that can equip the item. (Map default is 'All: true')
+#   Classes                 Upper class types that can equip the item. (Map default is 'All: true')
+#   Gender                  Gender that can equip the item. (Default: Both)
+#   Locations               Equipment's placement. (Default: None)
+#   WeaponLevel             Weapon level. (Default: 0)
+#   EquipLevelMin           Minimum required level to equip. (Default: 0)
+#   EquipLevelMax           Maximum level that can equip. (Default: 0)
+#   Refineable              If the item can be refined. (Default: false)
+#   View                    View sprite of an item. (Default: 0)
+#   AliasName               Another item's AegisName that will be sent to the client instead of this item's AegisName. (Default: null)
+#   Flags:                  Item flags. (Default: null)
+#     BuyingStore           If the item is available for Buyingstores. (Default: false)
+#     DeadBranch            If the item is a Dead Branch. (Default: false)
+#     Container             If the item is part of a container. (Default: false)
+#     UniqueId              If the item is a unique stack. (Default: false)
+#     BindOnEquip           If the item is bound to the character upon equipping. (Default: false)
+#     DropAnnounce          If the item has a special announcement to self on drop. (Default: false)
+#     NoConsume             If the item is consumed on use. (Default: false)
+#     DropEffect            If the item has a special effect when on the ground. (Default: None)
+#   Delay:                  Item use delay. (Default: null)
+#     Duration              Duration of delay in seconds.
+#     Status                Status Change used to track delay. (Default: None)
+#   Stack:                  Item stack amount. (Default: null)
+#     Amount                Maximum amount that can be stacked.
+#     Inventory             If the stack is applied to player's inventory. (Default: true)
+#     Cart                  If the stack is applied to the player's cart. (Default: false)
+#     Storage               If the stack is applied to the player's storage. (Default: false)
+#     GuildStorage          If the stack is applied to the player's guild storage. (Default: false)
+#   NoUse:                  Conditions when the item is unusable. (Default: null)
+#     Override              Group level to override these conditions.
+#     Sitting               If the item can not be used while sitting. (Default: false)
+#   Trade:                  Trade restrictions. (Default: null)
+#     Override              Group level to override these conditions.
+#     NoDrop                If the item can not be dropped. (Default: false)
+#     NoTrade               If the item can not be traded. (Default: false)
+#     TradePartner          If the item can not be traded to the player's partner. (Default: false)
+#     NoSell                If the item can not be sold. (Default: false)
+#     NoCart                If the item can not be put in a cart. (Default: false)
+#     NoStorage             If the item can not be put in a storage. (Default: false)
+#     NoGuildStorage        If the item can not be put in a guild storage. (Default: false)
+#     NoMail                If the item can not be put in a mail. (Default: false)
+#     NoAuction             If the item can not be put in an auction. (Default: false)
+#   Script                  Script to execute when the item is used/equipped. (Default: null)
+#   EquipScript             Script to execute when the item is equipped. (Default: null)
+#   UnEquipScript           Script to execute when the item is unequipped or when a rental item expires. (Default: null)
+###########################################################################
+
+Header:
+  Type: ITEM_DB
+  Version: 1
+
+Body:
+# THQ Quest Items
+#=============================================================
+#  - Id: 1998
+#    AegisName: Jeramiah's_Jur
+#    Name: Jeramiah's Jur
+#    Type: Etc
+#    Sell: 10
+#    Weight: 10
+#    AliasName: Jur
+#  - Id: 1999
+#    AegisName: Zed's_Staff
+#    Name: Zed's Staff
+#    Type: Etc
+#    Sell: 10
+#    Weight: 10
+#    AliasName: Staff_Of_Soul
+#  - Id: 7950
+#    AegisName: THG_Membership
+#    Name: THG Membership
+#    Type: Etc
+#    Sell: 10
+#    Weight: 10
+#    AliasName: Foolishness_Of_Blind
+#  - Id: 7951
+#    AegisName: Token_Bag
+#    Name: Token Bag
+#    Type: Etc
+#    Sell: 10
+#    Weight: 10
+#    AliasName: Leather_Bag_Of_Infinity
+
+# Official Event Items that had their Effects removed after the event was completed
+#=============================================================
+#  - Id: 585
+#    AegisName: Wurst
+#    Name: Brusti
+#    Type: Delayconsume
+#    Buy: 2
+#    Weight: 40
+#    Script: |
+#      itemheal rand(15,20),0; itemskill "PR_MAGNIFICAT",3;
+#  - Id: 679
+#    AegisName: Gold_Pill
+#    Name: Pilule
+#    Type: Healing
+#    Buy: 5000
+#    Weight: 300
+#    Script: |
+#      percentheal 50,50;
+#  - Id: 2681
+#    AegisName: Republic_Ring
+#    Name: Republic Anniversary Ring
+#    Type: Armor
+#    Buy: 20
+#    Weight: 100
+#    Locations:
+#      Right_Accessory: true
+#      Left_Accessory: true
+#    Script: |
+#      bonus bAllStats,3;
+#  - Id: 5134
+#    AegisName: Pumpkin_Hat
+#    Name: Pumpkin-Head
+#    Type: Armor
+#    Buy: 20
+#    Weight: 200
+#    Defense: 2
+#    Locations:
+#      Head_Top: true
+#    Refineable: true
+#    View: 206
+#    Script: |
+#      bonus2 bSubRace,RC_Demon,5;
+#  - Id: 5136
+#    AegisName: Santa's_Hat_
+#    Name: Louise's Santa Hat
+#    Type: Armor
+#    Buy: 20
+#    Weight: 100
+#    Defense: 3
+#    Locations:
+#      Head_Top: true
+#    Refineable: true
+#    View: 20
+#    Script: |
+#      bonus bMdef,1; bonus bLuk,1; bonus3 bAutoSpellWhenHit,"AL_HEAL",3,50; bonus3 bAutoSpellWhenHit,"AL_BLESSING",10,50;
+#  - Id: 5145
+#    AegisName: Carnival_Joker_Jester
+#    Name: Carnival Jester
+#    Type: Armor
+#    Buy: 10
+#    Weight: 100
+#    Locations:
+#      Head_Top: true
+#    Refineable: true
+#    View: 89
+#    Script: |
+#      bonus bAllStats,3;
+#  - Id: 5147
+#    AegisName: Baseball_Cap
+#    Name: Baseball Cap
+#    Type: Armor
+#    Weight: 200
+#    Defense: 3
+#    Locations:
+#      Head_Top: true
+#    Refineable: true
+#    View: 216
+#    Script: |
+#      bonus2 bExpAddRace,RC_Boss,50; bonus2 bExpAddRace,RC_NonBoss,50;
+#  - Id: 5201
+#    AegisName: Party_Hat_B
+#    Name: 2nd Anniversary Party Hat
+#    Type: Armor
+#    Buy: 20
+#    Weight: 300
+#    Defense: 3
+#    Locations:
+#      Head_Top: true
+#    Refineable: true
+#    View: 144
+#    Script: |
+#      bonus bAllStats,3;
+#  - Id: 5202
+#    AegisName: Pumpkin_Hat_
+#    Name: Pumpkin Hat
+#    Type: Armor
+#    Buy: 20
+#    Weight: 200
+#    Defense: 2
+#    Locations:
+#      Head_Top: true
+#    Refineable: true
+#    View: 206
+#    Script: |
+#      bonus bAllStats,2; bonus2 bSubRace,RC_Demon,5; bonus3 bAddMonsterDropItem,529,RC_DemiHuman,1500;
+#  - Id: 5204
+#    AegisName: Event_Pierrot_Nose
+#    Name: Rudolf's Red Nose
+#    Type: Armor
+#    Buy: 20
+#    Weight: 100
+#    Locations:
+#      Head_Low: true
+#    View: 49
+#    Script: |
+#      bonus2 bResEff,Eff_Blind,3000; bonus2 bAddMonsterDropItem,12130,30;
+#  - Id: 5264
+#    AegisName: Aussie_Flag_Hat
+#    Name: Australian Flag Hat
+#    Type: Armor
+#    Buy: 20
+#    Weight: 500
+#    Defense: 4
+#    Locations:
+#      Head_Top: true
+#    Refineable: true
+#    View: 304
+#    Script: |
+#      bonus bAllStats,2;
+#  - Id: 5356
+#    AegisName: Pumpkin_Hat_H
+#    Name: Pumpkin Hat
+#    Type: Armor
+#    Buy: 20
+#    Weight: 200
+#    Defense: 2
+#    Locations:
+#      Head_Top: true
+#    Refineable: true
+#    View: 206
+#    Script: |
+#      bonus bAllStats,2; bonus2 bSubRace,RC_Demon,5; bonus2 bMagicAddRace,RC_Demon,5;
+#  - Id: 5384
+#    AegisName: Santa_Hat_1
+#    Name: Twin Pompom By JB
+#    Type: Armor
+#    Buy: 20
+#    Weight: 200
+#    Defense: 2
+#    Slots: 1
+#    Locations:
+#      Head_Top: true
+#    EquipLevelMin: 20
+#    Refineable: true
+#    View: 390
+#    Script: |
+#      bonus bLuk,3; bonus2 bResEff,Eff_Curse,2000; bonus bVariableCastrate,-2; bonus bAspdRate,4; bonus2 bAddMonsterDropItem,539,100; bonus2 bAddMonsterDropItem,529,200; bonus2 bAddMonsterDropItem,530,200; autobonus "{ bonus bCritical,10; }",10,5000;
+#  - Id: 5811
+#    AegisName: Santa_Beard
+#    Name: Santa Beard
+#    Type: Armor
+#    Buy: 20
+#    Weight: 100
+#    Defense: 5
+#    Locations:
+#      Head_Low: true
+#    View: 25
+#    Script: |
+#      bonus2 bSubRace,RC_Brute,5; bonus2 bSubRace,RC_Player_Doram,5;
+#  - Id: 11702
+#    AegisName: Moon_Cookie
+#    Name: Moon Cookie
+#    Type: Delayconsume
+#    Weight: 10
+#    Script: |
+#      sc_end SC_POISON; sc_end SC_SILENCE; sc_end SC_BLIND; sc_end SC_CONFUSION; sc_end SC_CURSE; sc_end SC_HALLUCINATION; itemskill "AL_BLESSING",7;
+#  - Id: 12131
+#    AegisName: Lucky_Potion
+#    Name: Lucky Potion
+#    Type: Healing
+#    Buy: 2
+#    Weight: 100
+#    Script: |
+#      sc_start SC_LUKFOOD,180000,15;
+#  - Id: 12143
+#    AegisName: Red_Can
+#    Name: Red Can
+#    Type: Usable
+#    Buy: 50000
+#    Weight: 300
+#    Script: |
+#      percentheal 25,25;
+
+# Event effect: Summon monster? Probably Rice_Cake. x_x
+#=============================================================
+#  - Id: 12199
+#    AegisName: Rice_Scroll
+#    Name: Rice Scroll
+#    Type: Usable
+#  - Id: 12200
+#    AegisName: Event_Cake
+#    Name: Event Cake
+#    Type: Usable
+#    Buy: 20
+#    Weight: 50
+#    Script: |
+#      itemskill "PR_MAGNIFICAT",3;
+#  - Id: 12238
+#    AegisName: New_Year_Rice_Cake_1
+#    Name: New Year Rice Cake
+#    Type: Healing
+#    Buy: 20
+#    Weight: 100
+#    Script: |
+#      percentheal 20,15; sc_start SC_STRFOOD,1200000,3; sc_start SC_INTFOOD,1200000,3; sc_start SC_LUKFOOD,1200000,3; sc_start SC_SPEEDUP1,5000,0;
+#  - Id: 12239
+#    AegisName: New_Year_Rice_Cake_2
+#    Name: New Year Rice Cake
+#    Type: Healing
+#    Buy: 20
+#    Weight: 100
+#    Script: |
+#      percentheal 20,15; sc_start SC_DEXFOOD,1200000,3; sc_start SC_AGIFOOD,1200000,3; sc_start SC_VITFOOD,1200000,3; sc_start SC_SPEEDUP1,5000,0;
+
+# iRO St. Patrick's Day Event 2008
+#=============================================================
+#  - Id: 7915
+#    AegisName: Copper_Coin_
+#    Name: Bronze Coin
+#    Type: Etc
+#    Weight: 10
+#    AliasName: Copper_Coin
+#  - Id: 7916
+#    AegisName: Silver_Coin_
+#    Name: Silver Coin
+#    Type: Etc
+#    Weight: 10
+#    AliasName: Silver_Coin
+#  - Id: 12715
+#    AegisName: Black_Treasure_Chest
+#    Name: Black Treasure Chest
+#    Type: Usable
+#    Weight: 200
+#    AliasName: Treasure_Box_
+#    Script: |
+#      callfunc "F_08stpattyseventbox";
+
+# iRO Valentine's Day Event 2009
+#=============================================================
+#  - Id: 5817
+#    AegisName: Valentine's_Emblem
+#    Name: Valentine's Emblem
+#    Type: Armor
+#    Buy: 10
+#    Defense: 3
+#    Locations:
+#      Right_Accessory: true
+#      Left_Accessory: true
+#    Script: |
+#      bonus bAtkRate,3; bonus bMatkRate,3; bonus bAllStats,2; bonus bFlee,10; bonus bAspd,1; bonus bMdef,3; bonus2 bSkillAtk,"AL_HEAL",10; bonus2 bSkillHeal,"AL_HEAL",10; bonus2 bSkillHeal,"AM_POTIONPITCHER",10; bonus2 bAddItemGroupHealRate,IG_Potion,10;
+#  - Id: 7946
+#    AegisName: Gold_Ring_Of_Valentine
+#    Name: Gold Ring Of Valentine
+#    Type: Etc
+#    Buy: 10
+#  - Id: 7947
+#    AegisName: Silver_Ring_Of_Valentine
+#    Name: Silver Ring Of Valentine
+#    Type: Etc
+#    Buy: 10
+#  - Id: 7948
+#    AegisName: Box
+#    Name: Box
+#    Type: Etc
+#    Buy: 10
+#    Weight: 10
+#  - Id: 12742
+#    AegisName: Valentine_Gift_Box_M
+#    Name: Valentine Gift Box
+#    Type: Usable
+#    Buy: 10
+#    Script: |
+#      getitem 7946,1;
+#  - Id: 12743
+#    AegisName: Valentine_Gift_Box_F
+#    Name: Valentine Gift Box
+#    Type: Usable
+#    Buy: 10
+#    Script: |
+#      getitem 7947,1;
+#  - Id: 12744
+#    AegisName: Chocolate_Box
+#    Name: Chocolate Box
+#    Type: Usable
+#    Buy: 10
+#    Script: |
+#      getitem 558,1;
+#  - Id: 14466
+#    AegisName: Valentine's_Emblem_Box
+#    Name: Valentine's Emblem Box
+#    Type: Usable
+#    Buy: 10
+#    Script: |
+#      getitem 5817,1;
+
+# iRO Halloween Event 2009
+#=============================================================
+#  - Id: 5668
+#    AegisName: Weird_Pumpkin_Hat
+#    Name: Weird Pumpkin Hat
+#    Type: Armor
+#    Buy: 20
+#    Defense: 5
+#    Locations:
+#      Head_Top: true
+#    Refineable: true
+#    View: 206
+#    Script: |
+#      bonus bMdef,5; bonus2 bAddMonsterDropItem,12192,2500;
+#  - Id: 6298
+#    AegisName: Crushed_Pumpkin
+#    Name: Crushed Pumpkin
+#    Type: Etc
+#  - Id: 6299
+#    AegisName: Worn_Fabric
+#    Name: Worn Fabric
+#    Type: Etc
+
+# Old Tuxedo and Wedding Dress, will display the outfit when worn.
+#==================================================================
+#  - Id: 2338
+#    AegisName: Wedding_Dress
+#    Name: Wedding Dress
+#    Type: Armor
+#    Buy: 43000
+#    Weight: 500
+#    Jobs:
+#      All: true
+#      Novice: false
+#    Locations:
+#      Armor: true
+#    Refineable: true
+#    EquipScript: |
+#      sc_start SC_WEDDING,INFINITE_TICK,0;
+#    UnEquipScript: |
+#      sc_end SC_WEDDING;
+#  - Id: 7170
+#    AegisName: Tuxedo
+#    Name: Tuxedo
+#    Type: Armor
+#    Buy: 43000
+#    Weight: 10
+#    Jobs:
+#      All: true
+#      Novice: false
+#    Gender: Male
+#    Locations:
+#      Armor: true
+#    Refineable: true
+#    EquipScript: |
+#      sc_start SC_WEDDING,INFINITE_TICK,0;
+#    UnEquipScript: |
+#      sc_end SC_WEDDING;
+
+# Non-kRO Eden Group Mark effect
+#=============================================================
+#  - Id: 22508
+#    AegisName: Para_Team_Mark_
+#    Name: Eden Group Mark
+#    Type: Delayconsume
+#    Script: |
+#      unitskilluseid getcharid(3),"AL_TELEPORT",3;
+  - Id: 7804
+    AegisName: Battleground_Badge
+    Name: Battleground Badge
+    Type: Etc
+    Buy: 0
+    Sell: 0
+    Weight: 0
\ No newline at end of file
diff --git a/db/import/map_cache.dat b/db/import/map_cache.dat
new file mode 100644
index 000000000..75586af90
Binary files /dev/null and b/db/import/map_cache.dat differ
diff --git a/db/import/map_index.txt b/db/import/map_index.txt
new file mode 100644
index 000000000..2116086e1
--- /dev/null
+++ b/db/import/map_index.txt
@@ -0,0 +1,36 @@
+//======================================================================================
+// Map Index
+//======================================================================================
+//Contains the list of maps with their respective IDs for inter-server use.
+//IDs must never change, therefore any new maps need to be added at the end,
+//and old ones must not be removed, but may be replaced.
+//Format:
+//mapname<tab>index <- specifies index for this map
+//mapname <- map will use index of previous map +1
+//Note that map index 0 is special and reserved for "error" status. 
+
+//======================================================================================
+//Place your custom maps with a starting ID here.
+//======================================================================================
+//Example:
+//
+//mymap	1250
+//mymap-2
+
+// BG Extended
+bg_ctf
+bg_tdm
+bg_eoe
+bg_con01
+bg_con02
+bg_con03
+bg_con04
+bg_con05
+bg_con06
+bg_kvm
+bg_sc
+bg_dom
+bg_rush01
+bg_rush02
+bg_rush03
+bg_rush04
diff --git a/npc/battleground-extended/1-bg_ctf.txt b/npc/battleground-extended/1-bg_ctf.txt
new file mode 100644
index 000000000..d990de79f
--- /dev/null
+++ b/npc/battleground-extended/1-bg_ctf.txt
@@ -0,0 +1,470 @@
+// (c) 2008 - 2012 eAmod Project; Andres Garbanzo / Zephyrus
+//
+//  - gaiaro.staff@yahoo.com
+//  - MSN andresjgm.cr@hotmail.com
+//  - Skype: Zephyrus_cr
+//  - Site: http://dev.terra-gaming.com
+//
+// This file is NOT public - you are not allowed to distribute it.
+// Authorized Server List : http://dev.terra-gaming.com/index.php?/topic/72-authorized-eamod-servers/
+// eAmod is a non Free, extended version of eAthena Ragnarok Private Server.
+
+// ==============================================================================
+// BattleGround System - Flavius Capture the Flag
+// ==============================================================================
+
+// Battleground Flags
+// *********************************************************************
+
+bg_ctf,196,91,0	script	Alpha Crystal::Team1_Flag	1914,1,1,{
+	end;
+
+OnTouch:
+	if( $@BG_Status != 1 || bg_current_mode() != bg_info("bg_ctf", BG_INFO_ID) || HP < 1 )
+		end;
+
+	if( getcharid(4) == $@BG_Team2 && .Flag_Status < 2 )
+	{ // Flag Captured
+		set .Flag_Status, 2; // Taken
+		set .Flag_Carrier, getcharid(0);
+
+		sc_end SC_HIDING;
+		sc_end SC_CLOAKING;
+		sc_end SC_CHASEWALK;
+		// Renewal invisibility
+		sc_end SC_CLOAKINGEXCEED;
+		sc_end SC_CAMOUFLAGE;
+		sc_end SC__INVISIBILITY;
+
+		pcblock 1,1; // Block Skills/Items
+
+		mapannounce "bg_ctf","Alpha Crystal Taken by [ " + strcharinfo(0) + " ]",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+		//bg_rankpoints "ctf_taken",1;
+		disablenpc "Team1_Flag";
+		addtimer 2000, "Flavius_CTF::OnAlphaFlash";
+		stopnpctimer;
+	}
+	else if( getcharid(4) == $@BG_Team1 )
+	{
+		if( .Flag_Status == 0 && getvariableofnpc(.Flag_Carrier,"Team2_Flag") == getcharid(0) )
+		{
+			set getvariableofnpc(.Flag_Carrier,"Team2_Flag"),0;
+			set .Flag_Carrier, 0;
+			mapannounce "bg_ctf","Omega Crystal Captured by [ " + strcharinfo(0) + " ]!!",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+			//bg_rankpoints "ctf_captured",1;
+			pcblock 1,0; // UnBlock Skills/Items
+			stopnpctimer;
+			donpcevent "Flavius_CTF::OnTeam1Score";
+		}
+		else if( .Flag_Status == 1 )
+		{
+			mapannounce "bg_ctf","Alpha Crystal Returned by [ " + strcharinfo(0) + " ]!!",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+			//bg_rankpoints "fame",1;
+			disablenpc "Team1_Flag";
+			sleep 2000;
+			movenpc "Team1_Flag",196,91; // Back to Base
+			set .Flag_Status, 0;
+			initnpctimer;
+			enablenpc "Team1_Flag";
+		}
+	}
+	end;
+
+OnTimer2000:
+	stopnpctimer;
+	if( .Flag_Status < 2 )
+	{
+		getmapxy .@m$, .@x, .@y, BL_NPC;
+		viewpointmap "bg_ctf",1, .@x, .@y, 1, bg_info(bg_current_mode(), BG_INFO_COLOR);
+		specialeffect 223;
+		initnpctimer;
+	}
+	end;
+
+OnBase:
+	movenpc "Team1_Flag",196,91;
+	set .Flag_Status, 0;
+	set .Flag_Carrier, 0;
+	initnpctimer;
+	enablenpc "Team1_Flag";
+	end;
+}
+
+bg_ctf,63,91,0	script	Omega Crystal::Team2_Flag	1915,1,1,{
+	end;
+
+OnTouch:
+	if( $@BG_Status != 1 || bg_current_mode() != bg_info("bg_ctf", BG_INFO_ID) || HP < 1 )
+		end;
+
+	if( getcharid(4) == $@BG_Team1 && .Flag_Status < 2 )
+	{ // Flag Captured
+		set .Flag_Status, 2; // Taken
+		set .Flag_Carrier, getcharid(0);
+
+		sc_end SC_HIDING;
+		sc_end SC_CLOAKING;
+		sc_end SC_CHASEWALK;
+		// Renewal invisibility
+		sc_end SC_CLOAKINGEXCEED;
+		sc_end SC_CAMOUFLAGE;
+		sc_end SC__INVISIBILITY;
+
+		pcblock 1,1; // Block Skills/Items
+
+		mapannounce "bg_ctf","Omega Crystal Taken by [ " + strcharinfo(0) + " ]",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+		//bg_rankpoints "ctf_taken",1;
+		disablenpc "Team2_Flag";
+		addtimer 2000, "Flavius_CTF::OnOmegaFlash";
+		stopnpctimer;
+	}
+	else if( getcharid(4) == $@BG_Team2 )
+	{
+		if( .Flag_Status == 0 && getvariableofnpc(.Flag_Carrier,"Team1_Flag") == getcharid(0) )
+		{
+			set getvariableofnpc(.Flag_Carrier,"Team1_Flag"),0;
+			set .Flag_Carrier, 0;
+			mapannounce "bg_ctf","Alpha Crystal Captured by [ " + strcharinfo(0) + " ]!!",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+			//bg_rankpoints "ctf_captured",1;
+			pcblock 1,0; // UnBlock Skills/Items
+			stopnpctimer;
+			donpcevent "Flavius_CTF::OnTeam2Score";
+		}
+		else if( .Flag_Status == 1 )
+		{
+			mapannounce "bg_ctf","Omega Crystal Returned by [ " + strcharinfo(0) + " ]!!",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+			//bg_rankpoints "fame",1;
+			disablenpc "Team2_Flag";
+			sleep 2000;
+			movenpc "Team2_Flag",63,91; // Back to Base
+			set .Flag_Status, 0;
+			initnpctimer;
+			enablenpc "Team2_Flag";
+		}
+	}
+	end;
+
+OnTimer2000:
+	stopnpctimer;
+	if( .Flag_Status < 2 )
+	{
+		getmapxy .@m$, .@x, .@y, BL_NPC;
+		viewpointmap "bg_ctf",1, .@x, .@y, 2, bg_info(bg_current_mode(), BG_INFO_COLOR);
+		specialeffect 223;
+		initnpctimer;
+	}
+	end;
+
+OnBase:
+	movenpc "Team2_Flag",63,91;
+	set .Flag_Status, 0;
+	set .Flag_Carrier, 0;
+	initnpctimer;
+	enablenpc "Team2_Flag";
+	end;
+}
+
+// Battleground Engine
+// *********************************************************************
+
+-	script	Flavius_CTF	-1,{
+	end;
+
+OnAlphaFlash:
+	if( getvariableofnpc(.Flag_Carrier,"Team1_Flag") == getcharid(0) && $@BG_Status == 1 && bg_current_mode() == bg_info("bg_ctf", BG_INFO_ID) )
+	{
+		getmapxy .@m$, .@x, .@y, BL_PC;
+		viewpointmap "bg_ctf",1, .@x, .@y, 1, bg_info(bg_current_mode(), BG_INFO_COLOR);
+		specialeffect2 73;
+		emotion ET_HELP,getcharid(3);
+		addtimer 2000, "Flavius_CTF::OnAlphaFlash";
+		percentheal -5,-5;
+	}
+	end;
+
+OnOmegaFlash:
+	if( getvariableofnpc(.Flag_Carrier,"Team2_Flag") == getcharid(0) && $@BG_Status == 1 && bg_current_mode() == bg_info("bg_ctf", BG_INFO_ID) )
+	{
+		getmapxy .@m$, .@x, .@y, BL_PC;
+		viewpointmap "bg_ctf",1, .@x, .@y, 2, bg_info(bg_current_mode(), BG_INFO_COLOR);
+		specialeffect2 73;
+		emotion ET_HELP,getcharid(3);
+		addtimer 2000, "Flavius_CTF::OnOmegaFlash";
+		percentheal -5,-5;
+	}
+	end;
+
+OnInit:
+	disablenpc "Team1_Flag";
+	disablenpc "Team2_Flag";
+	end;
+
+OnTeam1Quit:
+	bg_desert;
+	set @killer_bg_src, 0;
+	if( $@BG_Status != 0 && bg_current_mode() == bg_info("bg_ctf", BG_INFO_ID) )
+		donpcevent "BG_Queue_Join::OnJoinEvent";
+OnTeam1Die:
+	if( $@BG_Status == 1 && bg_current_mode() == bg_info("bg_ctf", BG_INFO_ID) && getvariableofnpc(.Flag_Carrier,"Team2_Flag") == getcharid(0) )
+	{ // Drop Flag
+		set getvariableofnpc(.Flag_Carrier,"Team2_Flag"), 0;
+		pcblock 1,0; // UnBlock Skills/Items
+		getmapxy .@m$, .@x, .@y, BL_PC;
+		movenpc "Team2_Flag", .@x, .@y;
+		mapannounce "bg_ctf","Omega Flag Droped by [ " + strcharinfo(0) + " ]",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+		//bg_rankpoints "ctf_droped",1;
+		//bg_rankpoints "fame",1,@killer_bg_src;
+		set getvariableofnpc(.Flag_Status,"Team2_Flag"), 1; // OnFloor
+		initnpctimer "Team2_Flag";
+		enablenpc "Team2_Flag";
+	}
+	end;
+
+OnTeam2Quit:
+	bg_desert;
+	set @killer_bg_src, 0;
+	if( $@BG_Status != 0 && bg_current_mode() == bg_info("bg_ctf", BG_INFO_ID) )
+		donpcevent "BG_Queue_Join::OnJoinEvent";
+OnTeam2Die:
+	if( $@BG_Status == 1 && bg_current_mode() == bg_info("bg_ctf", BG_INFO_ID) && getvariableofnpc(.Flag_Carrier,"Team1_Flag") == getcharid(0) )
+	{ // Drop Flag
+		set getvariableofnpc(.Flag_Carrier,"Team1_Flag"), 0;
+		pcblock 1,0; // UnBlock Skills/Items
+		getmapxy .@m$, .@x, .@y, BL_PC;
+		movenpc "Team1_Flag", .@x, .@y;
+		mapannounce "bg_ctf","Alpha Flag Droped by [ " + strcharinfo(0) + " ]",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+		//bg_rankpoints "ctf_droped",1;
+		//bg_rankpoints "fame",1,@killer_bg_src;
+		set getvariableofnpc(.Flag_Status,"Team1_Flag"), 1; // OnFloor
+		initnpctimer "Team1_Flag";
+		enablenpc "Team1_Flag";
+	}
+	end;
+	
+OnReady:
+	if( bg_current_mode() != bg_info("bg_ctf", BG_INFO_ID) )
+		end;
+	set $@BG_Status, 1;
+	initnpctimer;
+	// BG Variables
+	set .Team1_Score, 0;
+	set .Team2_Score, 0;
+	sleep 2000;
+	bg_warp $@BG_Team1,"bg_ctf",165,127;
+	bg_warp $@BG_Team2,"bg_ctf",94,56;
+	sleep 2000;
+	// Respawn NPC's
+	donpcevent "#guictf_respawn::OnBGStart";
+	donpcevent "#croctf_respawn::OnBGStart";
+	// Start Match!!
+	donpcevent "Flavius_CTF::OnMatchStart";
+	end;
+
+OnBGTeam1Active:
+	warp "bg_ctf",228,39;
+	donpcevent "BG_Queue_Join::OnJoinEvent";
+	end;
+
+OnBGTeam2Active:
+	warp "bg_ctf",30,38;
+	donpcevent "BG_Queue_Join::OnJoinEvent";
+	end;
+	
+OnMatchStart:
+	if( $@BG_Status != 1 || bg_current_mode() != bg_info("bg_ctf", BG_INFO_ID) )
+		end;
+
+	// Flags2Base
+	donpcevent "Team1_Flag::OnBase";
+	donpcevent "Team2_Flag::OnBase";
+	mapannounce "bg_ctf","The Flags have been set to their Bases!!",8;
+	end;
+
+OnTeam1Score:
+	set .Team1_Score, .Team1_Score + 1;
+	donpcevent "Flavius_CTF::OnMatchStop";
+	end;
+
+OnTeam2Score:
+	set .Team2_Score, .Team2_Score + 1;
+	donpcevent "Flavius_CTF::OnMatchStop";
+	end;
+
+OnMatchStop:
+	disablenpc "Team1_Flag";
+	disablenpc "Team2_Flag";
+	bg_updatescore "bg_ctf",.Team1_Score,.Team2_Score;
+
+	viewpointmap "bg_ctf",2, 0, 0, 1, 0x0000FF;
+	viewpointmap "bg_ctf",2, 0, 0, 2, 0xFF0000;
+
+	if( .Team1_Score > 2 )
+	{ // Team 1 Won
+		mapannounce "bg_ctf","The " + bg_get_data($@BG_Team1,2) + " army has won the Battle of Flavius CTF!",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+		donpcevent "Flavius_CTF::OnMatchEnd";
+	}
+	else if( .Team2_Score > 2 )
+	{ // Team 2 Won
+		mapannounce "bg_ctf","The " + bg_get_data($@BG_Team2,2) + " army has won the Battle of Flavius CTF!",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+		donpcevent "Flavius_CTF::OnMatchEnd";
+	}
+	else
+	{ // Keep Playing
+		sleep 8000;
+		donpcevent "Flavius_CTF::OnMatchStart";
+	}
+	end;
+
+OnTimer600000:
+	mapannounce "bg_ctf","The Battle will ends in 5 minutes!!",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+	end;
+
+OnTimer840000:
+	mapannounce "bg_ctf","The Battle will ends in 1 minute!!",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+	end;
+
+OnTimer900000:
+OnPrematureEnd:
+	disablenpc "Team1_Flag";
+	disablenpc "Team2_Flag";
+
+	viewpointmap "bg_ctf",2, 0, 0, 1, bg_info(bg_current_mode(), BG_INFO_COLOR);
+	viewpointmap "bg_ctf",2, 0, 0, 2, bg_info(bg_current_mode(), BG_INFO_COLOR);
+
+	if( .Team1_Score > .Team2_Score )
+		mapannounce "bg_ctf","The " + bg_get_data($@BG_Team1,2) + " army has won the Battle of Flavius CTF!",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+	else if( .Team1_Score < .Team2_Score )
+		mapannounce "bg_ctf","The " + bg_get_data($@BG_Team2,2) + " army has won the Battle of Flavius CTF!",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+	else
+		mapannounce "bg_ctf","The battle is over. This is a Tie...!",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+	donpcevent "Flavius_CTF::OnMatchEnd";
+	end;
+
+OnMatchEnd:
+	stopnpctimer;
+	disablenpc "Team1_Flag";
+	disablenpc "Team2_Flag";
+	donpcevent "#guictf_respawn::OnBGStop";
+	donpcevent "#croctf_respawn::OnBGStop";
+	set $@BG_Status, 2;
+	bg_reserve "bg_ctf", true;
+	// =======================================================
+	// Team Rewards
+	// =======================================================
+	if( .Team1_Score > .Team2_Score )
+	{
+		callfunc("Reward_BG","bg_ctf", 1);
+	}
+	else if( .Team2_Score > .Team1_Score )
+	{
+		callfunc("Reward_BG","bg_ctf", 2);
+	}
+	else
+	{
+		callfunc("Reward_BG","bg_ctf", 0);
+	}
+	// =======================================================
+	set .Team1_Score, 0;
+	set .Team2_Score, 0;
+	sleep 5000;
+	bg_unbook "bg_ctf";
+	donpcevent "BG_Queue_Join::OnRotate";
+	bg_updatescore "bg_ctf",0,0;
+	end;
+}
+
+// Battleground Therapist
+// *********************************************************************
+bg_ctf,228,45,5	script	Therapist in battle#ctf1	4_F_SISTER,{
+	mes "[Therapist in battle]";
+	mes "Just close your eyes, take a deep breath";
+	mes "and you free yourself from the pain.";
+	specialeffect2 312;
+	percentheal 100,100;
+	repairall;
+	close2;
+	openstorage;
+	end;
+}
+
+bg_ctf,31,45,5	script	Therapist in battle#ctf2	4_F_SISTER,{
+	mes "[Therapist in battle]";
+	mes "Just close your eyes, take a deep breath";
+	mes "and you free yourself from the pain.";
+	specialeffect2 312;
+	percentheal 100,100;
+	repairall;
+	close2;
+	openstorage;
+	end;
+}
+// Battleground Respawn
+// *********************************************************************
+
+bg_ctf,228,39,0	script	#guictf_respawn	139,{
+	end;
+
+OnBGStart:
+	initnpctimer;
+	end;
+
+OnBGStop:
+	stopnpctimer;
+	end;
+
+OnTimer24000:
+	misceffect 83;
+	end;
+
+OnTimer25000:
+	areapercentheal "bg_ctf",214,51,244,22,100,100;
+	areawarp "bg_ctf",214,51,244,22,"bg_ctf",191,121;
+	initnpctimer;
+	end;
+}
+
+bg_ctf,30,38,0	script	#croctf_respawn	139,{
+	end;
+
+OnBGStart:
+	initnpctimer;
+	end;
+
+OnBGStop:
+	stopnpctimer;
+	end;
+
+OnTimer24000:
+	misceffect 83;
+	end;
+
+OnTimer25000:
+	areapercentheal "bg_ctf",16,51,45,24,100,100;
+	areawarp "bg_ctf",16,51,45,24,"bg_ctf",68,62;
+	initnpctimer;
+	end;
+}
+
+// Flags
+// *********************************************************************
+
+bg_ctf,166,86,1	duplicate(Base Flag#bg)	Alpha Base#bat23	973
+bg_ctf,166,97,1	duplicate(Base Flag#bg)	Alpha Base#bat24	973
+
+bg_ctf,93,86,1	duplicate(Base Flag#bg)	Omega Base#bat22	974
+bg_ctf,93,97,1	duplicate(Base Flag#bg)	Omega Base#bat23	974
+
+// MapFlags
+// *********************************************************************
+
+bg_ctf	mapflag	battleground	2
+bg_ctf	mapflag	nomemo
+bg_ctf	mapflag	nosave	SavePoint
+bg_ctf	mapflag	noteleport
+bg_ctf	mapflag	nowarp
+bg_ctf	mapflag	nowarpto
+bg_ctf	mapflag	noreturn
+bg_ctf	mapflag	nobranch
+bg_ctf	mapflag	nopenalty
+//bg_ctf	mapflag	noemergencycall
+bg_ctf	mapflag	nodrop
diff --git a/npc/battleground-extended/2-bg_tdm.txt b/npc/battleground-extended/2-bg_tdm.txt
new file mode 100644
index 000000000..dcdbe9bc5
--- /dev/null
+++ b/npc/battleground-extended/2-bg_tdm.txt
@@ -0,0 +1,259 @@
+// (c) 2008 - 2012 eAmod Project; Andres Garbanzo / Zephyrus
+//
+//  - gaiaro.staff@yahoo.com
+//  - MSN andresjgm.cr@hotmail.com
+//  - Skype: Zephyrus_cr
+//  - Site: http://dev.terra-gaming.com
+//
+// This file is NOT public - you are not allowed to distribute it.
+// Authorized Server List : http://dev.terra-gaming.com/index.php?/topic/72-authorized-eamod-servers/
+// eAmod is a non Free, extended version of eAthena Ragnarok Private Server.
+
+// ==============================================================================
+// BattleGround System - Flavius TeamDeathMatch
+// ==============================================================================
+
+// Battleground Engine
+// *********************************************************************
+
+-	script	Flavius_TD	-1,{
+	end;
+
+OnTeam1Quit:
+	bg_desert;
+	if( $@BG_Status != 0 && bg_current_mode() == bg_info("bg_tdm", BG_INFO_ID) )
+		donpcevent "BG_Queue_Join::OnJoinEvent";
+OnTeam1Die:
+	if( $@BG_Status == 1 && bg_current_mode() == bg_info("bg_tdm", BG_INFO_ID) )
+	{
+		set .Team1_Score, .Team1_Score - 1;
+		donpcevent "Flavius_TD::OnValidateScore";
+	}
+	end;
+
+OnTeam2Quit:
+	bg_desert;
+	if( $@BG_Status != 0 && bg_current_mode() == bg_info("bg_tdm", BG_INFO_ID) )
+		donpcevent "BG_Queue_Join::OnJoinEvent";
+OnTeam2Die:
+	if( $@BG_Status == 1 && bg_current_mode() == bg_info("bg_tdm", BG_INFO_ID) )
+	{
+		set .Team2_Score, .Team2_Score - 1;
+		donpcevent "Flavius_TD::OnValidateScore";
+	}
+	end;
+
+OnReady:
+	if( bg_current_mode() != bg_info("bg_tdm", BG_INFO_ID) )
+		end;
+	set $@BG_Status, 1;
+	initnpctimer;
+	set .Team1_Score, 35;
+	set .Team2_Score, 35;
+	bg_updatescore "bg_tdm",.Team1_Score,.Team2_Score;
+	sleep 2000;
+	bg_warp $@BG_Team1,"bg_tdm",53,128;
+	bg_warp $@BG_Team2,"bg_tdm",146,55;
+	sleep 2000;
+	bg_team_reveal $@BG_Team1;
+	bg_team_reveal $@BG_Team2;
+	donpcevent "#guitd_respawn::OnBGStart";
+	donpcevent "#crotd_respawn::OnBGStart";
+	end;
+
+OnBGTeam1Active:
+	warp "bg_tdm",44,99;
+	donpcevent "BG_Queue_Join::OnJoinEvent";
+	end;
+
+OnBGTeam2Active:
+	warp "bg_tdm",100,43;
+	donpcevent "BG_Queue_Join::OnJoinEvent";
+	end;
+	
+OnValidateScore:
+	if( $@BG_Status != 1 || bg_current_mode() != bg_info("bg_tdm", BG_INFO_ID) )
+		end;
+
+	bg_updatescore "bg_tdm",.Team1_Score,.Team2_Score;
+	set .@Team1Count, bg_get_data($@BG_Team1, 0);
+	set .@Team2Count, bg_get_data($@BG_Team2, 0);
+
+	if( .Team2_Score <= 0 )
+	{ // Team 1 Won
+		callfunc("Reward_BG","bg_tdm", 1);
+		mapannounce "bg_tdm","The " + bg_get_data($@BG_Team1,2) + " army has won the Battle of Flavius TD!",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+	}
+	else if( .Team1_Score <= 0 )
+	{ // Team 2 Won
+		callfunc("Reward_BG","bg_tdm", 2);
+		mapannounce "bg_tdm","The " + bg_get_data($@BG_Team2,2) + " army has won the Battle of Flavius TD!",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+	}
+	else if( .@Team2Count == 0 )
+	{ // All Team 2 Players quit
+		set .@Rate, 25 - .Team2_Score;
+		callfunc("Reward_BG","bg_tdm", 1, 10 * .@Rate / 25);
+		mapannounce "bg_tdm","The " + bg_get_data($@BG_Team1,2) + " army has won the Battle of Flavius TD!",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+	}
+	else if( .@Team1Count == 0 )
+	{ // All Team 1 Players quit
+		set .@Rate, 25 - .Team1_Score;
+		callfunc("Reward_BG","bg_tdm", 2, 10 * .@Rate / 25);
+		mapannounce "bg_tdm","The " + bg_get_data($@BG_Team2,2) + " army has won the Battle of Flavius TD!",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+	}
+	else end;
+	donpcevent "Flavius_TD::OnMatchEnd";
+	end;
+
+OnTimer600000:
+	mapannounce "bg_tdm","The Battle will ends in 5 minutes!!",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+	end;
+
+OnTimer840000:
+	mapannounce "bg_tdm","The Battle will ends in 1 minute!!",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+	end;
+
+OnTimer900000:
+OnPrematureEnd:
+
+	// =======================================================
+	// Team Rewards
+	// =======================================================	
+	if( .Team1_Score > .Team2_Score )
+	{
+		callfunc("Reward_BG","bg_tdm", 1);
+		mapannounce "bg_tdm","The " + bg_get_data($@BG_Team1,2) + " army has won the Battle of Flavius TD!",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+	}
+	else if( .Team1_Score < .Team2_Score )
+	{
+		callfunc("Reward_BG","bg_tdm", 2);
+		mapannounce "bg_tdm","The " + bg_get_data($@BG_Team2,2) + " army has won the Battle of Flavius TD!",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+	}
+	else
+	{
+		callfunc("Reward_BG","bg_tdm", 0);
+		mapannounce "bg_tdm","The battle is over. This is a Tie...!",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+	}
+	donpcevent "Flavius_TD::OnMatchEnd";
+	end;
+
+OnMatchEnd:
+	stopnpctimer;
+	donpcevent "#guitd_respawn::OnBGStop";
+	donpcevent "#crotd_respawn::OnBGStop";
+	set $@BG_Status, 2;
+	bg_reserve "bg_tdm", true;
+	set .Team1_Score, 35;
+	set .Team2_Score, 35;
+	sleep 5000;
+	bg_unbook "bg_tdm";
+	donpcevent "BG_Queue_Join::OnRotate";
+	bg_updatescore "bg_tdm",35,35;
+	end;
+}
+
+// Battleground Therapist
+// *********************************************************************
+bg_tdm,35,105,5	script	Therapist in battle#td1	95,{
+	mes "[Therapist in battle]";
+	mes "Just close your eyes, take a deep breath";
+	mes "and you free yourself from the pain.";
+	specialeffect2 312;
+	percentheal 100,100;
+	repairall;
+	close2;
+	openstorage;
+	end;
+}
+
+bg_tdm,98,35,5	script	Therapist in battle#td2	95,{
+	mes "[Therapist in battle]";
+	mes "Just close your eyes, take a deep breath";
+	mes "and you free yourself from the pain.";
+	specialeffect2 312;
+	percentheal 100,100;
+	repairall;
+	close2;
+	openstorage;
+	end;
+}
+
+
+// Battleground Respawn
+// *********************************************************************
+bg_tdm,44,99,0	script	#guitd_respawn	139,{
+	end;
+
+OnBGStart:
+	initnpctimer;
+	end;
+
+OnBGStop:
+	stopnpctimer;
+	end;
+
+OnTimer24000:
+	misceffect 83;
+	end;
+
+OnTimer25000:
+	areapercentheal "bg_tdm",40,98,47,105,100,100;
+	areawarp "bg_tdm",40,98,47,105,"bg_tdm",50,131,77,102;
+	initnpctimer;
+	end;
+}
+
+bg_tdm,100,43,0	script	#crotd_respawn	139,{
+	end;
+
+OnBGStart:
+	initnpctimer;
+	end;
+
+OnBGStop:
+	stopnpctimer;
+	end;
+
+OnTimer24000:
+	misceffect 83;
+	end;
+
+OnTimer25000:
+	areapercentheal "bg_tdm",96,42,103,49,100,100;
+	areawarp "bg_tdm",96,42,103,49,"bg_tdm",122,71,149,52;
+	initnpctimer;
+	end;
+}
+
+// Flags
+// *********************************************************************
+
+bg_tdm,40,105,1	duplicate(Base Flag#bg)	Alpha Base#td_1	973
+bg_tdm,47,105,1	duplicate(Base Flag#bg)	Alpha Base#td_2	973
+
+bg_tdm,96,49,1	duplicate(Base Flag#bg)	Omega Base#td_1	974
+bg_tdm,103,49,1	duplicate(Base Flag#bg)	Omega Base#td_2	974
+
+bg_tdm,76,102,1	duplicate(Base Flag#bg)	Alpha Base#td_3	973
+bg_tdm,89,111,1	duplicate(Base Flag#bg)	Alpha Base#td_4	973
+bg_tdm,61,130,1	duplicate(Base Flag#bg)	Alpha Base#td_5	973
+bg_tdm,51,120,1	duplicate(Base Flag#bg)	Alpha Base#td_6	973
+
+bg_tdm,100,72,1	duplicate(Base Flag#bg)	Omega Base#td_3	974
+bg_tdm,123,81,1	duplicate(Base Flag#bg)	Omega Base#td_4	974
+bg_tdm,138,53,1	duplicate(Base Flag#bg)	Omega Base#td_5	974
+bg_tdm,148,63,1	duplicate(Base Flag#bg)	Omega Base#td_6	974
+
+// MapFlags
+// *********************************************************************
+
+bg_tdm	mapflag	battleground	2
+bg_tdm	mapflag	nomemo
+bg_tdm	mapflag	nosave	SavePoint
+bg_tdm	mapflag	noteleport
+bg_tdm	mapflag	nowarp
+bg_tdm	mapflag	nowarpto
+bg_tdm	mapflag	noreturn
+bg_tdm	mapflag	nobranch
+bg_tdm	mapflag	nopenalty
+bg_tdm	mapflag	nodrop
diff --git a/npc/battleground-extended/3-bg_eoe.txt b/npc/battleground-extended/3-bg_eoe.txt
new file mode 100644
index 000000000..c268cd0ea
--- /dev/null
+++ b/npc/battleground-extended/3-bg_eoe.txt
@@ -0,0 +1,749 @@
+// (c) 2008 - 2012 eAmod Project; Andres Garbanzo / Zephyrus
+//
+//  - gaiaro.staff@yahoo.com
+//  - MSN andresjgm.cr@hotmail.com
+//  - Skype: Zephyrus_cr
+//  - Site: http://dev.terra-gaming.com
+//
+// This file is NOT public - you are not allowed to distribute it.
+// Authorized Server List : http://dev.terra-gaming.com/index.php?/topic/72-authorized-eamod-servers/
+// eAmod is a non Free, extended version of eAthena Ragnarok Private Server.
+
+// ==============================================================================
+// BattleGround System - Tierra Valley Eye of Storm
+// ==============================================================================
+
+// Battleground Engine
+// *********************************************************************
+
+-	script	Tierra_EOS	-1,{
+	end;
+
+OnTeam1Quit:
+	bg_desert;
+	set @killer_bg_src, 0;
+	if( $@BG_Status != 0 && bg_current_mode() == bg_info("bg_eoe", BG_INFO_ID) )
+		donpcevent "BG_Queue_Join::OnJoinEvent";
+OnTeam1Die:
+	if( $@BG_Status == 1 && bg_current_mode() == bg_info("bg_eoe", BG_INFO_ID) && getvariableofnpc(.Flag_Carrier,"Neutral_Flag") == getcharid(0) )
+	{ // Drop Flag
+		pcblock 1,0; // UnBlock Skills/Items
+		getmapxy .@m$, .@x, .@y, BL_PC;
+		movenpc "Neutral_Flag", .@x, .@y;
+		mapannounce "bg_eoe",bg_get_data($@BG_Team1,2) + " have droped the Flag",1,0xFFFFFF;
+		//bg_rankpoints "fame",1,@killer_bg_src;
+		set getvariableofnpc(.Flag_Status,"Neutral_Flag"), 0; // OnFloor
+		set getvariableofnpc(.Flag_Carrier,"Neutral_Flag"), 0;
+		initnpctimer "Neutral_Flag";
+		enablenpc "Neutral_Flag";
+	}
+	end;
+
+OnTeam2Quit:
+	bg_desert;
+	set @killer_bg_src, 0;
+	if( $@BG_Status != 0 && bg_current_mode() == bg_info("bg_eoe", BG_INFO_ID) )
+		donpcevent "BG_Queue_Join::OnJoinEvent";
+OnTeam2Die:
+	if( $@BG_Status == 1 && bg_current_mode() == bg_info("bg_eoe", BG_INFO_ID) && getvariableofnpc(.Flag_Carrier,"Neutral_Flag") == getcharid(0) )
+	{ // Drop Flag
+		pcblock 1,0; // UnBlock Skills/Items
+		getmapxy .@m$, .@x, .@y, BL_PC;
+		movenpc "Neutral_Flag", .@x, .@y;
+		mapannounce "bg_eoe",bg_get_data($@BG_Team2,2) + " have droped the Flag",1,0xFFFFFF;
+		//bg_rankpoints "fame",1,@killer_bg_src;
+		set getvariableofnpc(.Flag_Status,"Neutral_Flag"), 0; // OnFloor
+		set getvariableofnpc(.Flag_Carrier,"Neutral_Flag"), 0;
+		initnpctimer "Neutral_Flag";
+		enablenpc "Neutral_Flag";
+	}
+	end;
+
+OnReady:
+	if( bg_current_mode() != bg_info("bg_eoe", BG_INFO_ID) )
+		end;
+
+	set $@BG_Status, 1;
+	// BG Variables
+	set .Team1_Score, 0;
+	set .Team2_Score, 0;
+	sleep 2000;
+	bg_warp $@BG_Team1,"bg_eoe",57,126;
+	bg_warp $@BG_Team2,"bg_eoe",151,52;
+	sleep 2000;
+	// Respawn NPC's
+	donpcevent "#guieoe_respawn::OnBGStart";
+	donpcevent "#croeoe_respawn::OnBGStart";
+	// Start Match!!
+	donpcevent "North_Base::OnBase";
+	donpcevent "South_Base::OnBase";
+	donpcevent "Neutral_Flag::OnBase";
+	donpcevent "::OnStartStorm";
+	mapannounce "bg_eoe","The Battle of Tierra Valley - Eye of Storm has begun",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+	end;
+
+OnBGTeam1Active:
+	warp "bg_eoe",14,15;
+	donpcevent "BG_Queue_Join::OnJoinEvent";
+	end;
+
+OnBGTeam2Active:
+	warp "bg_eoe",189,161;
+	donpcevent "BG_Queue_Join::OnJoinEvent";
+	end;
+	
+OnFlash:
+	if( getvariableofnpc(.Flag_Carrier,"Neutral_Flag") == getcharid(0) && $@BG_Status == 1 && bg_current_mode() == bg_info("bg_eoe", BG_INFO_ID) )
+	{
+		getmapxy .@m$, .@x, .@y, BL_PC;
+		viewpointmap "bg_eoe",1,.@x,.@y,3,0xFFFF00;
+		specialeffect2 73;
+		emotion ET_HELP,getcharid(3);
+		addtimer 2000, "Tierra_EOS::OnFlash";
+		percentheal -5,-5;
+	}
+	end;
+
+OnTeam1Flag:
+	viewpointmap "bg_eoe",2,0,0,3,0xFFFF00;
+	set .@North, getvariableofnpc(.Owner,"North_Base");
+	set .@South, getvariableofnpc(.Owner,"South_Base");
+
+	if( .@North == .@South )
+	{
+		set .Team1_Score, .Team1_Score + 5;
+		mapannounce "bg_eoe",bg_get_data($@BG_Team1,2) + " captured the Flag [+5 points]",1,0x0000FF;
+	}
+	else
+	{
+		set .Team1_Score, .Team1_Score + 3;
+		mapannounce "bg_eoe",bg_get_data($@BG_Team1,2) + " captured the Flag [+3 points]",1,0x0000FF;
+	}
+
+	donpcevent "Tierra_EOS::OnValidateScore";
+	donpcevent "Neutral_Flag::OnBase";
+	end;
+
+OnTeam2Flag:
+	viewpointmap "bg_eoe",2,0,0,3,0xFFFF00;
+	set .@North, getvariableofnpc(.Owner,"North_Base");
+	set .@South, getvariableofnpc(.Owner,"South_Base");
+
+	if( .@North == .@South )
+	{
+		set .Team2_Score, .Team2_Score + 5;
+		mapannounce "bg_eoe",bg_get_data($@BG_Team2,2) + " captured the Flag [+5 points]",1,0xFF0000;
+	}
+	else
+	{
+		set .Team2_Score, .Team2_Score + 3;
+		mapannounce "bg_eoe",bg_get_data($@BG_Team2,2) + " captured the Flag [+3 points]",1,0xFF0000;
+	}
+
+	donpcevent "Tierra_EOS::OnValidateScore";
+	donpcevent "Neutral_Flag::OnBase";
+	end;
+
+OnNorthScore:
+	if( set(.@North, getvariableofnpc(.Owner,"North_Base")) == 0 )
+		end; // No Owner
+	set .@South, getvariableofnpc(.Owner,"South_Base");
+	if( .@North == .@South )
+	{ // Double Domination
+		if( .@North == $@BG_Team1 )
+			set .Team1_Score, .Team1_Score + 2;
+		else
+			set .Team2_Score, .Team2_Score + 2;
+	}
+	else if( .@North == $@BG_Team1 )
+		set .Team1_Score, .Team1_Score + 1;
+	else
+		set .Team2_Score, .Team2_Score + 1;
+
+	donpcevent "Tierra_EOS::OnValidateScore";
+	end;
+
+OnSouthScore:
+	if( set(.@South, getvariableofnpc(.Owner,"South_Base")) == 0 )
+		end; // No Owner
+	set .@North, getvariableofnpc(.Owner,"North_Base");
+	if( .@North == .@South )
+	{ // Double Domination
+		if( .@South == $@BG_Team1 )
+			set .Team1_Score, .Team1_Score + 2;
+		else
+			set .Team2_Score, .Team2_Score + 2;
+	}
+	else if( .@South == $@BG_Team1 )
+		set .Team1_Score, .Team1_Score + 1;
+	else
+		set .Team2_Score, .Team2_Score + 1;
+
+	donpcevent "Tierra_EOS::OnValidateScore";
+	end;
+
+OnValidateScore:
+	if( .Team1_Score > 35 )
+		set .Team1_Score, 35;
+	if( .Team2_Score > 35 )
+		set .Team2_Score, 35;
+
+	bg_updatescore "bg_eoe",.Team1_Score,.Team2_Score; // Update Visual Score
+
+	if( .Team1_Score < 35 && .Team2_Score < 35 )
+		end; // No winners
+
+OnPrematureEnd:
+	donpcevent "Neutral_Flag::OnDisable";
+	stopnpctimer "North_Base";
+	stopnpctimer "South_Base";
+	donpcevent "#guieoe_respawn::OnBGStop";
+	donpcevent "#croeoe_respawn::OnBGStop";
+	set $@BG_Status, 2;
+	bg_reserve "bg_eoe", true;
+	// =======================================================
+	// Team Rewards
+	// =======================================================
+	if( .Team1_Score >= 35 && .Team2_Score >= 35 )
+	{ // Tie
+		callfunc("Reward_BG","bg_eoe", 0);
+		mapannounce "bg_eoe","The battle is over. This is a Tie...!",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+	}
+	else if( .Team1_Score >= 35 )
+	{ // Team 1 Won
+		callfunc("Reward_BG","bg_eoe", 1);
+		mapannounce "bg_eoe","The " + bg_get_data($@BG_Team1,2) + " has won the Battle of Tierra EoS!",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+	}
+	else if( .Team2_Score >= 35 )
+	{ // Team 2 Won
+		callfunc("Reward_BG","bg_eoe", 2);
+		mapannounce "bg_eoe","The " + bg_get_data($@BG_Team2,2) + " has won the Battle of Tierra EoS!",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+	}
+	// =======================================================
+	set .Team1_Score, 0;
+	set .Team2_Score, 0;
+	sleep 5000;
+	bg_unbook "bg_eoe";
+	donpcevent "BG_Queue_Join::OnRotate";
+	bg_updatescore "bg_eoe",0,0;
+	donpcevent "GEoSNBW::OnDisable";
+	//donpcevent "GEoSCBW::OnDisable";
+	donpcevent "GEoSSBW::OnDisable";
+	donpcevent "CEoSNBW::OnDisable";
+	//donpcevent "CEoSCBW::OnDisable";
+	donpcevent "CEoSSBW::OnDisable";
+	end;
+
+OnBreak:
+	if( $@BG_Status != 1 || bg_current_mode() != bg_info("bg_eoe", BG_INFO_ID) )
+		end;
+
+	if( getcharid(4) == $@BG_Team1 )
+		mapannounce "bg_eoe","Netraul Flag Taken by " + bg_get_data($@BG_Team1,2),1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+	else if( getcharid(4) == $@BG_Team2 )
+		mapannounce "bg_eoe","Netraul Flag Taken by " + bg_get_data($@BG_Team2,2),1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+	else end;
+
+	set getvariableofnpc(.Flag_Status,"Neutral_Flag"), 1;
+	set getvariableofnpc(.Flag_Carrier,"Neutral_Flag"), getcharid(0);
+
+	sc_end SC_HIDING;
+	sc_end SC_CLOAKING;
+	sc_end SC_CHASEWALK;
+
+	// Renewal invisibility
+	sc_end SC_CLOAKINGEXCEED;
+	sc_end SC_CAMOUFLAGE;
+	sc_end SC__INVISIBILITY;
+
+	pcblock 1,1; // Block Skills/Items
+
+	stopnpctimer "Neutral_Flag";
+	disablenpc "Neutral_Flag";
+
+	addtimer 2000, "Tierra_EOS::OnFlash";
+	end;
+}
+
+// Battleground Flag
+// *********************************************************************
+
+bg_eoe,104,90,0	script	Neutral Flag::Neutral_Flag	1911,1,1,{
+	end;
+
+OnTouch:
+	if( $@BG_Status != 1 || bg_current_mode() != bg_info("bg_eoe", BG_INFO_ID) || HP < 1 || .Flag_Status )
+		end;
+
+	if( getcharid(4) == $@BG_Team1 )
+		mapannounce "bg_eoe","Netraul Flag Taken by " + bg_get_data($@BG_Team1,2),1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+	else if( getcharid(4) == $@BG_Team2 )
+		mapannounce "bg_eoe","Netraul Flag Taken by " + bg_get_data($@BG_Team2,2),1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+	else end;
+
+	set .Flag_Status, 1;
+	set .Flag_Carrier, getcharid(0);
+	//bg_rankpoints "fame",1;
+
+	sc_end SC_HIDING;
+	sc_end SC_CLOAKING;
+	sc_end SC_CHASEWALK;
+
+	// Renewal invisibility
+	sc_end SC_CLOAKINGEXCEED;
+	sc_end SC_CAMOUFLAGE;
+	sc_end SC__INVISIBILITY;
+
+	pcblock 1,1; // Block Skills/Items
+
+	disablenpc "Neutral_Flag";
+	addtimer 2000, "Tierra_EOS::OnFlash";
+	stopnpctimer;
+	end;
+
+OnTimer2000:
+	stopnpctimer;
+	if( .Flag_Status == 0 && $@BG_Status == 1 && bg_current_mode() == bg_info("bg_eoe", BG_INFO_ID) )
+	{
+		getmapxy .@m$, .@x, .@y, BL_NPC;
+		viewpointmap "bg_eoe",1,.@x,.@y,3,0xFFFF00;
+		specialeffect 223;
+		initnpctimer;
+	}
+	end;
+
+OnDisable:
+	movenpc "Neutral_Flag",104,90;
+	set .Flag_Status, 0;
+	stopnpctimer;
+	disablenpc "Neutral_Flag";
+	killmonster "bg_eoe","Tierra_EOS::OnBreak";
+	end;
+
+OnBase:
+	if( $@BG_Status != 1 || bg_current_mode() != bg_info("bg_eoe", BG_INFO_ID) )
+		end;
+
+	movenpc "Neutral_Flag",104,90;
+	set .Flag_Status, 0;
+	set .Flag_Carrier, 0;
+	initnpctimer;
+	disablenpc "Neutral_Flag";
+	mapannounce "bg_eoe","The Neutral Flag have been set!!",1,0xFFFFFF;
+	bg_monster 0,"bg_eoe",104,90,"Neutral Flag",1911,"Tierra_EOS::OnBreak";
+	end;
+}
+
+// Battleground Bases
+// *********************************************************************
+
+bg_eoe,147,123,0	script	North Base::North_Base	1911,3,3,{
+	end;
+
+OnTouch:
+	if( $@BG_Status != 1 || bg_current_mode() != bg_info("bg_eoe", BG_INFO_ID) || .Owner == 0 || .Owner != getcharid(4) || getvariableofnpc(.Flag_Carrier,"Neutral_Flag") != getcharid(0) )
+		end;
+
+	//bg_rankpoints "eos_flags",1;
+	set getvariableofnpc(.Flag_Carrier,"Neutral_Flag"), 0;
+	pcblock 1,0; // UnBlock Skills/Items
+	if( .Owner == $@BG_Team1 )
+		donpcevent "Tierra_EOS::OnTeam1Flag";
+	else
+		donpcevent "Tierra_EOS::OnTeam2Flag";
+	end;
+
+OnBase:
+	set .Owner, 0;
+	set .Balance, 0;
+	set .Tick, 0;
+	setnpcdisplay "North_Base","North Base",1911;
+	initnpctimer;
+	end;
+
+OnTimer1000:
+	stopnpctimer;
+	if( $@BG_Status != 1 || bg_current_mode() != bg_info("bg_eoe", BG_INFO_ID) )
+		end;
+
+	set .@Team1Count, bg_getareausers($@BG_Team1,"bg_eoe",143,120,151,127);
+	set .@Team2Count, bg_getareausers($@BG_Team2,"bg_eoe",143,120,151,127);
+	set .Balance, .Balance + set(.@Balance, .@Team1Count - .@Team2Count);
+
+	if( .Balance < -20 )
+		set .Balance, -20;
+	else if( .Balance > 20 )
+		set .Balance, 20;
+
+	if( .Owner == 0 )
+	{
+		if( .Balance == 20 )
+		{
+			set .Balance, 20;
+			set .Owner, $@BG_Team1; // Team 1
+			setnpcdisplay "North_Base",bg_get_data($@BG_Team1,2) + " Base",1912;
+			mapannounce "bg_eoe","North Base captured by " + bg_get_data($@BG_Team1,2),1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+			//bg_rankpoints_area $@BG_Team1,"bg_eoe",143,120,151,127,"eos_bases",1;
+			donpcevent "GEoSNBW::OnEnable";
+		}
+		else if( .Balance == -20 )
+		{
+			set .Balance, -20;
+			set .Owner, $@BG_Team2; // Team 2
+			setnpcdisplay "North_Base",bg_get_data($@BG_Team2,2) + " Base",1913;
+			mapannounce "bg_eoe","North Base captured by " + bg_get_data($@BG_Team2,2),1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+			//bg_rankpoints_area $@BG_Team2,"bg_eoe",143,120,151,127,"eos_bases",1;
+			donpcevent "CEoSNBW::OnEnable";
+		}
+	}
+	else if( .Owner == $@BG_Team1 )
+	{
+		if( .Balance <= 0 )
+		{ // Team 1 lost Control
+			set .Owner, 0;
+			setnpcdisplay "North_Base","North Base",1911;
+			mapannounce "bg_eoe",bg_get_data($@BG_Team1,2) + " lost control of the North Base",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+			donpcevent "GEoSNBW::OnDisable";
+		}
+	}
+	else if( .Owner == $@BG_Team2 )
+	{
+		if( .Balance >= 0 )
+		{ // Team 2 lost Control
+			set .Owner, 0;
+			setnpcdisplay "North_Base","North Base",1911;
+			mapannounce "bg_eoe",bg_get_data($@BG_Team2,2) + " lost control of the North Base",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+			donpcevent "CEoSNBW::OnDisable";
+		}
+	}
+
+	if( .@Balance > 0 )
+		specialeffect 236;
+	else if( .@Balance < 0 )
+		specialeffect 225;
+	else if( .Owner == $@BG_Team1 )
+		specialeffect 236;
+	else if( .Owner == $@BG_Team2 )
+		specialeffect 225;
+	else
+		specialeffect 223;
+
+	if( .Owner == 0 )
+		viewpointmap "bg_eoe",1, 147,123, 1, 0xFFFFFF;
+	else if( .Owner == $@BG_Team1 )
+		viewpointmap "bg_eoe",1, 147,123, 1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+	else if( .Owner == $@BG_Team2 )
+		viewpointmap "bg_eoe",1, 147,123, 1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+
+	if( .Owner == 0 )
+		set .Tick, 0;
+	else if( set(.Tick, .Tick + 1) == 7 )
+	{
+		donpcevent "Tierra_EOS::OnNorthScore";
+		set .Tick, 0;
+	}
+
+	initnpctimer;
+	end;
+}
+
+bg_eoe,59,55,0	script	South Base::South_Base	1911,3,3,{
+	end;
+
+OnTouch:
+	if( $@BG_Status != 1 || bg_current_mode() != bg_info("bg_eoe", BG_INFO_ID) || .Owner == 0 || .Owner != getcharid(4) || getvariableofnpc(.Flag_Carrier,"Neutral_Flag") != getcharid(0) )
+		end;
+
+	//bg_rankpoints "eos_flags",1;
+	set getvariableofnpc(.Flag_Carrier,"Neutral_Flag"), 0;
+	pcblock 1,0; // UnBlock Skills/Items
+	if( .Owner == $@BG_Team1 )
+		donpcevent "Tierra_EOS::OnTeam1Flag";
+	else
+		donpcevent "Tierra_EOS::OnTeam2Flag";
+	end;
+
+OnBase:
+	set .Owner, 0;
+	set .Balance, 0;
+	set .Tick, 0;
+	setnpcdisplay "South_Base","South Base",1911;
+	initnpctimer;
+	end;
+
+OnTimer1000:
+	stopnpctimer;
+	if( $@BG_Status != 1 || bg_current_mode() != bg_info("bg_eoe", BG_INFO_ID) )
+		end;
+
+	set .@Team1Count, bg_getareausers($@BG_Team1,"bg_eoe",55,52,64,60);
+	set .@Team2Count, bg_getareausers($@BG_Team2,"bg_eoe",55,52,64,60);
+	set .Balance, .Balance + set(.@Balance, .@Team1Count - .@Team2Count);
+
+	if( .Balance < -20 )
+		set .Balance, -20;
+	else if( .Balance > 20 )
+		set .Balance, 20;
+
+	if( .Owner == 0 )
+	{
+		if( .Balance == 20 )
+		{
+			set .Balance, 20;
+			set .Owner, $@BG_Team1; // Team 1
+			setnpcdisplay "South_Base",bg_get_data($@BG_Team1,2) + " Base",1912;
+			mapannounce "bg_eoe","South Base captured by " + bg_get_data($@BG_Team1,2),1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+			//bg_rankpoints_area $@BG_Team1,"bg_eoe",55,52,64,60,"eos_bases",1;
+			donpcevent "GEoSSBW::OnEnable";
+		}
+		else if( .Balance == -20 )
+		{
+			set .Balance, -20;
+			set .Owner, $@BG_Team2; // Team 2
+			setnpcdisplay "South_Base",bg_get_data($@BG_Team2,2) + " Base",1913;
+			mapannounce "bg_eoe","South Base captured by " + bg_get_data($@BG_Team2,2),1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+			//bg_rankpoints_area $@BG_Team2,"bg_eoe",55,52,64,60,"eos_bases",1;
+			donpcevent "CEoSSBW::OnEnable";
+		}
+	}
+	else if( .Owner == $@BG_Team1 )
+	{
+		if( .Balance <= 0 )
+		{ // Team 1 lost Control
+			set .Owner, 0;
+			setnpcdisplay "South_Base","North Base",1911;
+			mapannounce "bg_eoe",bg_get_data($@BG_Team1,2) + " lost control of the South Base",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+			donpcevent "GEoSSBW::OnDisable";
+		}
+	}
+	else if( .Owner == $@BG_Team2 )
+	{
+		if( .Balance >= 0 )
+		{ // Team 2 lost Control
+			set .Owner, 0;
+			setnpcdisplay "South_Base","North Base",1911;
+			mapannounce "bg_eoe",bg_get_data($@BG_Team2,2) + " lost control of the South Base",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+			donpcevent "CEoSSBW::OnDisable";
+		}
+	}
+
+	if( .@Balance > 0 )
+		specialeffect 236;
+	else if( .@Balance < 0 )
+		specialeffect 225;
+	else if( .Owner == $@BG_Team1 )
+		specialeffect 236;
+	else if( .Owner == $@BG_Team2 )
+		specialeffect 225;
+	else
+		specialeffect 223;
+
+	if( .Owner == 0 )
+		viewpointmap "bg_eoe",1,59,55,2,0xFFFFFF;
+	else if( .Owner == $@BG_Team1 )
+		viewpointmap "bg_eoe",1,59,55,2,0x0000FF;
+	else if( .Owner == $@BG_Team2 )
+		viewpointmap "bg_eoe",1,59,55,2,0xFF0000;
+
+	if( .Owner == 0 )
+		set .Tick, 0;
+	else if( set(.Tick, .Tick + 1) == 7 )
+	{
+		donpcevent "Tierra_EOS::OnSouthScore";
+		set .Tick, 0;
+	}
+
+	initnpctimer;
+	end;
+}
+
+// Battleground Therapist
+// *********************************************************************
+
+bg_eoe,10,25,3	script	Therapist in battle#eoe2	4_F_SISTER,{
+	mes "[Therapist in battle]";
+	mes "Just close your eyes, take a deep breath";
+	mes "and you free yourself from the pain.";
+	specialeffect2 312;
+	percentheal 100,100;
+	repairall;
+	close2;
+	openstorage;
+	end;
+}
+
+bg_eoe,186,172,3	script	Therapist in battle#eoe1	4_F_SISTER,{
+	mes "[Therapist in battle]";
+	mes "Just close your eyes, take a deep breath";
+	mes "and you free yourself from the pain.";
+	specialeffect2 312;
+	percentheal 100,100;
+	repairall;
+	close2;
+	openstorage;
+	end;
+}
+
+// Battleground Respawn
+// *********************************************************************
+
+bg_eoe,19,20,0	script	North Base Warp::GEoSNBW	723,{
+	end;
+
+OnEnable:
+	waitingroom "Join To Warp",20;
+	end;
+
+OnDisable:
+	delwaitingroom;
+	end;
+
+OnWarp:
+	warpwaitingpc "bg_eoe",152,86,20;
+	end;
+}
+
+bg_eoe,8,9,0	script	South Base Warp::GEoSSBW	723,{
+	end;
+
+OnEnable:
+	waitingroom "Join To Warp",20;
+	end;
+
+OnDisable:
+	delwaitingroom;
+	end;
+
+OnWarp:
+	warpwaitingpc "bg_eoe",55,95,20;
+	end;
+}
+
+// *********************************************************************
+
+bg_eoe,195,166,0	script	North Base Warp::CEoSNBW	723,{
+	end;
+
+OnEnable:
+	waitingroom "Join To Warp",20;
+	end;
+
+OnDisable:
+	delwaitingroom;
+	end;
+
+OnWarp:
+	warpwaitingpc "bg_eoe",107,128,20;
+	end;
+}
+
+bg_eoe,185,155,0	script	South Base Warp::CEoSSBW	723,{
+	end;
+
+OnEnable:
+	waitingroom "Join To Warp",20;
+	end;
+
+OnDisable:
+	delwaitingroom;
+	end;
+
+OnWarp:
+	warpwaitingpc "bg_eoe",100,51,20;
+	end;
+}
+
+// *********************************************************************
+
+bg_eoe,14,15,0	script	#guieoe_respawn	139,{
+	end;
+
+OnBGStart:
+	initnpctimer;
+	end;
+
+OnBGStop:
+	stopnpctimer;
+	end;
+
+OnTimer24000:
+	misceffect 83;
+	end;
+
+OnTimer25000:
+	areapercentheal "bg_eoe",6,6,21,22,100,100;
+	donpcevent "GEoSNBW::OnWarp";
+	donpcevent "GEoSSBW::OnWarp";
+	areawarp "bg_eoe",6,6,21,22,"bg_eoe",57,126;
+	initnpctimer;
+	end;
+}
+
+bg_eoe,189,161,0	script	#croeoe_respawn	139,{
+	end;
+
+OnBGStart:
+	initnpctimer;
+	end;
+
+OnBGStop:
+	stopnpctimer;
+	end;
+
+OnTimer24000:
+	misceffect 83;
+	end;
+
+OnTimer25000:
+	areapercentheal "bg_eoe",182,152,197,167,100,100;
+	donpcevent "CEoSNBW::OnWarp";
+	donpcevent "CEoSSBW::OnWarp";
+	areawarp "bg_eoe",182,152,197,167,"bg_eoe",151,52;
+	initnpctimer;
+	end;
+}
+
+// MapFlags
+// *********************************************************************
+
+bg_eoe	mapflag	battleground	2
+bg_eoe	mapflag	nomemo
+bg_eoe	mapflag	nosave	SavePoint
+bg_eoe	mapflag	noteleport
+bg_eoe	mapflag	nowarp
+bg_eoe	mapflag	nowarpto
+bg_eoe	mapflag	noreturn
+bg_eoe	mapflag	nobranch
+bg_eoe	mapflag	nopenalty
+//bg_eoe	mapflag	noemergencycall
+
+// Eye of the Storm Effects
+// *********************************************************************
+
+bg_eoe,127,115,0	script	#stormef1	139,{
+	end;
+
+OnStartStorm:
+	if( $@BG_Status != 1 || bg_current_mode() != bg_info("bg_eoe", BG_INFO_ID) ) end;
+
+	sleep (rand(30,80) * 1000);
+	specialeffect 622;
+	specialeffect 537;
+
+	goto OnStartStorm;
+	end;
+}
+
+bg_eoe,138,103,0	duplicate(#stormef1)	#stormef2	139
+bg_eoe,69,77,0	duplicate(#stormef1)	#stormef3	139
+bg_eoe,80,66,0	duplicate(#stormef1)	#stormef4	139
+bg_eoe,93,79,0	duplicate(#stormef1)	#stormef5	139
+bg_eoe,114,79,0	duplicate(#stormef1)	#stormef6	139
+bg_eoe,114,100,0	duplicate(#stormef1)	#stormef7	139
+bg_eoe,130,117,0	duplicate(#stormef1)	#stormef8	139
+bg_eoe,95,70,0	duplicate(#stormef1)	#stormef9	139
+bg_eoe,100,99,0	duplicate(#stormef1)	#stormef10	139
+bg_eoe,124,88,0	duplicate(#stormef1)	#stormef11	139
+bg_eoe,76,80,0	duplicate(#stormef1)	#stormef12	139
+bg_eoe,93,101,0	duplicate(#stormef1)	#stormef13	139
+
diff --git a/npc/battleground-extended/4-bg_conquest.txt b/npc/battleground-extended/4-bg_conquest.txt
new file mode 100644
index 000000000..1ad38ab9d
--- /dev/null
+++ b/npc/battleground-extended/4-bg_conquest.txt
@@ -0,0 +1,2223 @@
+// (c) 2008 - 2012 eAmod Project; Andres Garbanzo / Zephyrus
+//
+//  - gaiaro.staff@yahoo.com
+//  - MSN andresjgm.cr@hotmail.com
+//  - Skype: Zephyrus_cr
+//  - Site: http://dev.terra-gaming.com
+//
+// This file is NOT public - you are not allowed to distribute it.
+// Authorized Server List : http://dev.terra-gaming.com/index.php?/topic/72-authorized-eamod-servers/
+// eAmod is a non Free, extended version of eAthena Ragnarok Private Server.
+
+// ==============================================================================
+// BattleGround System - Conquest 1
+// ==============================================================================
+
+// Battleground Engine
+// *********************************************************************
+
+-	script	Conquest	-1,{
+	end;
+
+OnInit:
+	// Cementery Walls
+	setwall "bg_con01",291,376,8,0,0,"conquest_wall_a";
+	setwall "bg_con01",268,376,8,0,0,"conquest_wall_b";
+	setwall "bg_con02",93,301,21,0,0,"conquest_wall_c";
+	setwall "bg_con02",110,301,21,0,0,"conquest_wall_d";
+	setwall "bg_con03",84,43,6,6,0,"conquest_wall_e";
+	setwall "bg_con03",26,43,6,6,0,"conquest_wall_f";
+	setwall "bg_con04",121,353,10,0,0,"conquest_wall_g";
+	setwall "bg_con04",25,377,10,6,0,"conquest_wall_h";
+	setwall "bg_con05",291,335,7,6,0,"conquest_wall_i1";
+	setwall "bg_con05",300,335,6,6,0,"conquest_wall_j1";
+	setwall "bg_con05",291,312,7,6,0,"conquest_wall_i2";
+	setwall "bg_con05",300,312,4,6,0,"conquest_wall_j2";
+	setwall "bg_con06",317,150,8,0,0,"conquest_wall_k";
+	setwall "bg_con06",326,150,8,0,0,"conquest_wall_l";
+	// Select your castle, -1 to randomize. 0 is bg_con01, etc..
+	set .Index,-1;
+	end;
+
+OnTeamQuit:
+	bg_desert;
+	if( $@BG_Status != 0 && bg_current_mode() == bg_info(.Castle$, BG_INFO_ID) )
+		donpcevent "BG_Queue_Join::OnJoinEvent";
+	end;
+
+OnReady:
+	set .Castle$, bg_get_data($@BG_Team1, 4);
+	if (.Castle$ == "bg_con01") {
+		set .DX,120; set .DY,290; set .AX,119; set .AY,  8;
+		set .Index, 0;
+	} else if (.Castle$ == "bg_con02") {
+		set .DX,136; set .DY,188; set .AX,339; set .AY, 78;
+		set .Index, 1;
+	} else if (.Castle$ == "bg_con03") {
+		set .DX,308; set .DY,208; set .AX,337; set .AY,330;
+		set .Index, 2;
+	} else if (.Castle$ == "bg_con04") {
+		set .DX, 67; set .DY,193; set .AX,275; set .AY, 93;
+		set .Index, 3;
+	} else if (.Castle$ == "bg_con05") {
+		set .DX, 43; set .DY,256; set .AX,139; set .AY, 31;
+		set .Index, 4;
+	} else if (.Castle$ == "bg_con06") {
+		set .DX,121; set .DY,318; set .AX,141; set .AY, 45;
+		set .Index, 5;
+	}
+
+	if( bg_current_mode() != bg_info(.Castle$, BG_INFO_ID) )
+		end;
+
+	set $@BG_Status, 1;
+	initnpctimer;
+	initnpctimer "Conquest_Respawn";
+	set .Score, 0;
+	switch( rand(2) )
+	{
+	case 1:
+		set .Defender, $@BG_Team1;
+		set .Atacker, $@BG_Team2;
+		break;
+	case 0:
+		set .Defender, $@BG_Team2;
+		set .Atacker, $@BG_Team1;
+		break;
+	}
+	// =========================================================================
+	// Build Structures
+	// =========================================================================
+	switch( .Index )
+	{
+	case 0: // =========================================================================
+		setwall .Castle$,114,48,13,6,0,"conq_RL00";
+		setwall .Castle$,114,51,13,6,1,"conq_RL01";
+		setwall .Castle$,114,154,13,6,1,"conq_RL02";
+		setwall .Castle$,116,241,11,6,1,"conq_RL03";
+
+		bg_monster .Defender,.Castle$,115,49," ",1905,"Conquest::OnBarricade0";
+		bg_monster .Defender,.Castle$,117,49," ",1905,"Conquest::OnBarricade0";
+		bg_monster .Defender,.Castle$,119,49," ",1905,"Conquest::OnBarricade0";
+		bg_monster .Defender,.Castle$,121,49," ",1905,"Conquest::OnBarricade0";
+		bg_monster .Defender,.Castle$,123,49," ",1905,"Conquest::OnBarricade0";
+		bg_monster .Defender,.Castle$,125,49," ",1905,"Conquest::OnBarricade0";
+
+		bg_monster .Defender,.Castle$,115,50," ",1905,"Conquest::OnBarricade1";
+		bg_monster .Defender,.Castle$,117,50," ",1905,"Conquest::OnBarricade1";
+		bg_monster .Defender,.Castle$,119,50," ",1905,"Conquest::OnBarricade1";
+		bg_monster .Defender,.Castle$,121,50," ",1905,"Conquest::OnBarricade1";
+		bg_monster .Defender,.Castle$,123,50," ",1905,"Conquest::OnBarricade1";
+		bg_monster .Defender,.Castle$,125,50," ",1905,"Conquest::OnBarricade1";
+
+		bg_monster .Defender,.Castle$,115,153," ",1905,"Conquest::OnBarricade2";
+		bg_monster .Defender,.Castle$,117,153," ",1905,"Conquest::OnBarricade2";
+		bg_monster .Defender,.Castle$,119,153," ",1905,"Conquest::OnBarricade2";
+		bg_monster .Defender,.Castle$,121,153," ",1905,"Conquest::OnBarricade2";
+		bg_monster .Defender,.Castle$,123,153," ",1905,"Conquest::OnBarricade2";
+		bg_monster .Defender,.Castle$,125,153," ",1905,"Conquest::OnBarricade2";
+
+		bg_monster .Defender,.Castle$,116,240," ",1905,"Conquest::OnBarricade3";
+		bg_monster .Defender,.Castle$,118,240," ",1905,"Conquest::OnBarricade3";
+		bg_monster .Defender,.Castle$,120,240," ",1905,"Conquest::OnBarricade3";
+		bg_monster .Defender,.Castle$,122,240," ",1905,"Conquest::OnBarricade3";
+
+		bg_monster .Defender,.Castle$,27,35,"1st Guardian Stone",1907,"Conquest::OnGuardianStone1";
+		bg_monster .Defender,.Castle$,207,75,"2st Guardian Stone",1908,"Conquest::OnGuardianStone2";
+
+		bg_monster .Defender,.Castle$,120,272,"Emperium",1288,"Conquest::OnEmperium";
+		break;
+	case 1: // =========================================================================
+		setwall .Castle$,290,98,8,0,0,"conq_RL00";
+		setwall .Castle$,279,98,8,0,1,"conq_RL01";
+		setwall .Castle$,230,213,6,0,1,"conq_RL02";
+		setwall .Castle$,160,141,6,6,1,"conq_RL03";
+
+		bg_monster .Defender,.Castle$,289,98," ",1905,"Conquest::OnBarricade0";
+		bg_monster .Defender,.Castle$,289,100," ",1905,"Conquest::OnBarricade0";
+		bg_monster .Defender,.Castle$,289,102," ",1905,"Conquest::OnBarricade0";
+		bg_monster .Defender,.Castle$,289,104," ",1905,"Conquest::OnBarricade0";
+
+		bg_monster .Defender,.Castle$,280,98," ",1905,"Conquest::OnBarricade1";
+		bg_monster .Defender,.Castle$,280,100," ",1905,"Conquest::OnBarricade1";
+		bg_monster .Defender,.Castle$,280,102," ",1905,"Conquest::OnBarricade1";
+		bg_monster .Defender,.Castle$,281,99," ",1905,"Conquest::OnBarricade1";
+		bg_monster .Defender,.Castle$,281,101," ",1905,"Conquest::OnBarricade1";
+		bg_monster .Defender,.Castle$,281,103," ",1905,"Conquest::OnBarricade1";
+
+		bg_monster .Defender,.Castle$,231,214," ",1905,"Conquest::OnBarricade2";
+		bg_monster .Defender,.Castle$,231,216," ",1905,"Conquest::OnBarricade2";
+		bg_monster .Defender,.Castle$,231,218," ",1905,"Conquest::OnBarricade2";
+		bg_monster .Defender,.Castle$,232,213," ",1905,"Conquest::OnBarricade2";
+		bg_monster .Defender,.Castle$,232,215," ",1905,"Conquest::OnBarricade2";
+		bg_monster .Defender,.Castle$,232,217," ",1905,"Conquest::OnBarricade2";
+
+		bg_monster .Defender,.Castle$,160,140," ",1905,"Conquest::OnBarricade3";
+		bg_monster .Defender,.Castle$,162,140," ",1905,"Conquest::OnBarricade3";
+		bg_monster .Defender,.Castle$,164,140," ",1905,"Conquest::OnBarricade3";
+		bg_monster .Defender,.Castle$,166,140," ",1905,"Conquest::OnBarricade3";
+
+		bg_monster .Defender,.Castle$,231,58,"1st Guardian Stone",1907,"Conquest::OnGuardianStone1";
+		bg_monster .Defender,.Castle$,335,230,"2nd Guardian Stone",1908,"Conquest::OnGuardianStone2";
+
+		bg_monster .Defender,.Castle$,162,193,"Emperium",1288,"Conquest::OnEmperium";
+		break;
+	case 2: // =========================================================================
+		setwall .Castle$,326,301,6,6,0,"conq_RL00";
+		setwall .Castle$,325,277,8,6,1,"conq_RL01";
+		setwall .Castle$,200,230,8,0,1,"conq_RL02";
+		setwall .Castle$,285,198,8,0,1,"conq_RL03";
+
+		bg_monster .Defender,.Castle$,326,300," ",1905,"Conquest::OnBarricade0";
+		bg_monster .Defender,.Castle$,328,300," ",1905,"Conquest::OnBarricade0";
+		bg_monster .Defender,.Castle$,330,300," ",1905,"Conquest::OnBarricade0";
+
+		bg_monster .Defender,.Castle$,326,278," ",1905,"Conquest::OnBarricade1";
+		bg_monster .Defender,.Castle$,328,278," ",1905,"Conquest::OnBarricade1";
+		bg_monster .Defender,.Castle$,330,278," ",1905,"Conquest::OnBarricade1";
+		bg_monster .Defender,.Castle$,327,279," ",1905,"Conquest::OnBarricade1";
+		bg_monster .Defender,.Castle$,329,279," ",1905,"Conquest::OnBarricade1";
+		bg_monster .Defender,.Castle$,331,279," ",1905,"Conquest::OnBarricade1";
+
+		bg_monster .Defender,.Castle$,201,231," ",1905,"Conquest::OnBarricade2";
+		bg_monster .Defender,.Castle$,201,233," ",1905,"Conquest::OnBarricade2";
+		bg_monster .Defender,.Castle$,201,235," ",1905,"Conquest::OnBarricade2";
+		bg_monster .Defender,.Castle$,202,232," ",1905,"Conquest::OnBarricade2";
+		bg_monster .Defender,.Castle$,202,234," ",1905,"Conquest::OnBarricade2";
+		bg_monster .Defender,.Castle$,202,236," ",1905,"Conquest::OnBarricade2";
+
+		bg_monster .Defender,.Castle$,284,199," ",1905,"Conquest::OnBarricade3";
+		bg_monster .Defender,.Castle$,284,201," ",1905,"Conquest::OnBarricade3";
+		bg_monster .Defender,.Castle$,284,203," ",1905,"Conquest::OnBarricade3";
+		bg_monster .Defender,.Castle$,284,205," ",1905,"Conquest::OnBarricade3";
+
+		bg_monster .Defender,.Castle$,242,309,"1st Guardian Stone",1907,"Conquest::OnGuardianStone1";
+		bg_monster .Defender,.Castle$,376,251,"2nd Guardian Stone",1908,"Conquest::OnGuardianStone2";
+
+		bg_monster .Defender,.Castle$,338,202,"Emperium",1288,"Conquest::OnEmperium";
+		break;
+	case 3: // =========================================================================
+		setwall .Castle$,238,74,8,6,0,"conq_RL00";
+		setwall .Castle$,239,53,8,6,1,"conq_RL01";
+		setwall .Castle$,107,124,6,6,1,"conq_RL02";
+		setwall .Castle$,84,171,8,6,1,"conq_RL03";
+
+		bg_monster .Defender,.Castle$,239,73," ",1905,"Conquest::OnBarricade0";
+		bg_monster .Defender,.Castle$,241,73," ",1905,"Conquest::OnBarricade0";
+		bg_monster .Defender,.Castle$,243,73," ",1905,"Conquest::OnBarricade0";
+		bg_monster .Defender,.Castle$,245,73," ",1905,"Conquest::OnBarricade0";
+
+		bg_monster .Defender,.Castle$,239,55," ",1905,"Conquest::OnBarricade1";
+		bg_monster .Defender,.Castle$,241,55," ",1905,"Conquest::OnBarricade1";
+		bg_monster .Defender,.Castle$,243,55," ",1905,"Conquest::OnBarricade1";
+		bg_monster .Defender,.Castle$,240,54," ",1905,"Conquest::OnBarricade1";
+		bg_monster .Defender,.Castle$,242,54," ",1905,"Conquest::OnBarricade1";
+		bg_monster .Defender,.Castle$,244,54," ",1905,"Conquest::OnBarricade1";
+
+		bg_monster .Defender,.Castle$,107,122," ",1905,"Conquest::OnBarricade2";
+		bg_monster .Defender,.Castle$,109,122," ",1905,"Conquest::OnBarricade2";
+		bg_monster .Defender,.Castle$,111,122," ",1905,"Conquest::OnBarricade2";
+		bg_monster .Defender,.Castle$,108,123," ",1905,"Conquest::OnBarricade2";
+		bg_monster .Defender,.Castle$,110,123," ",1905,"Conquest::OnBarricade2";
+		bg_monster .Defender,.Castle$,112,123," ",1905,"Conquest::OnBarricade2";
+
+		bg_monster .Defender,.Castle$,84,170," ",1905,"Conquest::OnBarricade3";
+		bg_monster .Defender,.Castle$,86,170," ",1905,"Conquest::OnBarricade3";
+		bg_monster .Defender,.Castle$,88,170," ",1905,"Conquest::OnBarricade3";
+		bg_monster .Defender,.Castle$,90,170," ",1905,"Conquest::OnBarricade3";
+
+		bg_monster .Defender,.Castle$,210,234,"1st Guardian Stone",1907,"Conquest::OnGuardianStone1";
+		bg_monster .Defender,.Castle$,308,189,"2nd Guardian Stone",1908,"Conquest::OnGuardianStone2";
+
+		bg_monster .Defender,.Castle$,87,219,"Emperium",1288,"Conquest::OnEmperium";
+		break;
+	case 4: // =========================================================================
+		setwall .Castle$,136,136,8,6,0,"conq_RL00";
+		setwall .Castle$,150,223,12,6,1,"conq_RL01";
+		setwall .Castle$,125,342,8,0,1,"conq_RL02";
+		setwall .Castle$,38,314,12,6,1,"conq_RL03";
+
+		bg_monster .Defender,.Castle$,137,137," ",1905,"Conquest::OnBarricade0";
+		bg_monster .Defender,.Castle$,139,137," ",1905,"Conquest::OnBarricade0";
+		bg_monster .Defender,.Castle$,141,137," ",1905,"Conquest::OnBarricade0";
+		bg_monster .Defender,.Castle$,143,137," ",1905,"Conquest::OnBarricade0";
+
+		bg_monster .Defender,.Castle$,151,222," ",1905,"Conquest::OnBarricade1";
+		bg_monster .Defender,.Castle$,153,222," ",1905,"Conquest::OnBarricade1";
+		bg_monster .Defender,.Castle$,155,222," ",1905,"Conquest::OnBarricade1";
+		bg_monster .Defender,.Castle$,157,222," ",1905,"Conquest::OnBarricade1";
+		bg_monster .Defender,.Castle$,159,222," ",1905,"Conquest::OnBarricade1";
+		bg_monster .Defender,.Castle$,161,222," ",1905,"Conquest::OnBarricade1";
+
+		bg_monster .Defender,.Castle$,126,343," ",1905,"Conquest::OnBarricade2";
+		bg_monster .Defender,.Castle$,126,345," ",1905,"Conquest::OnBarricade2";
+		bg_monster .Defender,.Castle$,126,347," ",1905,"Conquest::OnBarricade2";
+		bg_monster .Defender,.Castle$,127,344," ",1905,"Conquest::OnBarricade2";
+		bg_monster .Defender,.Castle$,127,346," ",1905,"Conquest::OnBarricade2";
+		bg_monster .Defender,.Castle$,127,348," ",1905,"Conquest::OnBarricade2";
+
+		bg_monster .Defender,.Castle$,40,315," ",1905,"Conquest::OnBarricade3";
+		bg_monster .Defender,.Castle$,42,315," ",1905,"Conquest::OnBarricade3";
+		bg_monster .Defender,.Castle$,44,315," ",1905,"Conquest::OnBarricade3";
+		bg_monster .Defender,.Castle$,46,315," ",1905,"Conquest::OnBarricade3";
+
+		bg_monster .Defender,.Castle$,33,168,"1st Guardian Stone",1907,"Conquest::OnGuardianStone1";
+		bg_monster .Defender,.Castle$,245,168,"2nd Guardian Stone",1908,"Conquest::OnGuardianStone2";
+
+		bg_monster .Defender,.Castle$,89,256,"Emperium",1288,"Conquest::OnEmperium";
+		break;
+	case 5:  // =========================================================================
+		setwall .Castle$,138,110,8,6,0,"conq_RL00";
+		setwall .Castle$,139,158,6,6,1,"conq_RL01";
+		setwall .Castle$,138,210,8,6,1,"conq_RL02";
+		setwall .Castle$,138,263,8,6,1,"conq_RL03";
+
+		bg_monster .Defender,.Castle$,139,111," ",1905,"Conquest::OnBarricade0";
+		bg_monster .Defender,.Castle$,141,111," ",1905,"Conquest::OnBarricade0";
+		bg_monster .Defender,.Castle$,143,111," ",1905,"Conquest::OnBarricade0";
+		bg_monster .Defender,.Castle$,145,111," ",1905,"Conquest::OnBarricade0";
+
+		bg_monster .Defender,.Castle$,140,157," ",1905,"Conquest::OnBarricade1";
+		bg_monster .Defender,.Castle$,142,157," ",1905,"Conquest::OnBarricade1";
+		bg_monster .Defender,.Castle$,144,157," ",1905,"Conquest::OnBarricade1";
+		bg_monster .Defender,.Castle$,139,156," ",1905,"Conquest::OnBarricade1";
+		bg_monster .Defender,.Castle$,141,156," ",1905,"Conquest::OnBarricade1";
+		bg_monster .Defender,.Castle$,143,156," ",1905,"Conquest::OnBarricade1";
+
+		bg_monster .Defender,.Castle$,140,209," ",1905,"Conquest::OnBarricade2";
+		bg_monster .Defender,.Castle$,142,209," ",1905,"Conquest::OnBarricade2";
+		bg_monster .Defender,.Castle$,144,209," ",1905,"Conquest::OnBarricade2";
+		bg_monster .Defender,.Castle$,139,208," ",1905,"Conquest::OnBarricade2";
+		bg_monster .Defender,.Castle$,141,208," ",1905,"Conquest::OnBarricade2";
+		bg_monster .Defender,.Castle$,143,208," ",1905,"Conquest::OnBarricade2";
+
+		bg_monster .Defender,.Castle$,139,262," ",1905,"Conquest::OnBarricade3";
+		bg_monster .Defender,.Castle$,141,262," ",1905,"Conquest::OnBarricade3";
+		bg_monster .Defender,.Castle$,143,262," ",1905,"Conquest::OnBarricade3";
+		bg_monster .Defender,.Castle$,145,262," ",1905,"Conquest::OnBarricade3";
+
+		bg_monster .Defender,.Castle$,65,171,"1st Guardian Stone",1907,"Conquest::OnGuardianStone1";
+		bg_monster .Defender,.Castle$,212,149,"2nd Guardian Stone",1908,"Conquest::OnGuardianStone2";
+
+		bg_monster .Defender,.Castle$,141,293,"Emperium",1288,"Conquest::OnEmperium";
+		break;
+	}
+	set .Stone, 2;
+	set .Wall1, 6;
+	set .Wall2, 6;
+	set .Wall3, 4;
+	// ======================================
+	donpcevent "::OnEmblemConquest";
+	sleep 2000;
+	bg_warp .Defender,.Castle$,.DX,.DY; // Flag Respawn - Emperium
+	bg_warp .Atacker,.Castle$,.AX,.AY; // Castle Entrance
+	sleep 4000;
+	mapannounce .Castle$,bg_get_data(.Atacker,3) + " : Move on warriors!! Let's capture this Castle!!",1,bg_get_data(.Atacker,4);
+	sleep 4000;
+	mapannounce .Castle$,bg_get_data(.Defender,3) + " : Protect the Castle and it's defenses to all cost!!",1,bg_get_data(.Defender,4);
+	end;
+
+OnBGTeamActive:
+	if (getcharid(4) == $@BG_Team1) {
+		if ($@BG_Team1 == .Atacker)
+			warp .Castle$,.AX,.AY;
+		else
+			warp .Castle$,.DX,.DY;
+	} else {		
+		if ($@BG_Team2 == .Atacker)
+			warp .Castle$,.AX,.AY;
+		else
+			warp .Castle$,.DX,.DY;
+	}
+	donpcevent "BG_Queue_Join::OnJoinEvent";
+	end;
+	
+OnGuardianStone1:
+	set .Stone, .Stone - 1;
+	set .Score, .Score + 1;
+	if( .Stone > 0 ) mapannounce .Castle$,"1st Guardian Stone has fallen - 6 minutes to destroy the 2nd",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+	donpcevent "Conquest::OnCheckGStone";
+	end;
+
+OnGuardianStone2:
+	set .Stone, .Stone - 1;
+	set .Score, .Score + 1;
+	if( .Stone > 0 ) mapannounce .Castle$,"2nd Guardian Stone has fallen - 6 minutes to destroy the 1st",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+	donpcevent "Conquest::OnCheckGStone";
+	end;
+
+OnCheckGStone:
+	initnpctimer;
+	if( .Stone < 1 )
+	{
+		mapannounce .Castle$,"Both Guardian Stones has fallen - 6 minutes to destroy the 1st Fortress Gate",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+		killmonster .Castle$,"Conquest::OnBarricade0";
+		delwall "conq_RL00";
+	}
+	end;
+
+OnBarricade0:
+	end;
+
+OnBarricade1:
+	if( set(.Wall1,.Wall1 - 1) < 1 )
+	{
+		initnpctimer; // Restart Timer
+		mapannounce .Castle$,"1st Fortress Gate has fallen - 6 minutes to destroy the 2nd",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+		set .Score, .Score + 1;
+		delwall "conq_RL01";
+	}
+	end;
+OnBarricade2:
+	if( set(.Wall2,.Wall2 - 1) < 1 )
+	{
+		initnpctimer; // Restart Timer
+		mapannounce .Castle$,"2nd Fortress Gate has fallen - 6 minutes to destroy the 3rd",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+		set .Score, .Score + 1;
+		delwall "conq_RL02";
+	}
+	end;
+OnBarricade3:
+	if( set(.Wall3,.Wall3 - 1) < 1 )
+	{
+		initnpctimer; // Restart Timer
+		mapannounce .Castle$,"3rd Fortress Gate has fallen - 6 minutes to destroy the Emperium",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+		set .Score, .Score + 1;
+		delwall "conq_RL03";
+	}
+	end;
+
+OnTimer60000:
+	mapannounce .Castle$,"Battle of Conquest will ends in 5 minutes",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+	end;
+
+OnTimer300000:
+	mapannounce .Castle$,"Battle of Conquest will ends in 1 minute",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+	end;
+
+OnEmperium:
+	set .Score, .Score + 1;
+	mapannounce .Castle$,"The " + bg_get_data(.Atacker,2) + " army has won the Battle and captured the Castle!!",1,bg_get_data(.Atacker,4);
+	donpcevent "Conquest::OnMatchEnd";
+	end;
+
+OnTimer360000:
+OnPrematureEnd:
+	mapannounce .Castle$,"The " + bg_get_data(.Defender,2) + " army has won the Battle and protected the Castle!!",1,bg_get_data(.Defender,4);
+	donpcevent "Conquest::OnMatchEnd";
+	end;
+
+OnMatchEnd:
+	stopnpctimer;
+	stopnpctimer "Conquest_Respawn";
+	killmonster .Castle$,"Conquest::OnBarricade0";
+	killmonster .Castle$,"Conquest::OnBarricade1";
+	killmonster .Castle$,"Conquest::OnBarricade2";
+	killmonster .Castle$,"Conquest::OnBarricade3";
+	killmonster .Castle$,"Conquest::OnGuardianStone1";
+	killmonster .Castle$,"Conquest::OnGuardianStone2";
+	killmonster .Castle$,"Conquest::OnEmperium";
+	set $@BG_Status, 2;
+	bg_reserve .Castle$, true;
+	// =======================================================
+	// Team Rewards
+	// =======================================================
+	// If attacker is team1 and they scored 6 pts (Emperium taken)
+	if(.Atacker == $@BG_Team1 && .Score >= 6)
+		callfunc("Reward_BG", .Castle$, 1);
+	else
+		callfunc("Reward_BG", .Castle$, 2);
+
+	// =======================================================
+	set .Score, 0;
+	sleep 5000;
+	bg_unbook .Castle$;
+	donpcevent "BG_Queue_Join::OnRotate";
+	delwall "conq_RL00";
+	delwall "conq_RL01";
+	delwall "conq_RL02";
+	delwall "conq_RL03";
+	end;
+}
+
+// Battleground Therapist
+// *********************************************************************
+
+bg_con01,260,383,5	script	Therapist in battle#cq1	95,{
+	mes "[Therapist in battle]";
+	mes "Just close your eyes, and take a deep breathe.";
+	mes "You can be free from pain.";
+	specialeffect2 312;
+	percentheal 100,100;
+	repairall;
+	close2;
+	openstorage;
+	end;
+}
+
+bg_con01,299,383,3	script	Therapist in battle#cq2	95,{
+	mes "[Therapist in battle]";
+	mes "Just close your eyes, and take a deep breathe.";
+	mes "You can be free from pain.";
+	specialeffect2 312;
+	percentheal 100,100;
+	repairall;
+	close2;
+	openstorage;
+	end;
+}
+
+bg_con02,86,315,5	script	Therapist in battle#cq3	95,{
+	mes "[Therapist in battle]";
+	mes "Just close your eyes, and take a deep breathe.";
+	mes "You can be free from pain.";
+	specialeffect2 312;
+	percentheal 100,100;
+	repairall;
+	close2;
+	openstorage;
+	end;
+}
+
+bg_con02,117,315,3	script	Therapist in battle#cq4	95,{
+	mes "[Therapist in battle]";
+	mes "Just close your eyes, and take a deep breathe.";
+	mes "You can be free from pain.";
+	specialeffect2 312;
+	percentheal 100,100;
+	repairall;
+	close2;
+	openstorage;
+	end;
+}
+
+bg_con03,23,50,6	script	Therapist in battle#cq5	95,{
+	mes "[Therapist in battle]";
+	mes "Just close your eyes, and take a deep breathe.";
+	mes "You can be free from pain.";
+	specialeffect2 312;
+	percentheal 100,100;
+	repairall;
+	close2;
+	openstorage;
+	end;
+}
+
+bg_con03,92,50,4	script	Therapist in battle#cq6	95,{
+	mes "[Therapist in battle]";
+	mes "Just close your eyes, and take a deep breathe.";
+	mes "You can be free from pain.";
+	specialeffect2 312;
+	percentheal 100,100;
+	repairall;
+	close2;
+	openstorage;
+	end;
+}
+
+bg_con04,26,385,5	script	Therapist in battle#cq7	95,{
+	mes "[Therapist in battle]";
+	mes "Just close your eyes, and take a deep breathe.";
+	mes "You can be free from pain.";
+	specialeffect2 312;
+	percentheal 100,100;
+	repairall;
+	close2;
+	openstorage;
+	end;
+}
+
+bg_con04,122,361,5	script	Therapist in battle#cq8	95,{
+	mes "[Therapist in battle]";
+	mes "Just close your eyes, and take a deep breathe.";
+	mes "You can be free from pain.";
+	specialeffect2 312;
+	percentheal 100,100;
+	repairall;
+	close2;
+	openstorage;
+	end;
+}
+
+bg_con05,304,342,3	script	Therapist in battle#cq9	95,{
+	mes "[Therapist in battle]";
+	mes "Just close your eyes, and take a deep breathe.";
+	mes "You can be free from pain.";
+	specialeffect2 312;
+	percentheal 100,100;
+	repairall;
+	close2;
+	openstorage;
+	end;
+}
+
+bg_con05,304,305,1	script	Therapist in battle#cq0	95,{
+	mes "[Therapist in battle]";
+	mes "Just close your eyes, and take a deep breathe.";
+	mes "You can be free from pain.";
+	specialeffect2 312;
+	percentheal 100,100;
+	repairall;
+	close2;
+	openstorage;
+	end;
+}
+
+bg_con06,310,154,6	script	Therapist in battle#cqa	95,{
+	mes "[Therapist in battle]";
+	mes "Just close your eyes, and take a deep breathe.";
+	mes "You can be free from pain.";
+	specialeffect2 312;
+	percentheal 100,100;
+	repairall;
+	close2;
+	openstorage;
+	end;
+}
+
+bg_con06,333,154,4	script	Therapist in battle#cqb	95,{
+	mes "[Therapist in battle]";
+	mes "Just close your eyes, and take a deep breathe.";
+	mes "You can be free from pain.";
+	specialeffect2 312;
+	percentheal 100,100;
+	repairall;
+	close2;
+	openstorage;
+	end;
+}
+
+// Battleground Respawn
+// *********************************************************************
+
+-	script	Conquest_Respawn	-1,{
+	end;
+
+OnTimer25000:
+	set .@Castle$,getvariableofnpc(.Castle$,"Conquest");
+	set .@DX,getvariableofnpc(.DX,"Conquest");
+	set .@DY,getvariableofnpc(.DY,"Conquest");
+	set .@AX,getvariableofnpc(.AX,"Conquest");
+	set .@AY,getvariableofnpc(.AY,"Conquest");
+	.@announce_ok = 0;
+	switch( getvariableofnpc(.Index,"Conquest") )
+	{
+	case 0: // schg_cas01 ========================================================================
+		areapercentheal .@Castle$,260,376,267,383,100,100;
+		areapercentheal .@Castle$,292,376,299,383,100,100;
+		if(getareausers(.@Castle$,260,376,267,383) > 0 || getareausers(.@Castle$,292,376,299,383) > 0)		.@announce_ok = 1;
+		if( $@BG_Team1 == getvariableofnpc(.Defender,"Conquest") )
+		{
+			areawarp .@Castle$,260,376,267,383,.@Castle$,.@DX,.@DY;
+			areawarp .@Castle$,292,376,299,383,.@Castle$,.@AX,.@AY;
+		}
+		else
+		{
+			areawarp .@Castle$,260,376,267,383,.@Castle$,.@AX,.@AY;
+			areawarp .@Castle$,292,376,299,383,.@Castle$,.@DX,.@DY;
+		}
+		break;
+	case 1: // schg_cas02 ========================================================================
+		areapercentheal .@Castle$,80,301,92,321,100,100;
+		areapercentheal .@Castle$,111,301,123,321,100,100;
+		if(getareausers(.@Castle$,80,301,92,321) > 0 || getareausers(.@Castle$,111,301,123,321) > 0)		.@announce_ok = 1;
+		if( $@BG_Team1 == getvariableofnpc(.Defender,"Conquest") )
+		{
+			areawarp .@Castle$,80,301,92,321,.@Castle$,.@DX,.@DY;
+			areawarp .@Castle$,111,301,123,321,.@Castle$,.@AX,.@AY;
+		}
+		else
+		{
+			areawarp .@Castle$,80,301,92,321,.@Castle$,.@AX,.@AY;
+			areawarp .@Castle$,111,301,123,321,.@Castle$,.@DX,.@DY;
+		}
+		break;
+	case 2: // schg_cas03 ========================================================================
+		areapercentheal .@Castle$,18,44,33,55,100,100;
+		areapercentheal .@Castle$,82,44,97,55,100,100;
+		if(getareausers(.@Castle$,18,44,33,55) > 0 || getareausers(.@Castle$,82,44,97,55) > 0)		.@announce_ok = 1;
+		if( $@BG_Team1 == getvariableofnpc(.Defender,"Conquest") )
+		{
+			areawarp .@Castle$,18,44,33,55,.@Castle$,.@DX,.@DY;
+			areawarp .@Castle$,82,44,97,55,.@Castle$,.@AX,.@AY;
+		}
+		else
+		{
+			areawarp .@Castle$,18,44,33,55,.@Castle$,.@AX,.@AY;
+			areawarp .@Castle$,82,44,97,55,.@Castle$,.@DX,.@DY;
+		}
+		break;
+	case 3: // arug_cas01 ========================================================================
+		areapercentheal .@Castle$,26,378,33,385,100,100;
+		areapercentheal .@Castle$,122,354,129,361,100,100;
+		if(getareausers(.@Castle$,26,378,33,385) > 0 || getareausers(.@Castle$,122,354,129,361) > 0)		.@announce_ok = 1;
+		if( $@BG_Team1 == getvariableofnpc(.Defender,"Conquest") )
+		{
+			areawarp .@Castle$,26,378,33,385,.@Castle$,.@DX,.@DY;
+			areawarp .@Castle$,122,354,129,361,.@Castle$,.@AX,.@AY;
+		}
+		else
+		{
+			areawarp .@Castle$,26,378,33,385,.@Castle$,.@AX,.@AY;
+			areawarp .@Castle$,122,354,129,361,.@Castle$,.@DX,.@DY;
+		}
+		break;
+	case 4: // arug_cas02 ========================================================================
+		areapercentheal .@Castle$,291,336,304,342,100,100;
+		areapercentheal .@Castle$,291,305,304,311,100,100;
+		if(getareausers(.@Castle$,291,336,304,342) > 0 || getareausers(.@Castle$,291,305,304,311) > 0)		.@announce_ok = 1;
+		if( $@BG_Team1 == getvariableofnpc(.Defender,"Conquest") )
+		{
+			areawarp .@Castle$,291,336,304,342,.@Castle$,.@DX,.@DY;
+			areawarp .@Castle$,291,305,304,311,.@Castle$,.@AX,.@AY;
+		}
+		else
+		{
+			areawarp .@Castle$,291,336,304,342,.@Castle$,.@AX,.@AY;
+			areawarp .@Castle$,291,305,304,311,.@Castle$,.@DX,.@DY;
+		}
+		break;
+	case 5: // arug_cas03 ========================================================================
+		areapercentheal .@Castle$,310,150,316,157,100,100;
+		areapercentheal .@Castle$,327,150,333,157,100,100;
+		if(getareausers(.@Castle$,310,150,316,157) > 0 || getareausers(.@Castle$,327,150,333,157) > 0)		.@announce_ok = 1;
+		if( $@BG_Team1 == getvariableofnpc(.Defender,"Conquest") )
+		{
+			areawarp .@Castle$,310,150,316,157,.@Castle$,.@DX,.@DY;
+			areawarp .@Castle$,327,150,333,157,.@Castle$,.@AX,.@AY;
+		}
+		else
+		{
+			areawarp .@Castle$,310,150,316,157,.@Castle$,.@AX,.@AY;
+			areawarp .@Castle$,327,150,333,157,.@Castle$,.@DX,.@DY;
+		}
+		break;
+	}
+	if(.@announce_ok)
+		mapannounce .@Castle$,"-- Reinforcements entering the Battle of Conquest --",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+	initnpctimer;
+	end;
+}
+
+// Flags bg_con01
+// *********************************************************************
+
+bg_con01,106,302,0	script	LF-01#bg_con01	111,{
+	if( getcharid(4) == getvariableofnpc(.Defender,"Conquest") )
+	{
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch( select("First Gate House:Second Gate House:Cancel") )
+		{
+		case 1:
+			warp "bg_con01",19,26;
+			end;
+		case 2:
+			warp "bg_con01",219,90;
+			end;
+		case 3:
+			close;
+		}
+	}
+	end;
+}
+
+bg_con01,109,302,0	script	LF-02#bg_con01	111,{
+	if( getcharid(4) == getvariableofnpc(.Defender,"Conquest") )
+	{
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch( select("Defense Area 1-1:Defense Area 1-2:Cancel") )
+		{
+		case 1:
+			warp "bg_con01",89,43;
+			end;
+		case 2:
+			warp "bg_con01",141,45;
+			end;
+		case 3:
+			close;
+		}
+	}
+	end;
+}
+
+bg_con01,112,302,0	script	LF-03#bg_con01	111,{
+	if( getcharid(4) == getvariableofnpc(.Defender,"Conquest") )
+	{
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch( select("Defense Area 2-1:Defense Area 2-2:Cancel") )
+		{
+		case 1:
+			warp "bg_con01",137,54;
+			end;
+		case 2:
+			warp "bg_con01",102,54;
+			end;
+		case 3:
+			close;
+		}
+	}
+	end;
+}
+
+bg_con01,115,302,0	script	LF-04#bg_con01	111,{
+	if( getcharid(4) == getvariableofnpc(.Defender,"Conquest") )
+	{
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch( select("Defense Area 2-3:Defense Area 2-4:Cancel") )
+		{
+		case 1:
+			warp "bg_con01",94,147;
+			end;
+		case 2:
+			warp "bg_con01",163,140;
+			end;
+		case 3:
+			close;
+		}
+	}
+	end;
+}
+
+bg_con01,118,302,0	script	LF-05#bg_con01	111,{
+	if( getcharid(4) == getvariableofnpc(.Defender,"Conquest") )
+	{
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch( select("Defense Area 2-3:Defense Area 2-4:Cancel") )
+		{
+		case 1:
+			warp "bg_con01",87,220;
+			end;
+		case 2:
+			warp "bg_con01",151,220;
+			end;
+		case 3:
+			close;
+		}
+	}
+	end;
+}
+
+bg_con01,121,302,0	script	LF-06#bg_con01	111,{
+	if( getcharid(4) == getvariableofnpc(.Defender,"Conquest") )
+	{
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch( select("Defense Area 3-1:Defense Area 3-2:Cancel") )
+		{
+		case 1:
+			warp "bg_con01",100,242;
+			end;
+		case 2:
+			warp "bg_con01",136,242;
+			end;
+		case 3:
+			close;
+		}
+	}
+	end;
+}
+
+bg_con01,124,302,0	script	LF-07#bg_con01	111,{
+	if( getcharid(4) == getvariableofnpc(.Defender,"Conquest") )
+	{
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch( select("Center 1 Area:Center 2 Area:Cancel") )
+		{
+		case 1:
+			warp "bg_con01",120,168;
+			end;
+		case 2:
+			warp "bg_con01",119,211;
+			end;
+		case 3:
+			close;
+		}
+	}
+	end;
+}
+
+bg_con01,127,302,0	script	LF-08#bg_con01	111,{
+	if( getcharid(4) == getvariableofnpc(.Defender,"Conquest") )
+	{
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch( select("Area 1-1:Area 2-1:Area 3-1:Cancel") )
+		{
+		case 1:
+			warp "bg_con01",89,43;
+			end;
+		case 2:
+			warp "bg_con01",94,147;
+			end;
+		case 3:
+			warp "bg_con01",100,242;
+			end;
+		case 4:
+			close;
+		}
+	}
+	end;
+}
+
+bg_con01,130,302,0	script	LF-09#bg_con01	111,{
+	if( getcharid(4) == getvariableofnpc(.Defender,"Conquest") )
+	{
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch( select("Area 1-2:Area 2-3:Area 3-2:Cancel") )
+		{
+		case 1:
+			warp "bg_con01",141,45;
+			end;
+		case 2:
+			warp "bg_con01",163,140;
+			end;
+		case 3:
+			warp "bg_con01",136,243;
+			end;
+		case 4:
+			close;
+		}
+	}
+	end;
+}
+
+bg_con01,17,45,0	script	Castle#LF_sc06_1::LF_sc06_1	111,{
+	if( getcharid(4) == getvariableofnpc(.Defender,"Conquest") )
+	{
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Would";
+		mes "you like to teleport to";
+		mes "the Flag Center?^000000";
+		switch( select("Teleport:Cancel") )
+		{
+		case 1:
+			warp "bg_con01",120,290;
+			end;
+		case 2:
+			close;
+		}
+	}
+	end;
+}
+
+bg_con01,207,95,0	duplicate(LF_sc06_1)	Castle#LF_sc06_2	111
+bg_con01,99,77,0	duplicate(LF_sc06_1)	Castle#LF_sc06_5	111
+bg_con01,140,77,0	duplicate(LF_sc06_1)	Castle#LF_sc06_6	111
+bg_con01,112,212,0	duplicate(LF_sc06_1)	Castle#LF_sc06_9	111
+bg_con01,127,212,0	duplicate(LF_sc06_1)	Castle#LF_sc06_10	111
+bg_con01,113,238,0	duplicate(LF_sc06_1)	Castle#LF_sc06_11	111
+bg_con01,126,238,0	duplicate(LF_sc06_1)	Castle#LF_sc06_12	111
+bg_con01,95,247,0	duplicate(LF_sc06_1)	Castle#LF_sc06_13	111
+bg_con01,144,247,0	duplicate(LF_sc06_1)	Castle#LF_sc06_14	111
+
+bg_con01,111,46,4	script	Castle#LF_sc06_3::LF_sc06_2	722,{
+	if( getcharid(4) == getvariableofnpc(.Defender,"Conquest") )
+	{
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Would";
+		mes "you like to teleport to";
+		mes "the Flag Center?^000000";
+		switch( select("Teleport:Cancel") )
+		{
+		case 1:
+			warp "bg_con01",120,290;
+			end;
+		case 2:
+			close;
+		}
+	}
+	end;
+
+OnEmblemConquest:
+	FlagEmblem getvariableofnpc(.Defender,"Conquest");
+	end;
+}
+
+bg_con01,129,46,4	duplicate(LF_sc06_2)	Castle#LF_sc06_4	722
+bg_con01,109,150,4	duplicate(LF_sc06_2)	Castle#LF_sc06_7	722
+bg_con01,130,150,4	duplicate(LF_sc06_2)	Castle#LF_sc06_8	722
+
+// Flags bg_con02
+// *********************************************************************
+
+bg_con02,143,198,0	script	LF-01#bg_con02	111,{
+	if( getcharid(4) == getvariableofnpc(.Defender,"Conquest") )
+	{
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch( select("First Gate House:Second Gate House:Cancel") )
+		{
+		case 1:
+			warp "bg_con02",235,44;
+			end;
+		case 2:
+			warp "bg_con02",302,233;
+			end;
+		case 3:
+			close;
+		}
+	}
+	end;
+}
+
+bg_con02,143,202,0	script	LF-02#bg_con02	111,{
+	if( getcharid(4) == getvariableofnpc(.Defender,"Conquest") )
+	{
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch( select("Defense area 1-1:Defense area 1-2:Cancel") )
+		{
+		case 1:
+			warp "bg_con02",317,83;
+			end;
+		case 2:
+			warp "bg_con02",359,83;
+			end;
+		case 3:
+			close;
+		}
+	}
+	end;
+}
+
+bg_con02,143,206,0	script	LF-03#bg_con02	111,{
+	if( getcharid(4) == getvariableofnpc(.Defender,"Conquest") )
+	{
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch( select("Defense area 2-1:Defense area 2-2:Cancel") )
+		{
+		case 1:
+			warp "bg_con02",283,79;
+			end;
+		case 2:
+			warp "bg_con02",280,122;
+			end;
+		case 3:
+			close;
+		}
+	}
+	end;
+}
+
+bg_con02,145,208,0	script	LF-04#bg_con02	111,{
+	if( getcharid(4) == getvariableofnpc(.Defender,"Conquest") )
+	{
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch( select("Defense area 3-1:Defense area 3-2:Cancel") )
+		{
+		case 1:
+			warp "bg_con02",215,110;
+			end;
+		case 2:
+			warp "bg_con02",255,215;
+			end;
+		case 3:
+			close;
+		}
+	}
+	end;
+}
+
+bg_con02,180,208,0	script	LF-05#bg_con02	111,{
+	if( getcharid(4) == getvariableofnpc(.Defender,"Conquest") )
+	{
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch( select("Center 1 Area:Center 2 Area:Cancel") )
+		{
+		case 1:
+			warp "bg_con02",338,153;
+			end;
+		case 2:
+			warp "bg_con02",213,226;
+			end;
+		case 3:
+			close;
+		}
+	}
+	end;
+}
+
+bg_con02,182,206,0	script	LF-06#bg_con02	111,{
+	if( getcharid(4) == getvariableofnpc(.Defender,"Conquest") )
+	{
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch( select("Defense area 1-1:Defense area 2-1:Defense area 3-1:Cancel") )
+		{
+		case 1:
+			warp "bg_con02",317,83;
+			end;
+		case 2:
+			warp "bg_con02",283,79;
+			end;
+		case 3:
+			warp "bg_con02",215,110;
+			end;
+		case 4:
+			close;
+		}
+	}
+	end;
+}
+
+bg_con02,182,202,0	script	LF-07#bg_con02	111,{
+	if( getcharid(4) == getvariableofnpc(.Defender,"Conquest") )
+	{
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch( select("Area 1-2:Area 2-2:Area 3-2:Cancel") )
+		{
+		case 1:
+			warp "bg_con02",359,83;
+			end;
+		case 2:
+			warp "bg_con02",280,122;
+			end;
+		case 3:
+			warp "bg_con02",255,215;
+			end;
+		case 4:
+			close;
+		}
+	}
+	end;
+}
+
+bg_con02,235,222,0	script	Andlangr#LF_sc07_1::LF_sc07_1	111,{
+	if( getcharid(4) == getvariableofnpc(.Defender,"Conquest") )
+	{
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Would";
+		mes "you like to teleport to";
+		mes "the Emperium Center?^000000";
+		switch( select("Teleport:Cancel") )
+		{
+		case 1:
+			warp "bg_con02",136,188;
+			end;
+		case 2:
+			close;
+		}
+	}
+	end;
+}
+
+bg_con02,157,136,0	duplicate(LF_sc07_1)	Andlangr#LF_sc07_2	111
+bg_con02,168,136,4	duplicate(LF_sc07_1)	Andlangr#LF_sc07_3	111
+bg_con02,320,232,4	duplicate(LF_sc07_1)	Andlangr#LF_sc07_4	111
+bg_con02,295,109,0	duplicate(LF_sc07_1)	Andlangr#LF_sc07_5	111
+bg_con02,295,92,0	duplicate(LF_sc07_1)	Andlangr#LF_sc07_6	111
+bg_con02,285,90,4	duplicate(LF_sc07_1)	Andlangr#LF_sc07_7	111
+bg_con02,285,190,4	duplicate(LF_sc07_1)	Andlangr#LF_sc07_8	111
+bg_con02,238,66,0	duplicate(LF_sc07_1)	Andlangr#LF_sc07_9	111
+bg_con02,230,45,0	duplicate(LF_sc07_1)	Andlangr#LF_sc07_10	111
+bg_con02,233,120,0	duplicate(LF_sc07_1)	Andlangr#LF_sc07_11	111
+bg_con02,247,120,0	duplicate(LF_sc07_1)	Andlangr#LF_sc07_12	111
+bg_con02,261,162,0	duplicate(LF_sc07_1)	Andlangr#LF_sc07_13	111
+bg_con02,244,162,0	duplicate(LF_sc07_1)	Andlangr#LF_sc07_14	111
+bg_con02,235,207,0	duplicate(LF_sc07_1)	Andlangr#LF_sc07_15	111
+
+// Flags bg_con03
+// *********************************************************************
+
+bg_con03,346,211,0	script	LF-01#bg_con03	111,{
+	if( getcharid(4) == getvariableofnpc(.Defender,"Conquest") )
+	{
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch( select("First Gate House:Second Gate House:Cancel") )
+		{
+		case 1:
+			warp "bg_con03",262,323;
+			end;
+		case 2:
+			warp "bg_con03",378,263;
+			end;
+		case 3:
+			close;
+		}
+	}
+	end;
+}
+
+bg_con03,346,207,0	script	LF-02#bg_con03	111,{
+	if( getcharid(4) == getvariableofnpc(.Defender,"Conquest") )
+	{
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch( select("Center 1 Area:Cancel") )
+		{
+		case 1:
+			warp "bg_con03",306,320;
+			end;
+		case 2:
+			close;
+		}
+	}
+	end;
+}
+
+bg_con03,346,203,0	script	LF-03#bg_con03	111,{
+	if( getcharid(4) == getvariableofnpc(.Defender,"Conquest") )
+	{
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch( select("Defense area 2-1:Defense area 2-2:Cancel") )
+		{
+		case 1:
+			warp "bg_con03",309,292;
+			end;
+		case 2:
+			warp "bg_con03",348,292;
+			end;
+		case 3:
+			close;
+		}
+	}
+	end;
+}
+
+bg_con03,346,199,0	script	LF-04#bg_con03	111,{
+	if( getcharid(4) == getvariableofnpc(.Defender,"Conquest") )
+	{
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch( select("Center 2 Area:Cancel") )
+		{
+		case 1:
+			warp "bg_con03",266,263;
+			end;
+		case 2:
+			close;
+		}
+	}
+	end;
+}
+
+bg_con03,346,195,0	script	LF-05#bg_con03	111,{
+	if( getcharid(4) == getvariableofnpc(.Defender,"Conquest") )
+	{
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch( select("Defense Area 3-1:Defense Area 3-2:Cancel") )
+		{
+		case 1:
+			warp "bg_con03",226,220;
+			end;
+		case 2:
+			warp "bg_con03",185,249;
+			end;
+		case 3:
+			close;
+		}
+	}
+	end;
+}
+
+bg_con03,346,191,0	script	LF-06#bg_con03	111,{
+	if( getcharid(4) == getvariableofnpc(.Defender,"Conquest") )
+	{
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch( select("Center 3 Area:Cancel") )
+		{
+		case 1:
+			warp "bg_con03",271,226;
+			end;
+		case 2:
+			close;
+		}
+	}
+	end;
+}
+
+bg_con03,301,213,0	script	LF-07#bg_con03	111,{
+	if( getcharid(4) == getvariableofnpc(.Defender,"Conquest") )
+	{
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch( select("Area 1-2:Area 2-2:Area 3-2:Cancel") )
+		{
+		case 1:
+			warp "bg_con03",262,323;
+			end;
+		case 2:
+			warp "bg_con03",378,263;
+			end;
+		case 3:
+			warp "bg_con03",306,320;
+			end;
+		case 4:
+			close;
+		}
+	}
+	end;
+}
+
+bg_con03,301,209,0	script	LF-08#bg_con03	111,{
+	if( getcharid(4) == getvariableofnpc(.Defender,"Conquest") )
+	{
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch( select("Area 2-1:Area 2-2:Center 2 Area:Cancel") )
+		{
+		case 1:
+			warp "bg_con03",309,292;
+			end;
+		case 2:
+			warp "bg_con03",348,292;
+			end;
+		case 3:
+			warp "bg_con03",326,263;
+			end;
+		case 4:
+			close;
+		}
+	}
+	end;
+}
+
+bg_con03,301,194,0	script	LF-09#bg_con03	111,{
+	if( getcharid(4) == getvariableofnpc(.Defender,"Conquest") )
+	{
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch( select("Area 3-1:Area 3-2:Center 3 Area:Cancel") )
+		{
+		case 1:
+			warp "bg_con03",226,220;
+			end;
+		case 2:
+			warp "bg_con03",185,249;
+			end;
+		case 3:
+			warp "bg_con03",271,226;
+			end;
+		case 4:
+			close;
+		}
+	}
+	end;
+}
+
+bg_con03,335,305,0	script	Vidblainn#LF_sc08_1::LF_sc08_1	111,{
+	if( getcharid(4) == getvariableofnpc(.Defender,"Conquest") )
+	{
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Would";
+		mes "you like to teleport to";
+		mes "the Emperium Center?^000000";
+		switch( select("Teleport:Cancel") )
+		{
+		case 1:
+			warp "bg_con03",308,202;
+			end;
+		case 2:
+			close;
+		}
+	}
+	end;
+}
+
+bg_con03,322,305,0	duplicate(LF_sc08_1)	Vidblainn#LF_sc08_2	111
+bg_con03,352,248,0	duplicate(LF_sc08_1)	Vidblainn#LF_sc08_3	111
+bg_con03,320,283,0	duplicate(LF_sc08_1)	Vidblainn#LF_sc08_4	111
+bg_con03,337,283,0	duplicate(LF_sc08_1)	Vidblainn#LF_sc08_5	111
+bg_con03,233,320,0	duplicate(LF_sc08_1)	Vidblainn#LF_sc08_6	111
+bg_con03,207,239,0	duplicate(LF_sc08_1)	Vidblainn#LF_sc08_7	111
+bg_con03,207,228,0	duplicate(LF_sc08_1)	Vidblainn#LF_sc08_8	111
+bg_con03,266,206,0	duplicate(LF_sc08_1)	Vidblainn#LF_sc08_9	111
+bg_con03,266,197,0	duplicate(LF_sc08_1)	Vidblainn#LF_sc08_10	111
+
+bg_con03,283,206,2	script	Vidblainn#LF_sc08_11::LF_sc08_2	722,{
+	if( getcharid(4) == getvariableofnpc(.Defender,"Conquest") )
+	{
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Would";
+		mes "you like to teleport to";
+		mes "the Emperium Center?^000000";
+		switch( select("Teleport:Cancel") )
+		{
+		case 1:
+			warp "bg_con03",308,202;
+			end;
+		case 2:
+			close;
+		}
+	}
+	end;
+
+OnEmblemConquest:
+	FlagEmblem getvariableofnpc(.Defender,"Conquest");
+	end;
+}
+
+bg_con03,283,197,2	duplicate(LF_sc08_2)	Vidblainn#LF_sc08_12	722
+bg_con03,332,323,6	duplicate(LF_sc08_2)	Vidblainn#LF_sc08_13	722
+bg_con03,343,323,2	duplicate(LF_sc08_2)	Vidblainn#LF_sc08_14	722
+
+// Flags bg_con04
+// *********************************************************************
+
+bg_con04,74,232,0	script	LF-01#bg_con04	111,{
+	if( getcharid(4) == getvariableofnpc(.Defender,"Conquest") )
+	{
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch( select("First Gate House:Second Gate House:Cancel") )
+		{
+		case 1:
+			warp "bg_con04",158,237;
+			end;
+		case 2:
+			warp "bg_con04",297,248;
+			end;
+		case 3:
+			close;
+		}
+	}
+	end;
+}
+
+bg_con04,77,232,0	script	LF-02#bg_con04	111,{
+	if( getcharid(4) == getvariableofnpc(.Defender,"Conquest") )
+	{
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch( select("Defense Area 1-1:Defense Area 1-2:Cancel") )
+		{
+		case 1:
+			warp "bg_con04",197,144;
+			end;
+		case 2:
+			warp "bg_con04",245,103;
+			end;
+		case 3:
+			close;
+		}
+	}
+	end;
+}
+
+bg_con04,80,232,0	script	LF-03#bg_con04	111,{
+	if( getcharid(4) == getvariableofnpc(.Defender,"Conquest") )
+	{
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch( select("Defense Area 2-1:Defense Area 2-2:Cancel") )
+		{
+		case 1:
+			warp "bg_con04",256,35;
+			end;
+		case 2:
+			warp "bg_con04",186,26;
+			end;
+		case 3:
+			close;
+		}
+	}
+	end;
+}
+
+bg_con04,83,232,0	script	LF-04#bg_con04	111,{
+	if( getcharid(4) == getvariableofnpc(.Defender,"Conquest") )
+	{
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch( select("Defense Area 2-3:Defense Area 2-4:Cancel") )
+		{
+		case 1:
+			warp "bg_con04",146,65;
+			end;
+		case 2:
+			warp "bg_con04",176,111;
+			end;
+		case 3:
+			close;
+		}
+	}
+	end;
+}
+
+bg_con04,86,232,0	script	LF-05#bg_con04	111,{
+	if( getcharid(4) == getvariableofnpc(.Defender,"Conquest") )
+	{
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch( select("Defense Area 3-1:Defense Area 3-2:Cancel") )
+		{
+		case 1:
+			warp "bg_con04",94,126;
+			end;
+		case 2:
+			warp "bg_con04",126,126;
+			end;
+		case 3:
+			close;
+		}
+	}
+	end;
+}
+
+bg_con04,89,232,0	script	LF-06#bg_con04	111,{
+	if( getcharid(4) == getvariableofnpc(.Defender,"Conquest") )
+	{
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch( select("Defense Area 3-3:Defense Area 3-4:Cancel") )
+		{
+		case 1:
+			warp "bg_con04",68,171;
+			end;
+		case 2:
+			warp "bg_con04",105,182;
+			end;
+		case 3:
+			close;
+		}
+	}
+	end;
+}
+
+bg_con04,92,232,0	script	LF-07#bg_con04	111,{
+	if( getcharid(4) == getvariableofnpc(.Defender,"Conquest") )
+	{
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch( select("Gate House Fork:Cancel") )
+		{
+		case 1:
+			warp "bg_con04",233,130;
+			end;
+		case 2:
+			close;
+		}
+	}
+	end;
+}
+
+bg_con04,95,232,0	script	LF-08#bg_con04	111,{
+	if( getcharid(4) == getvariableofnpc(.Defender,"Conquest") )
+	{
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch( select("Area 1-1:Area 2-1:Area 3-1:Cancel") )
+		{
+		case 1:
+			warp "bg_con04",197,144;
+			end;
+		case 2:
+			warp "bg_con04",256,35;
+			end;
+		case 3:
+			warp "bg_con04",146,65;
+			end;
+		case 4:
+			close;
+		}
+	}
+	end;
+}
+
+bg_con04,98,232,0	script	LF-09#bg_con04	111,{
+	if( getcharid(4) == getvariableofnpc(.Defender,"Conquest") )
+	{
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch( select("Area 1-2:Area 2-2:Area 3-3:Cancel") )
+		{
+		case 1:
+			warp "bg_con04",245,103;
+			end;
+		case 2:
+			warp "bg_con04",186,26;
+			end;
+		case 3:
+			warp "bg_con04",68,171;
+			end;
+		case 4:
+			close;
+		}
+	}
+	end;
+}
+
+bg_con04,72,176,0	script	Mardol#LF_ar06_1::LF_ar06_1	111,{
+	if( getcharid(4) == getvariableofnpc(.Defender,"Conquest") )
+	{
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Would";
+		mes "you like to teleport to";
+		mes "the Emperium Center?^000000";
+		switch( select("Teleport:Cancel") )
+		{
+		case 1:
+			warp "bg_con04",67,193;
+			end;
+		case 2:
+			close;
+		}
+	}
+	end;
+}
+
+bg_con04,103,186,0	duplicate(LF_ar06_1)	Mardol#LF_ar06_2	111,{
+bg_con04,150,102,0	duplicate(LF_ar06_1)	Mardol#LF_ar06_4	111
+bg_con04,208,68,0	duplicate(LF_ar06_1)	Mardol#LF_ar06_5	111
+bg_con04,249,52,0	duplicate(LF_ar06_1)	Mardol#LF_ar06_6	111
+bg_con04,234,76,0	duplicate(LF_ar06_1)	Mardol#LF_ar06_7	111
+bg_con04,249,76,0	duplicate(LF_ar06_1)	Mardol#LF_ar06_8	111
+bg_con04,204,142,0	duplicate(LF_ar06_1)	Mardol#LF_ar06_9	111
+bg_con04,183,244,0	duplicate(LF_ar06_1)	Mardol#LF_ar06_10	111
+bg_con04,292,219,0	duplicate(LF_ar06_1)	Mardol#LF_ar06_11	111
+
+bg_con04,92,126,4	script	Mardol#LF_ar06_3::LF_ar06_2	111,{
+	if( getcharid(4) == getvariableofnpc(.Defender,"Conquest") )
+	{
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Would";
+		mes "you like to teleport to";
+		mes "the Emperium Center?^000000";
+		switch( select("Teleport:Cancel") )
+		{
+		case 1:
+			warp "bg_con04",67,193;
+			end;
+		case 2:
+			close;
+		}
+	}
+	end;
+
+OnEmblemConquest:
+	FlagEmblem getvariableofnpc(.Defender,"Conquest");
+	end;
+}
+
+bg_con04,127,126,4	duplicate(LF_ar06_2)	Mardol#LF_ar06_3	111
+bg_con04,102,120,4	duplicate(LF_ar06_2)	Mardol#LF_ar06_12	722
+bg_con04,117,120,4	duplicate(LF_ar06_2)	Mardol#LF_ar06_13	722
+bg_con04,233,140,4	duplicate(LF_ar06_2)	Mardol#LF_ar06_14	722
+
+// Flags bg_con05
+// *********************************************************************
+
+bg_con05,98,270,0	script	LF-01#bg_con05	111,{
+	if( getcharid(4) == getvariableofnpc(.Defender,"Conquest") )
+	{
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch( select("First Gate House:Second Gate House:Cancel") )
+		{
+		case 1:
+			warp "bg_con05",10,187;
+			end;
+		case 2:
+			warp "bg_con05",268,187;
+			end;
+		case 3:
+			close;
+		}
+	}
+	end;
+}
+
+bg_con05,98,266,0	script	LF-02#bg_con05	111,{
+	if( getcharid(4) == getvariableofnpc(.Defender,"Conquest") )
+	{
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch( select("Defense Area 1-1:Defense Area 1-2:Cancel") )
+		{
+		case 1:
+			warp "bg_con05",66,31;
+			end;
+		case 2:
+			warp "bg_con05",212,31;
+			end;
+		case 3:
+			close;
+		}
+	}
+	end;
+}
+
+bg_con05,98,262,0	script	LF-03#bg_con05	111,{
+	if( getcharid(4) == getvariableofnpc(.Defender,"Conquest") )
+	{
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch( select("Defense Area 1-3:Defense Area 1-4:Cancel") )
+		{
+		case 1:
+			warp "bg_con05",90,120;
+			end;
+		case 2:
+			warp "bg_con05",188,119;
+			end;
+		case 3:
+			close;
+		}
+	}
+	end;
+}
+
+bg_con05,98,258,0	script	LF-04#bg_con05	111,{
+	if( getcharid(4) == getvariableofnpc(.Defender,"Conquest") )
+	{
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch( select("Defense Area 2-1:Defense Area 2-2:Cancel") )
+		{
+		case 1:
+			warp "bg_con05",119,183;
+			end;
+		case 2:
+			warp "bg_con05",159,183;
+			end;
+		case 3:
+			close;
+		}
+	}
+	end;
+}
+
+bg_con05,98,253,0	script	LF-05#bg_con05	111,{
+	if( getcharid(4) == getvariableofnpc(.Defender,"Conquest") )
+	{
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch( select("Defense Area 2-3:Defense Area 2-4:Cancel") )
+		{
+		case 1:
+			warp "bg_con05",156,324;
+			end;
+		case 2:
+			warp "bg_con05",174,372;
+			end;
+		case 3:
+			close;
+		}
+	}
+	end;
+}
+
+bg_con05,98,249,0	script	LF-06#bg_con05	111,{
+	if( getcharid(4) == getvariableofnpc(.Defender,"Conquest") )
+	{
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch( select("Defense Area 3-1:Defense Area 3-2:Cancel") )
+		{
+		case 1:
+			warp "bg_con05",28,325;
+			end;
+		case 2:
+			warp "bg_con05",57,325;
+			end;
+		case 3:
+			close;
+		}
+	}
+	end;
+}
+
+bg_con05,98,245,0	script	LF-07#bg_con05	111,{
+	if( getcharid(4) == getvariableofnpc(.Defender,"Conquest") )
+	{
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch( select("Center 2nd Area:Center 3rd Area:Cancel") )
+		{
+		case 1:
+			warp "bg_con05",156,263;
+			end;
+		case 2:
+			warp "bg_con05",43,354;
+			end;
+		case 3:
+			close;
+		}
+	}
+	end;
+}
+
+bg_con05,216,92,0	script	Cyr#LF_ar07_1::LF_ar07_1	111,{
+	if( getcharid(4) == getvariableofnpc(.Defender,"Conquest") )
+	{
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Would";
+		mes "you like to teleport to";
+		mes "the Emperium Center?^000000";
+		switch( select("Teleport:Cancel") )
+		{
+		case 1:
+			warp "bg_con05",43,256;
+			end;
+		case 2:
+			close;
+		}
+	}
+	end;
+}
+
+bg_con05,63,92,0	duplicate(LF_ar07_1)	Cyr#LF_ar07_2	111
+bg_con05,127,133,4	duplicate(LF_ar07_1)	Cyr#LF_ar07_3	111
+bg_con05,152,133,4	duplicate(LF_ar07_1)	Cyr#LF_ar07_4	111
+bg_con05,149,218,0	duplicate(LF_ar07_1)	Cyr#LF_ar07_5	111
+bg_con05,162,218,0	duplicate(LF_ar07_1)	Cyr#LF_ar07_6	111
+bg_con05,128,350,0	duplicate(LF_ar07_1)	Cyr#LF_ar07_7	111
+bg_con05,128,341,0	duplicate(LF_ar07_1)	Cyr#LF_ar07_8	111
+bg_con05,49,317,0	duplicate(LF_ar07_1)	Cyr#LF_ar07_9	111
+bg_con05,30,317,0	duplicate(LF_ar07_1)	Cyr#LF_ar07_10	111
+bg_con05,9,190,0	duplicate(LF_ar07_1)	Cyr#LF_ar07_11	111
+bg_con05,271,190,0	duplicate(LF_ar07_1)	Cyr#LF_ar07_12	111
+
+bg_con05,129,178,4	script	Cyr#LF_ar07_13::LF_ar07_2	722,{
+	if( getcharid(4) == getvariableofnpc(.Defender,"Conquest") )
+	{
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Would";
+		mes "you like to teleport to";
+		mes "the Emperium Center?^000000";
+		switch( select("Teleport:Cancel") )
+		{
+		case 1:
+			warp "bg_con05",43,256;
+			end;
+		case 2:
+			close;
+		}
+	}
+	end;
+
+OnEmblemConquest:
+	FlagEmblem getvariableofnpc(.Defender,"Conquest");
+	end;
+}
+
+bg_con05,149,178,4	duplicate(LF_ar07_2)	Cyr#LF_ar07_14	722
+bg_con05,132,38,4	duplicate(LF_ar07_2)	Cyr#LF_ar07_15	722
+bg_con05,147,38,4	duplicate(LF_ar07_2)	Cyr#LF_ar07_16	722
+
+// Flags bg_con06
+// *********************************************************************
+
+bg_con06,122,314,0	script	LF-01#bg_con06	111,{
+	if( getcharid(4) == getvariableofnpc(.Defender,"Conquest") )
+	{
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch( select("First Gate House:Second Gate House:Cancel") )
+		{
+		case 1:
+			warp "bg_con06",84,158;
+			end;
+		case 2:
+			warp "bg_con06",197,136;
+			end;
+		case 3:
+			close;
+		}
+	}
+	end;
+}
+
+bg_con06,125,314,0	script	LF-02#bg_con06	111,{
+	if( getcharid(4) == getvariableofnpc(.Defender,"Conquest") )
+	{
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch( select("Defense Area 1-1:Defense Area 1-2:Cancel") )
+		{
+		case 1:
+			warp "bg_con06",65,94;
+			end;
+		case 2:
+			warp "bg_con06",211,97;
+			end;
+		case 3:
+			close;
+		}
+	}
+	end;
+}
+
+bg_con06,128,314,0	script	LF-03#bg_con06	111,{
+	if( getcharid(4) == getvariableofnpc(.Defender,"Conquest") )
+	{
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch( select("Defense Area 1-3:Defense Area 1-4:Cancel") )
+		{
+		case 1:
+			warp "bg_con06",112,73;
+			end;
+		case 2:
+			warp "bg_con06",171,73;
+			end;
+		case 3:
+			close;
+		}
+	}
+	end;
+}
+
+bg_con06,131,314,0	script	LF-04#bg_con06	111,{
+	if( getcharid(4) == getvariableofnpc(.Defender,"Conquest") )
+	{
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch( select("Defense Area 2-1:Defense Area 2-2:Cancel") )
+		{
+		case 1:
+			warp "bg_con06",112,152;
+			end;
+		case 2:
+			warp "bg_con06",172,152;
+			end;
+		case 3:
+			close;
+		}
+	}
+	end;
+}
+
+bg_con06,134,314,0	script	LF-05#bg_con06	111,{
+	if( getcharid(4) == getvariableofnpc(.Defender,"Conquest") )
+	{
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch( select("Defense Area 2-3:Defense Area 2-4:Cancel") )
+		{
+		case 1:
+			warp "bg_con06",120,186;
+			end;
+		case 2:
+			warp "bg_con06",162,186;
+			end;
+		case 3:
+			close;
+		}
+	}
+	end;
+}
+
+bg_con06,149,314,0	script	LF-06#bg_con06	111,{
+	if( getcharid(4) == getvariableofnpc(.Defender,"Conquest") )
+	{
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch( select("Defense Area 3-1:Defense Area 3-2:Cancel") )
+		{
+		case 1:
+			warp "bg_con06",116,235;
+			end;
+		case 2:
+			warp "bg_con06",164,235;
+			end;
+		case 3:
+			close;
+		}
+	}
+	end;
+}
+
+bg_con06,152,314,0	script	LF-07#bg_con06	111,{
+	if( getcharid(4) == getvariableofnpc(.Defender,"Conquest") )
+	{
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch( select("Defense Area 1-1:Defense Area 2-1:Defense Area 3-1:Cancel") )
+		{
+		case 1:
+			warp "bg_con06",65,94;
+			end;
+		case 2:
+			warp "bg_con06",112,152;
+			end;
+		case 3:
+			warp "bg_con06",116,235;
+			end;
+		case 4:
+			close;
+		}
+	}
+	end;
+}
+
+bg_con06,155,314,0	script	LF-08#bg_con06	111,{
+	if( getcharid(4) == getvariableofnpc(.Defender,"Conquest") )
+	{
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch( select("Defense Area 1-2:Defense Area 2-2:Defense Area 3-2:Cancel") )
+		{
+		case 1:
+			warp "bg_con06",211,97;
+			end;
+		case 2:
+			warp "bg_con06",172,152;
+			end;
+		case 3:
+			warp "bg_con06",164,235;
+			end;
+		case 4:
+			close;
+		}
+	}
+	end;
+}
+
+bg_con06,158,314,0	script	LF-09#bg_con06	111,{
+	if( getcharid(4) == getvariableofnpc(.Defender,"Conquest") )
+	{
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Please";
+		mes "choose a destination";
+		mes "within the stronghold.^000000";
+		switch( select("Defense Area 1-4:Defense Area 2-4:Cancel") )
+		{
+		case 1:
+			warp "bg_con06",171,73;
+			end;
+		case 2:
+			warp "bg_con06",162,186;
+			end;
+		case 3:
+			close;
+		}
+	}
+	end;
+}
+
+bg_con06,45,158,0	script	Horn#LF_ar08_01::LF_ar08_01	111,{
+	if( getcharid(4) == getvariableofnpc(.Defender,"Conquest") )
+	{
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Would";
+		mes "you like to teleport to";
+		mes "the Emperium Center?^000000";
+		switch( select("Teleport:Cancel") )
+		{
+		case 1:
+			warp "bg_con06",121,318;
+			end;
+		case 2:
+			close;
+		}
+	}
+	end;
+}
+
+bg_con06,226,156,0	duplicate(LF_ar08_01)	Horn#LF_ar08_01	111
+bg_con06,134,62,4	duplicate(LF_ar08_01)	Horn#LF_ar08_02	111
+bg_con06,149,62,4	duplicate(LF_ar08_01)	Horn#LF_ar08_03	111
+bg_con06,123,154,0	duplicate(LF_ar08_01)	Horn#LF_ar08_04	111
+bg_con06,160,154,0	duplicate(LF_ar08_01)	Horn#LF_ar08_05	111
+bg_con06,135,205,0	duplicate(LF_ar08_01)	Horn#LF_ar08_06	111
+bg_con06,148,205,0	duplicate(LF_ar08_01)	Horn#LF_ar08_07	111
+bg_con06,134,260,0	duplicate(LF_ar08_01)	Horn#LF_ar08_08	111
+
+bg_con06,148,103,4	script	Horn#LF_ar08_10::LF_ar08_02	722,{
+	if( getcharid(4) == getvariableofnpc(.Defender,"Conquest") )
+	{
+		mes "^3355FFThis is the Stronghold";
+		mes "Teleport Service. Would";
+		mes "you like to teleport to";
+		mes "the Emperium Center?^000000";
+		switch( select("Teleport:Cancel") )
+		{
+		case 1:
+			warp "bg_con06",121,318;
+			end;
+		case 2:
+			close;
+		}
+	}
+	end;
+
+OnEmblemConquest:
+	FlagEmblem getvariableofnpc(.Defender,"Conquest");
+	end;
+}
+
+bg_con06,135,103,4	duplicate(LF_ar08_02)	Horn#LF_ar08_11	722
+bg_con06,63,51,7	duplicate(LF_ar08_02)	Horn#LF_ar08_12	722
+bg_con06,214,51,1	duplicate(LF_ar08_02)	Horn#LF_ar08_13	722
+
+// MapFlags
+// *********************************************************************
+
+bg_con01	mapflag	battleground
+bg_con01	mapflag	nomemo
+bg_con01	mapflag	nosave	SavePoint
+bg_con01	mapflag	noteleport
+bg_con01	mapflag	nowarp
+bg_con01	mapflag	nowarpto
+bg_con01	mapflag	noreturn
+bg_con01	mapflag	nobranch
+bg_con01	mapflag	nopenalty
+bg_con01	mapflag	nodrop
+
+bg_con02	mapflag	battleground
+bg_con02	mapflag	nomemo
+bg_con02	mapflag	nosave	SavePoint
+bg_con02	mapflag	noteleport
+bg_con02	mapflag	nowarp
+bg_con02	mapflag	nowarpto
+bg_con02	mapflag	noreturn
+bg_con02	mapflag	nobranch
+bg_con02	mapflag	nopenalty
+
+bg_con03	mapflag	battleground
+bg_con03	mapflag	nomemo
+bg_con03	mapflag	nosave	SavePoint
+bg_con03	mapflag	noteleport
+bg_con03	mapflag	nowarp
+bg_con03	mapflag	nowarpto
+bg_con03	mapflag	noreturn
+bg_con03	mapflag	nobranch
+bg_con03	mapflag	nopenalty
+bg_con03	mapflag	nodrop
+
+bg_con04	mapflag	battleground
+bg_con04	mapflag	nomemo
+bg_con04	mapflag	nosave	SavePoint
+bg_con04	mapflag	noteleport
+bg_con04	mapflag	nowarp
+bg_con04	mapflag	nowarpto
+bg_con04	mapflag	noreturn
+bg_con04	mapflag	nobranch
+bg_con04	mapflag	nopenalty
+bg_con04	mapflag	nodrop
+
+bg_con05	mapflag	battleground
+bg_con05	mapflag	nomemo
+bg_con05	mapflag	nosave	SavePoint
+bg_con05	mapflag	noteleport
+bg_con05	mapflag	nowarp
+bg_con05	mapflag	nowarpto
+bg_con05	mapflag	noreturn
+bg_con05	mapflag	nobranch
+bg_con05	mapflag	nopenalty
+bg_con05	mapflag	nodrop
+
+bg_con06	mapflag	battleground
+bg_con06	mapflag	nomemo
+bg_con06	mapflag	nosave	SavePoint
+bg_con06	mapflag	noteleport
+bg_con06	mapflag	nowarp
+bg_con06	mapflag	nowarpto
+bg_con06	mapflag	noreturn
+bg_con06	mapflag	nobranch
+bg_con06	mapflag	nopenalty
+bg_con06	mapflag	nodrop
diff --git a/npc/battleground-extended/5-bg_kvm.txt b/npc/battleground-extended/5-bg_kvm.txt
new file mode 100644
index 000000000..66d4a0a0a
--- /dev/null
+++ b/npc/battleground-extended/5-bg_kvm.txt
@@ -0,0 +1,250 @@
+// ==============================================================================
+// BattleGround System - KvM
+// ==============================================================================
+
+// Light Effects
+// *********************************************************************
+
+bg_kvm,54,123,0	script	#bat_c01a	139,{
+	end;
+
+OnKvM01LightA: misceffect 54; end;
+OnKvM01LightB: misceffect 55; end;
+OnKvM01LightC: misceffect 56; end;
+}
+
+bg_kvm,56,125,0	duplicate(#bat_c01a)	#bat_c01b	139
+bg_kvm,58,127,0	duplicate(#bat_c01a)	#bat_c01c	139
+bg_kvm,141,56,0	duplicate(#bat_c01a)	#bat_c01d	139
+bg_kvm,143,58,0	duplicate(#bat_c01a)	#bat_c01e	139
+bg_kvm,145,60,0	duplicate(#bat_c01a)	#bat_c01f	139
+
+// Battleground Therapist
+// *********************************************************************
+bg_kvm,148,53,1	script	Therapist in battle#2	95,{
+	mes "[Therapist in battle]";
+	mes "Just close your eyes, and take a deep breathe.";
+	mes "You can be free from pain.";
+	specialeffect2 312;
+	percentheal 100,100;
+	close2;
+	openstorage;
+	end;
+}
+bg_kvm,51,130,5	duplicate(Therapist in battle#2)	Therapist in battle#1	95
+
+// Battleground Engine
+// *********************************************************************
+
+-	script	KvM01_BG	-1,{
+	end;
+
+OnInit:
+	setwall "bg_kvm",54,122,6,7,0,"batc01wall_a";
+	setwall "bg_kvm",55,122,5,7,0,"batc01wall_b";
+	setwall "bg_kvm",140,56,6,7,0,"batc01wall_c";
+	setwall "bg_kvm",140,57,5,7,0,"batc01wall_d";
+	disablenpc "Therapist in battle#1";
+	disablenpc "Therapist in battle#2";
+	end;
+
+OnTeam1Quit:
+	bg_desert;
+	if( $@BG_Status != 0 && bg_current_mode() == bg_info("bg_kvm", BG_INFO_ID) )
+		donpcevent "BG_Queue_Join::OnJoinEvent";
+OnTeam1Die:
+	if( $@KvM01BG == 2 && $@BG_Status == 2 && bg_current_mode() == bg_info("bg_kvm", BG_INFO_ID))
+	{
+		getmapxy .@m$, .@x, .@y, BL_PC;
+		if( .@m$ != "bg_kvm" || (.@x >= 50 && .@x <= 58 && .@y >= 123 && .@y <= 131) )
+			end; // Killed/Logout on Cementery or outside the map?
+
+		set .Guillaume_Count, .Guillaume_Count - 1;
+		set .Team2_Score, .Team2_Score + 1;
+		bg_updatescore "bg_kvm",.Team1_Score,.Team2_Score;
+		if( .Guillaume_Count < 1 ) donpcevent "KvM01_BG::OnCroixWin";
+	}
+	end;
+
+OnTeam2Quit:
+	bg_desert;
+	if( $@BG_Status != 0 && bg_current_mode() == bg_info("bg_kvm", BG_INFO_ID) )
+		donpcevent "BG_Queue_Join::OnJoinEvent";
+OnTeam2Die:
+	if( $@KvM01BG == 2 && $@BG_Status == 2 && bg_current_mode() == bg_info("bg_kvm", BG_INFO_ID))
+	{
+		getmapxy .@m$, .@x, .@y, BL_PC;
+		if( .@m$ != "bg_kvm" || (.@x >= 141 && .@x <= 149 && .@y >= 52 && .@y <= 60) )
+			end; // Killed/Logout on Cementery or outside the map?
+
+		set .Croix_Count, .Croix_Count - 1;
+		set .Team1_Score, .Team1_Score + 1;
+		bg_updatescore "bg_kvm",.Team1_Score,.Team2_Score;
+		if( .Croix_Count < 1 ) donpcevent "KvM01_BG::OnGuillaumeWin";
+	}
+	end;
+	
+OnReady:
+	if( bg_current_mode() != bg_info("bg_kvm", BG_INFO_ID) )
+		end;
+	if( $@KvM01BG || $@Global_BG_Block )
+		end;
+	
+	set $@BG_Status, 1;
+	set $@KvM01BG, 1; // Starting
+	donpcevent "KvM01_BG::OnStart";
+	end;
+
+OnBGTeam1Active:
+	warp "bg_kvm",53,128;
+	donpcevent "BG_Queue_Join::OnJoinEvent";
+	end;
+
+OnBGTeam2Active:
+	warp "bg_kvm",146,55;
+	donpcevent "BG_Queue_Join::OnJoinEvent";
+	end;
+	
+OnStart:
+	if( $@BG_Status != 1 || bg_current_mode() != bg_info("bg_kvm", BG_INFO_ID) )
+		end;
+
+	enablenpc "Therapist in battle#1";
+	enablenpc "Therapist in battle#2";
+	set $@KvM01BG_Victory, 0;
+	sleep 2000;
+	// Warp Teams
+	bg_warp $@BG_Team1,"bg_kvm",53,128;
+	bg_warp $@BG_Team2,"bg_kvm",146,55;
+	// ScoreBoard
+	set .Team1_Score, 0;
+	set .Team2_Score, 0;
+	initnpctimer;
+	end;
+
+OnTimer5000:
+	areapercentheal "bg_kvm",50,123,58,131,100,100;
+	areapercentheal "bg_kvm",141,52,149,60,100,100;
+	mapannounce "bg_kvm","The Battle will start in 25 seconds!!",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+	end;
+
+OnTimer26000:
+	mapannounce "bg_kvm","The Battle will start in 4 seconds!!",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+	set $@BG_Status, 2; // Prevent people to enter
+	bg_reserve "bg_kvm", true;
+	end;
+
+OnTimer27000:
+	donpcevent "::OnKvM01LightA";
+	end;
+
+OnTimer28000:
+	donpcevent "::OnKvM01LightB";
+	end;
+
+OnTimer29000:
+	donpcevent "::OnKvM01LightC";
+	end;
+
+OnTimer30000:
+	// Team Members
+	set .Guillaume_Count, bg_get_data($@BG_Team1, 0);
+	set .Croix_Count, bg_get_data($@BG_Team2, 0);
+	if( .Guillaume_Count < getvariableofnpc(.BG_Min[8],"BG_Queue_Join") || .Croix_Count < getvariableofnpc(.BG_Min[8],"BG_Queue_Join") )
+	{
+		set $@KvM01BG_Victory, 3;
+		set $@KvM01BG, 3;
+		mapannounce "bg_kvm","There are not enough players to start the battle",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+		stopnpctimer;
+		sleep 2000;
+		donpcevent "KvM01_BG::OnStop";
+		end;
+	}
+	disablenpc "Therapist in battle#1";
+	disablenpc "Therapist in battle#2";
+	set $@KvM01BG, 2; // Playing
+	areapercentheal "bg_kvm",50,123,58,131,100,100;
+	bg_warp $@BG_Team1,"bg_kvm",62,119;
+	areapercentheal "bg_kvm",141,52,149,60,100,100;
+	bg_warp $@BG_Team2,"bg_kvm",137,64;
+	end;
+
+OnTimer32000:
+	mapannounce "bg_kvm","The Battle of Kreiger Von Midgard has begun!!",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+	end;
+
+OnTimer300000:
+	mapannounce "bg_kvm","The Battle will ends in 30 seconds!!",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+	end;
+
+OnTimer330000:
+OnPrematureEnd:
+	if( .Croix_Count > .Guillaume_Count )
+		donpcevent "KvM01_BG::OnCroixWin";
+	else if( .Croix_Count < .Guillaume_Count )
+		donpcevent "KvM01_BG::OnGuillaumeWin";
+	else
+	{ // Draw Game
+		set $@KvM01BG, 3;
+		set $@KvM01BG_Victory, 3;
+		stopnpctimer;
+		sleep 2000;
+		mapannounce "bg_kvm","The time is out! This is a Tie...",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+		callfunc("Reward_BG","bg_kvm", 0);
+		donpcevent "KvM01_BG::OnStop";
+	}
+	end;
+
+OnGuillaumeWin:
+	set $@KvM01BG, 3;
+	set $@KvM01BG_Victory, 1;
+	stopnpctimer;
+	sleep 2000;
+	callfunc("Reward_BG","bg_kvm", 1);
+	mapannounce "bg_kvm","The " + bg_get_data($@BG_Team1,2) + " army has won the Battle of Kreiger Von Midgard!",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+	donpcevent "KvM01_BG::OnStop";
+	end;
+
+OnCroixWin:
+	set $@KvM01BG, 3;
+	set $@KvM01BG_Victory, 2;
+	stopnpctimer;
+	sleep 2000;
+	callfunc("Reward_BG","bg_kvm", 2);
+
+	mapannounce "bg_kvm","The " + bg_get_data($@BG_Team2,2) + " army has won the Battle of Kreiger Von Midgard!",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+	donpcevent "KvM01_BG::OnStop";
+	end;
+
+OnStop:
+	// Reset salle
+	set .Croix_Count, 0;
+	set .Guillaume_Count, 0;
+	set .Team2_Score, 0;
+	set .Team1_Score, 0;
+	set $@KvM01BG_Victory, 0;
+	disablenpc "Therapist in battle#1";
+	disablenpc "Therapist in battle#2";
+	sleep 2000;
+	set $@KvM01BG, 0;
+	bg_unbook "bg_kvm";
+	donpcevent "BG_Queue_Join::OnRotate";
+	bg_updatescore "bg_kvm",0,0;
+	end;
+}
+
+
+// MapFlags
+// *********************************************************************
+
+bg_kvm	mapflag	battleground	2
+bg_kvm	mapflag	nomemo
+bg_kvm	mapflag	nosave	SavePoint
+bg_kvm	mapflag	noteleport
+bg_kvm	mapflag	nowarp
+bg_kvm	mapflag	nowarpto
+bg_kvm	mapflag	noreturn
+bg_kvm	mapflag	nobranch
+bg_kvm	mapflag	nopenalty
+//bg_kvm	mapflag	noemergencycall
+bg_kvm	mapflag	nodrop
diff --git a/npc/battleground-extended/6-bg_sc.txt b/npc/battleground-extended/6-bg_sc.txt
new file mode 100644
index 000000000..b4dca6d72
--- /dev/null
+++ b/npc/battleground-extended/6-bg_sc.txt
@@ -0,0 +1,1092 @@
+// (c) 2008 - 2012 eAmod Project; Andres Garbanzo / Zephyrus
+//
+//  - gaiaro.staff@yahoo.com
+//  - MSN andresjgm.cr@hotmail.com
+//  - Skype: Zephyrus_cr
+//  - Site: http://dev.terra-gaming.com
+//
+// This file is NOT public - you are not allowed to distribute it.
+// Authorized Server List : http://dev.terra-gaming.com/index.php?/topic/72-authorized-eamod-servers/
+// eAmod is a non Free, extended version of eAthena Ragnarok Private Server.
+
+// ==============================================================================
+// BattleGround System - Flavius Stone Control
+// ==============================================================================
+
+// Battleground Engine
+// *********************************************************************
+
+-	script	Flavius_SC	-1,{
+	end;
+
+OnTeam1Quit:
+OnTeam2Quit:
+	bg_desert;
+	set @killer_bg_src,0;
+	if( $@BG_Status != 0 && bg_current_mode() == bg_info("bg_sc", BG_INFO_ID) )
+		donpcevent "BG_Queue_Join::OnJoinEvent";
+OnTeam1Die:
+OnTeam2Die:
+	if( $@BG_Status == 1 && bg_current_mode() == bg_info("bg_sc", BG_INFO_ID) && set(.@Stone,callfunc("SC_StoneCheck",getcharid(0))) > 0 )
+	{ // Stone Carrier
+		set .Stone[.@Stone],0;
+		getmapxy .@m$, .@x, .@y, BL_PC;
+		movenpc "Neutral Stone#" + .@Stone, .@x, .@y;
+		mapannounce "bg_sc","Neutral Stone Droped by [ " + strcharinfo(0) + " ]",1,0xFFFFFF;
+		//bg_rankpoints "sc_droped",1;
+		//bg_rankpoints "fame",1,@killer_bg_src;
+		initnpctimer "Neutral Stone#" + .@Stone;
+		deltimer "Flavius_SC::OnFlash";
+		pcblock 1,0;
+		enablenpc "Neutral Stone#" + .@Stone;
+	}
+	end;
+
+OnReady:
+	if( bg_current_mode() != bg_info("bg_sc", BG_INFO_ID) )
+		end;
+
+	set $@BG_Status, 1;
+	initnpctimer;
+	set .Team1_Score, 0;
+	set .Team2_Score, 0;
+	setarray .Stone[1],0,0,0,0,0,0;
+	setarray .X[1],117,110,89,83,95,104;
+	setarray .Y[1],84,77,107,100,94,85;
+	for( set .@i, 1; .@i < 7; set .@i, .@i + 1 )
+		donpcevent "Neutral Stone#" + .@i + "::OnBGStart";
+
+	bg_updatescore "bg_sc",.Team1_Score,.Team2_Score;
+	sleep 2000;
+	bg_warp $@BG_Team1,"bg_sc",141,59;
+	bg_warp $@BG_Team2,"bg_sc",58,123;
+	sleep 2000;
+	donpcevent "#guisc_respawn::OnBGStart";
+	donpcevent "#crosc_respawn::OnBGStart";
+	end;
+
+OnBGTeam1Active:
+	warp "bg_sc",172,122;
+	donpcevent "BG_Queue_Join::OnJoinEvent";
+	end;
+
+OnBGTeam2Active:
+	warp "bg_sc",28,57;
+	donpcevent "BG_Queue_Join::OnJoinEvent";
+	end;
+	
+OnTeam1Score:
+	set .Team1_Score, .Team1_Score + 1;
+	donpcevent "Flavius_SC::OnValidateScore";
+	end;
+
+OnTeam2Score:
+	set .Team2_Score, .Team2_Score + 1;
+	donpcevent "Flavius_SC::OnValidateScore";
+	end;
+
+OnValidateScore:
+	if( $@BG_Status != 1 || bg_current_mode() != bg_info("bg_sc", BG_INFO_ID) )
+		end;
+	if( .Team1_Score > 35 )
+		set .Team1_Score,35;
+	if( .Team2_Score > 35 )
+		set .Team2_Score,35;
+
+	bg_updatescore "bg_sc",.Team1_Score,.Team2_Score;
+	if( .Team2_Score >= 35 || .Team1_Score >= 35 )
+		donpcevent "Flavius_SC::OnMatchEnd";
+	end;
+
+OnTimer600000:
+	mapannounce "bg_sc","The Battle will ends in 5 minutes!!",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+	end;
+
+OnTimer840000:
+	mapannounce "bg_sc","The Battle will ends in 1 minute!!",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+	end;
+
+OnTimer900000:
+OnMatchEnd:
+OnPrematureEnd:
+	stopnpctimer;
+	donpcevent "#guisc_respawn::OnBGStop";
+	donpcevent "#crosc_respawn::OnBGStop";
+	set $@BG_Status, 2;
+	bg_reserve "bg_sc", true;
+	// =======================================================
+	// Team Rewards
+	// =======================================================
+	if( .Team1_Score > .Team2_Score )
+	{ // Team 1 Won
+		callfunc("Reward_BG","bg_sc", 1);
+		mapannounce "bg_sc","The " + bg_get_data($@BG_Team1,2) + " army has won the Battle of Flavius SC!",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+	}
+	else if( .Team1_Score < .Team2_Score )
+	{ // Team 2 Won
+		callfunc("Reward_BG","bg_sc", 2);
+		mapannounce "bg_sc","The " + bg_get_data($@BG_Team2,2) + " army has won the Battle of Flavius SC!",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+	}
+	else
+	{
+		callfunc("Reward_BG","bg_sc", 0);
+		mapannounce "bg_sc","The battle is over. This is a Tie...!",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+	}
+	// =======================================================
+	set .Team1_Score, 0;
+	set .Team2_Score, 0;
+	for( set .@i, 1; .@i < 7; set .@i, .@i + 1 )
+	{ // Stop Running Timers
+		stopnpctimer "Neutral Stone#" + .@i;
+		stopnpctimer "csp" + .@i; // Team2 Stone Point
+		stopnpctimer "gsp" + .@i; // Team1 Stone Point
+	}
+	sleep 5000;
+	setarray .Stone[1],0,0,0,0,0,0;
+	bg_unbook "bg_sc";
+	donpcevent "BG_Queue_Join::OnRotate";
+	bg_updatescore "bg_sc",0,0;
+	for( set .@i, 1; .@i < 7; set .@i, .@i + 1 )
+	{ // Return Stones to Starting Position and Normalize Stone Points
+		donpcevent "Neutral Stone#" + .@i + "::OnBGStop";
+		donpcevent "csp" + .@i + "::OnBGStop";
+		donpcevent "gsp" + .@i + "::OnBGStop";
+	}
+	end;
+
+OnFlash:
+	if( $@BG_Status == 1 && bg_current_mode() == bg_info("bg_sc", BG_INFO_ID) && set(.@Stone,callfunc("SC_StoneCheck",getcharid(0))) > 0 )
+	{
+		getmapxy .@m$, .@x, .@y, BL_PC;
+		if( getcharid(4) == $@BG_Team1 )
+			viewpointmap "bg_sc",1, .@x, .@y, .@Stone, 0x0000FF;
+		else if( getcharid(4) == $@BG_Team2 )
+			viewpointmap "bg_sc",1, .@x, .@y, .@Stone, 0xFF0000;
+
+		specialeffect2 73;
+		emotion ET_HELP,getcharid(3);
+		addtimer 2000, "Flavius_SC::OnFlash";
+		percentheal -5,-5;
+	}
+	end;
+}
+
+// Basic Functions
+// *********************************************************************
+
+function	script	SC_StoneCheck	{
+	for( set .@i, 1; .@i < 7; set .@i, .@i + 1 )
+	{
+		if( getvariableofnpc(.Stone[.@i],"Flavius_SC") == getarg(0) )
+			return .@i;
+	}
+	return 0;
+}
+
+// Neutral Stones
+// *********************************************************************
+
+bg_sc,117,84,0	script	Neutral Stone#1	1905,1,1,{
+	end;
+
+OnTouch:
+	if( $@BG_Status != 1 || bg_current_mode() != bg_info("bg_sc", BG_INFO_ID) || HP < 1 || getcharid(4) == 0 )
+		end;
+	set .@Stone,atoi(strnpcinfo(2));
+	if( getvariableofnpc(.Stone[.@Stone],"Flavius_SC") != 0 )
+		end; // Already Captured
+	if( callfunc("SC_StoneCheck",getcharid(0)) != 0 )
+		end; // Already with a Stone
+
+	sc_end SC_HIDING;
+	sc_end SC_CLOAKING;
+	sc_end SC_CHASEWALK;
+	sc_end SC_CLOAKINGEXCEED;
+	sc_end SC_CAMOUFLAGE;
+	sc_end SC__INVISIBILITY;
+	pcblock 1,1; // Block Skills/Items
+
+	set getvariableofnpc(.Stone[.@Stone],"Flavius_SC"),getcharid(0);
+	addtimer 2000, "Flavius_SC::OnFlash";
+	disablenpc strnpcinfo(0);
+	stopnpctimer;
+	end;
+
+OnBGStart:
+	initnpctimer;
+	end;
+
+OnTimer2000:
+	initnpctimer;
+	getmapxy .@m$, .@x, .@y, BL_NPC;
+	viewpointmap "bg_sc",1, .@x, .@y, atoi(strnpcinfo(2)), 0xFFFFFF;
+	end;
+
+OnBGStop:
+	set .@Stone,atoi(strnpcinfo(2));
+	movenpc strnpcinfo(0),getvariableofnpc(.X[.@Stone],"Flavius_SC"),getvariableofnpc(.Y[.@Stone],"Flavius_SC");
+	enablenpc strnpcinfo(0);
+	stopnpctimer;
+	end;
+}
+
+bg_sc,110,77,0	duplicate(Neutral Stone#1)	Neutral Stone#2	1905,1,1
+bg_sc,89,107,0	duplicate(Neutral Stone#1)	Neutral Stone#3	1905,1,1
+bg_sc,83,100,0	duplicate(Neutral Stone#1)	Neutral Stone#4	1905,1,1
+bg_sc,95,94,0	duplicate(Neutral Stone#1)	Neutral Stone#5	1905,1,1
+bg_sc,104,85,0	duplicate(Neutral Stone#1)	Neutral Stone#6	1905,1,1
+
+// Stone Point - Team 2
+// *********************************************************************
+
+bg_sc,52,52,0	script	Stone Point::csp1	1309,1,1,{
+	end;
+
+OnTouch:
+	if( $@BG_Status != 1 || bg_current_mode() != bg_info("bg_sc", BG_INFO_ID) || HP < 1 )
+		end;
+	if( .Point != 0 && getcharid(4) == $@BG_Team1 && callfunc("SC_StoneCheck",getcharid(0)) == 0 )
+	{ // Team 1 Stole
+		set getvariableofnpc(.Stone[.Point],"Flavius_SC"),getcharid(0);
+		setnpcdisplay strnpcinfo(3),"Stone Point",1309;
+
+		sc_end SC_HIDING;
+		sc_end SC_CLOAKING;
+		sc_end SC_CHASEWALK;
+		sc_end SC_CLOAKINGEXCEED;
+		sc_end SC_CAMOUFLAGE;
+		sc_end SC__INVISIBILITY;
+		pcblock 1,1; // Block Skills/Items
+
+		mapannounce "bg_sc",bg_get_data($@BG_Team2,2) + " Stone has been stole by [ " + strcharinfo(0) + " ]",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+		//bg_rankpoints "sc_stole",1;
+
+		addtimer 2000, "Flavius_SC::OnFlash";
+		set .Point,0;
+		stopnpctimer;
+	}
+	else if( .Point == 0 && getcharid(4) == $@BG_Team2 && set(.@Stone,callfunc("SC_StoneCheck",getcharid(0))) > 0 )
+	{ // Check if user got a Stone
+		initnpctimer;
+		set .Point,.@Stone;
+		set .Count, 0;
+		deltimer "Flavius_SC::OnFlash";
+
+		mapannounce "bg_sc",bg_get_data($@BG_Team2,2) + " Stone captured by [ " + strcharinfo(0) + " ]",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+		//bg_rankpoints "sc_captured",1;
+		pcblock 1,0; // UnBlock Skills/Items
+
+		setnpcdisplay strnpcinfo(3),bg_get_data($@BG_Team2,2) + " Stone",1905;
+		set getvariableofnpc(.Stone[.Point],"Flavius_SC"),0;
+	}
+	end;
+
+OnTimer2000:
+	initnpctimer;
+	getmapxy .@m$, .@x, .@y, BL_NPC;
+	viewpointmap "bg_sc",1, .@x, .@y, .Point, bg_info(bg_current_mode(), BG_INFO_COLOR);
+	specialeffect 223;
+	if( set(.Count, .Count + 1) >= 5 )
+	{
+		set .Count, 0;
+		donpcevent "Flavius_SC::OnTeam2Score";
+	}
+	end;
+
+OnBGStop:
+	stopnpctimer;
+	setnpcdisplay strnpcinfo(3),"Stone Point",1309;
+	set .Point, 0;
+	set .Count, 0;
+	end;
+}
+
+bg_sc,56,52,0	script	Stone Point::csp2	1309,1,1,{
+	end;
+
+OnTouch:
+	if( $@BG_Status != 1 || bg_current_mode() != bg_info("bg_sc", BG_INFO_ID) || HP < 1 )
+		end;
+	if( .Point != 0 && getcharid(4) == $@BG_Team1 && callfunc("SC_StoneCheck",getcharid(0)) == 0 )
+	{ // Team 1 Stole
+		set getvariableofnpc(.Stone[.Point],"Flavius_SC"),getcharid(0);
+		setnpcdisplay strnpcinfo(3),"Stone Point",1309;
+
+		sc_end SC_HIDING;
+		sc_end SC_CLOAKING;
+		sc_end SC_CHASEWALK;
+		sc_end SC_CLOAKINGEXCEED;
+		sc_end SC_CAMOUFLAGE;
+		sc_end SC__INVISIBILITY;
+		pcblock 1,1; // Block Skills/Items
+
+		mapannounce "bg_sc",bg_get_data($@BG_Team2,2) + " Stone has been stole by [ " + strcharinfo(0) + " ]",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+		//bg_rankpoints "sc_stole",1;
+
+		addtimer 2000, "Flavius_SC::OnFlash";
+		set .Point,0;
+		stopnpctimer;
+	}
+	else if( .Point == 0 && getcharid(4) == $@BG_Team2 && set(.@Stone,callfunc("SC_StoneCheck",getcharid(0))) > 0 )
+	{ // Check if user got a Stone
+		initnpctimer;
+		set .Point,.@Stone;
+		set .Count, 0;
+		deltimer "Flavius_SC::OnFlash";
+
+		mapannounce "bg_sc",bg_get_data($@BG_Team2,2) + " Stone captured by [ " + strcharinfo(0) + " ]",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+		//bg_rankpoints "sc_captured",1;
+		pcblock 1,0; // UnBlock Skills/Items
+
+		setnpcdisplay strnpcinfo(3),bg_get_data($@BG_Team2,2) + " Stone",1905;
+		set getvariableofnpc(.Stone[.Point],"Flavius_SC"),0;
+	}
+	end;
+
+OnTimer2000:
+	initnpctimer;
+	getmapxy .@m$, .@x, .@y, BL_NPC;
+	viewpointmap "bg_sc",1, .@x, .@y, .Point, bg_info(bg_current_mode(), BG_INFO_COLOR);
+	specialeffect 223;
+	if( set(.Count, .Count + 1) >= 5 )
+	{
+		set .Count, 0;
+		donpcevent "Flavius_SC::OnTeam2Score";
+	}
+	end;
+
+OnBGStop:
+	stopnpctimer;
+	setnpcdisplay strnpcinfo(3),"Stone Point",1309;
+	set .Point, 0;
+	set .Count, 0;
+	end;
+}
+
+bg_sc,60,52,0	script	Stone Point::csp3	1309,1,1,{
+	end;
+
+OnTouch:
+	if( $@BG_Status != 1 || bg_current_mode() != bg_info("bg_sc", BG_INFO_ID) || HP < 1 )
+		end;
+	if( .Point != 0 && getcharid(4) == $@BG_Team1 && callfunc("SC_StoneCheck",getcharid(0)) == 0 )
+	{ // Team 1 Stole
+		set getvariableofnpc(.Stone[.Point],"Flavius_SC"),getcharid(0);
+		setnpcdisplay strnpcinfo(3),"Stone Point",1309;
+
+		sc_end SC_HIDING;
+		sc_end SC_CLOAKING;
+		sc_end SC_CHASEWALK;
+		sc_end SC_CLOAKINGEXCEED;
+		sc_end SC_CAMOUFLAGE;
+		sc_end SC__INVISIBILITY;
+		pcblock 1,1; // Block Skills/Items
+
+		mapannounce "bg_sc",bg_get_data($@BG_Team2,2) + " Stone has been stole by [ " + strcharinfo(0) + " ]",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+		//bg_rankpoints "sc_stole",1;
+
+		addtimer 2000, "Flavius_SC::OnFlash";
+		set .Point,0;
+		stopnpctimer;
+	}
+	else if( .Point == 0 && getcharid(4) == $@BG_Team2 && set(.@Stone,callfunc("SC_StoneCheck",getcharid(0))) > 0 )
+	{ // Check if user got a Stone
+		initnpctimer;
+		set .Point,.@Stone;
+		set .Count, 0;
+		deltimer "Flavius_SC::OnFlash";
+
+		mapannounce "bg_sc",bg_get_data($@BG_Team2,2) + " Stone captured by [ " + strcharinfo(0) + " ]",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+		//bg_rankpoints "sc_captured",1;
+		pcblock 1,0; // UnBlock Skills/Items
+
+		setnpcdisplay strnpcinfo(3),bg_get_data($@BG_Team2,2) + " Stone",1905;
+		set getvariableofnpc(.Stone[.Point],"Flavius_SC"),0;
+	}
+	end;
+
+OnTimer2000:
+	initnpctimer;
+	getmapxy .@m$, .@x, .@y, BL_NPC;
+	viewpointmap "bg_sc",1, .@x, .@y, .Point, bg_info(bg_current_mode(), BG_INFO_COLOR);
+	specialeffect 223;
+	if( set(.Count, .Count + 1) >= 5 )
+	{
+		set .Count, 0;
+		donpcevent "Flavius_SC::OnTeam2Score";
+	}
+	end;
+
+OnBGStop:
+	stopnpctimer;
+	setnpcdisplay strnpcinfo(3),"Stone Point",1309;
+	set .Point, 0;
+	set .Count, 0;
+	end;
+}
+
+bg_sc,50,54,0	script	Stone Point::csp4	1309,1,1,{
+	end;
+
+OnTouch:
+	if( $@BG_Status != 1 || bg_current_mode() != bg_info("bg_sc", BG_INFO_ID) || HP < 1 )
+		end;
+	if( .Point != 0 && getcharid(4) == $@BG_Team1 && callfunc("SC_StoneCheck",getcharid(0)) == 0 )
+	{ // Team 1 Stole
+		set getvariableofnpc(.Stone[.Point],"Flavius_SC"),getcharid(0);
+		setnpcdisplay strnpcinfo(3),"Stone Point",1309;
+
+		sc_end SC_HIDING;
+		sc_end SC_CLOAKING;
+		sc_end SC_CHASEWALK;
+		sc_end SC_CLOAKINGEXCEED;
+		sc_end SC_CAMOUFLAGE;
+		sc_end SC__INVISIBILITY;
+		pcblock 1,1; // Block Skills/Items
+
+		mapannounce "bg_sc",bg_get_data($@BG_Team2,2) + " Stone has been stole by [ " + strcharinfo(0) + " ]",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+		//bg_rankpoints "sc_stole",1;
+
+		addtimer 2000, "Flavius_SC::OnFlash";
+		set .Point,0;
+		stopnpctimer;
+	}
+	else if( .Point == 0 && getcharid(4) == $@BG_Team2 && set(.@Stone,callfunc("SC_StoneCheck",getcharid(0))) > 0 )
+	{ // Check if user got a Stone
+		initnpctimer;
+		set .Point,.@Stone;
+		set .Count, 0;
+		deltimer "Flavius_SC::OnFlash";
+
+		mapannounce "bg_sc",bg_get_data($@BG_Team2,2) + " Stone captured by [ " + strcharinfo(0) + " ]",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+		//bg_rankpoints "sc_captured",1;
+		pcblock 1,0; // UnBlock Skills/Items
+
+		setnpcdisplay strnpcinfo(3),bg_get_data($@BG_Team2,2) + " Stone",1905;
+		set getvariableofnpc(.Stone[.Point],"Flavius_SC"),0;
+	}
+	end;
+
+OnTimer2000:
+	initnpctimer;
+	getmapxy .@m$, .@x, .@y, BL_NPC;
+	viewpointmap "bg_sc",1, .@x, .@y, .Point, bg_info(bg_current_mode(), BG_INFO_COLOR);
+	specialeffect 223;
+	if( set(.Count, .Count + 1) >= 5 )
+	{
+		set .Count, 0;
+		donpcevent "Flavius_SC::OnTeam2Score";
+	}
+	end;
+
+OnBGStop:
+	stopnpctimer;
+	setnpcdisplay strnpcinfo(3),"Stone Point",1309;
+	set .Point, 0;
+	set .Count, 0;
+	end;
+}
+
+bg_sc,50,58,0	script	Stone Point::csp5	1309,1,1,{
+	end;
+
+OnTouch:
+	if( $@BG_Status != 1 || bg_current_mode() != bg_info("bg_sc", BG_INFO_ID) || HP < 1 )
+		end;
+	if( .Point != 0 && getcharid(4) == $@BG_Team1 && callfunc("SC_StoneCheck",getcharid(0)) == 0 )
+	{ // Team 1 Stole
+		set getvariableofnpc(.Stone[.Point],"Flavius_SC"),getcharid(0);
+		setnpcdisplay strnpcinfo(3),"Stone Point",1309;
+
+		sc_end SC_HIDING;
+		sc_end SC_CLOAKING;
+		sc_end SC_CHASEWALK;
+		sc_end SC_CLOAKINGEXCEED;
+		sc_end SC_CAMOUFLAGE;
+		sc_end SC__INVISIBILITY;
+		pcblock 1,1; // Block Skills/Items
+
+		mapannounce "bg_sc",bg_get_data($@BG_Team2,2) + " Stone has been stole by [ " + strcharinfo(0) + " ]",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+		//bg_rankpoints "sc_stole",1;
+
+		addtimer 2000, "Flavius_SC::OnFlash";
+		set .Point,0;
+		stopnpctimer;
+	}
+	else if( .Point == 0 && getcharid(4) == $@BG_Team2 && set(.@Stone,callfunc("SC_StoneCheck",getcharid(0))) > 0 )
+	{ // Check if user got a Stone
+		initnpctimer;
+		set .Point,.@Stone;
+		set .Count, 0;
+		deltimer "Flavius_SC::OnFlash";
+
+		mapannounce "bg_sc",bg_get_data($@BG_Team2,2) + " Stone captured by [ " + strcharinfo(0) + " ]",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+		//bg_rankpoints "sc_captured",1;
+		pcblock 1,0; // UnBlock Skills/Items
+
+		setnpcdisplay strnpcinfo(3),bg_get_data($@BG_Team2,2) + " Stone",1905;
+		set getvariableofnpc(.Stone[.Point],"Flavius_SC"),0;
+	}
+	end;
+
+OnTimer2000:
+	initnpctimer;
+	getmapxy .@m$, .@x, .@y, BL_NPC;
+	viewpointmap "bg_sc",1, .@x, .@y, .Point, bg_info(bg_current_mode(), BG_INFO_COLOR);
+	specialeffect 223;
+	if( set(.Count, .Count + 1) >= 5 )
+	{
+		set .Count, 0;
+		donpcevent "Flavius_SC::OnTeam2Score";
+	}
+	end;
+
+OnBGStop:
+	stopnpctimer;
+	setnpcdisplay strnpcinfo(3),"Stone Point",1309;
+	set .Point, 0;
+	set .Count, 0;
+	end;
+}
+
+bg_sc,50,62,0	script	Stone Point::csp6	1309,1,1,{
+	end;
+
+OnTouch:
+	if( $@BG_Status != 1 || bg_current_mode() != bg_info("bg_sc", BG_INFO_ID) || HP < 1 )
+		end;
+	if( .Point != 0 && getcharid(4) == $@BG_Team1 && callfunc("SC_StoneCheck",getcharid(0)) == 0 )
+	{ // Team 1 Stole
+		set getvariableofnpc(.Stone[.Point],"Flavius_SC"),getcharid(0);
+		setnpcdisplay strnpcinfo(3),"Stone Point",1309;
+
+		sc_end SC_HIDING;
+		sc_end SC_CLOAKING;
+		sc_end SC_CHASEWALK;
+		sc_end SC_CLOAKINGEXCEED;
+		sc_end SC_CAMOUFLAGE;
+		sc_end SC__INVISIBILITY;
+		pcblock 1,1; // Block Skills/Items
+
+		mapannounce "bg_sc",bg_get_data($@BG_Team2,2) + " Stone has been stole by [ " + strcharinfo(0) + " ]",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+		//bg_rankpoints "sc_stole",1;
+
+		addtimer 2000, "Flavius_SC::OnFlash";
+		set .Point,0;
+		stopnpctimer;
+	}
+	else if( .Point == 0 && getcharid(4) == $@BG_Team2 && set(.@Stone,callfunc("SC_StoneCheck",getcharid(0))) > 0 )
+	{ // Check if user got a Stone
+		initnpctimer;
+		set .Point,.@Stone;
+		set .Count, 0;
+		deltimer "Flavius_SC::OnFlash";
+
+		mapannounce "bg_sc",bg_get_data($@BG_Team2,2) + " Stone captured by [ " + strcharinfo(0) + " ]",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+		//bg_rankpoints "sc_captured",1;
+		pcblock 1,0; // UnBlock Skills/Items
+
+		setnpcdisplay strnpcinfo(3),bg_get_data($@BG_Team2,2) + " Stone",1905;
+		set getvariableofnpc(.Stone[.Point],"Flavius_SC"),0;
+	}
+	end;
+
+OnTimer2000:
+	initnpctimer;
+	getmapxy .@m$, .@x, .@y, BL_NPC;
+	viewpointmap "bg_sc",1, .@x, .@y, .Point, bg_info(bg_current_mode(), BG_INFO_COLOR);
+	specialeffect 223;
+	if( set(.Count, .Count + 1) >= 5 )
+	{
+		set .Count, 0;
+		donpcevent "Flavius_SC::OnTeam2Score";
+	}
+	end;
+
+OnBGStop:
+	stopnpctimer;
+	setnpcdisplay strnpcinfo(3),"Stone Point",1309;
+	set .Point, 0;
+	set .Count, 0;
+	end;
+}
+
+// Stone Point - Team 1
+// *********************************************************************
+
+bg_sc,147,131,0	script	Stone Point::gsp1	1309,1,1,{
+	end;
+
+OnTouch:
+	if( $@BG_Status != 1 || bg_current_mode() != bg_info("bg_sc", BG_INFO_ID) || HP < 1 )
+		end;
+	if( .Point != 0 && getcharid(4) == $@BG_Team2 && callfunc("SC_StoneCheck",getcharid(0)) == 0 )
+	{ // Team 2 Stole
+		set getvariableofnpc(.Stone[.Point],"Flavius_SC"),getcharid(0);
+		setnpcdisplay strnpcinfo(3),"Stone Point",1309;
+
+		sc_end SC_HIDING;
+		sc_end SC_CLOAKING;
+		sc_end SC_CHASEWALK;
+		sc_end SC_CLOAKINGEXCEED;
+		sc_end SC_CAMOUFLAGE;
+		sc_end SC__INVISIBILITY;
+		pcblock 1,1; // Block Skills/Items
+
+		mapannounce "bg_sc",bg_get_data($@BG_Team1,2) + " Stone has been stole by [ " + strcharinfo(0) + " ]",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+		//bg_rankpoints "sc_stole",1;
+
+		addtimer 2000, "Flavius_SC::OnFlash";
+		set .Point,0;
+		stopnpctimer;
+	}
+	else if( .Point == 0 && getcharid(4) == $@BG_Team1 && set(.@Stone,callfunc("SC_StoneCheck",getcharid(0))) > 0 )
+	{ // Check if user got a Stone
+		initnpctimer;
+		set .Point,.@Stone;
+		set .Count, 0;
+		deltimer "Flavius_SC::OnFlash";
+
+		mapannounce "bg_sc",bg_get_data($@BG_Team1,2) + " Stone captured by [ " + strcharinfo(0) + " ]",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+		//bg_rankpoints "sc_captured",1;
+		pcblock 1,0; // UnBlock Skills/Items
+
+		setnpcdisplay strnpcinfo(3),bg_get_data($@BG_Team1,2) + " Stone",1905;
+		set getvariableofnpc(.Stone[.Point],"Flavius_SC"),0;
+	}
+	end;
+
+OnTimer2000:
+	initnpctimer;
+	getmapxy .@m$, .@x, .@y, BL_NPC;
+	viewpointmap "bg_sc",1, .@x, .@y, .Point, bg_info(bg_current_mode(), BG_INFO_COLOR);
+	specialeffect 223;
+	if( set(.Count, .Count + 1) >= 5 )
+	{
+		set .Count, 0;
+		donpcevent "Flavius_SC::OnTeam1Score";
+	}
+	end;
+
+OnBGStop:
+	stopnpctimer;
+	setnpcdisplay strnpcinfo(3),"Stone Point",1309;
+	set .Point, 0;
+	set .Count, 0;
+	end;
+}
+
+bg_sc,143,131,0	script	Stone Point::gsp2	1309,1,1,{
+	end;
+
+OnTouch:
+	if( $@BG_Status != 1 || bg_current_mode() != bg_info("bg_sc", BG_INFO_ID) || HP < 1 )
+		end;
+	if( .Point != 0 && getcharid(4) == $@BG_Team2 && callfunc("SC_StoneCheck",getcharid(0)) == 0 )
+	{ // Team 2 Stole
+		set getvariableofnpc(.Stone[.Point],"Flavius_SC"),getcharid(0);
+		setnpcdisplay strnpcinfo(3),"Stone Point",1309;
+
+		sc_end SC_HIDING;
+		sc_end SC_CLOAKING;
+		sc_end SC_CHASEWALK;
+		sc_end SC_CLOAKINGEXCEED;
+		sc_end SC_CAMOUFLAGE;
+		sc_end SC__INVISIBILITY;
+		pcblock 1,1; // Block Skills/Items
+
+		mapannounce "bg_sc",bg_get_data($@BG_Team1,2) + " Stone has been stole by [ " + strcharinfo(0) + " ]",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+		//bg_rankpoints "sc_stole",1;
+
+		addtimer 2000, "Flavius_SC::OnFlash";
+		set .Point,0;
+		stopnpctimer;
+	}
+	else if( .Point == 0 && getcharid(4) == $@BG_Team1 && set(.@Stone,callfunc("SC_StoneCheck",getcharid(0))) > 0 )
+	{ // Check if user got a Stone
+		initnpctimer;
+		set .Point,.@Stone;
+		set .Count, 0;
+		deltimer "Flavius_SC::OnFlash";
+
+		mapannounce "bg_sc",bg_get_data($@BG_Team1,2) + " Stone captured by [ " + strcharinfo(0) + " ]",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+		//bg_rankpoints "sc_captured",1;
+		pcblock 1,0; // UnBlock Skills/Items
+
+		setnpcdisplay strnpcinfo(3),bg_get_data($@BG_Team1,2) + " Stone",1905;
+		set getvariableofnpc(.Stone[.Point],"Flavius_SC"),0;
+	}
+	end;
+
+OnTimer2000:
+	initnpctimer;
+	getmapxy .@m$, .@x, .@y, BL_NPC;
+	viewpointmap "bg_sc",1, .@x, .@y, .Point, bg_info(bg_current_mode(), BG_INFO_COLOR);
+	specialeffect 223;
+	if( set(.Count, .Count + 1) >= 5 )
+	{
+		set .Count, 0;
+		donpcevent "Flavius_SC::OnTeam1Score";
+	}
+	end;
+
+OnBGStop:
+	stopnpctimer;
+	setnpcdisplay strnpcinfo(3),"Stone Point",1309;
+	set .Point, 0;
+	set .Count, 0;
+	end;
+}
+
+bg_sc,139,131,0	script	Stone Point::gsp3	1309,1,1,{
+	end;
+
+OnTouch:
+	if( $@BG_Status != 1 || bg_current_mode() != bg_info("bg_sc", BG_INFO_ID) || HP < 1 )
+		end;
+	if( .Point != 0 && getcharid(4) == $@BG_Team2 && callfunc("SC_StoneCheck",getcharid(0)) == 0 )
+	{ // Team 2 Stole
+		set getvariableofnpc(.Stone[.Point],"Flavius_SC"),getcharid(0);
+		setnpcdisplay strnpcinfo(3),"Stone Point",1309;
+
+		sc_end SC_HIDING;
+		sc_end SC_CLOAKING;
+		sc_end SC_CHASEWALK;
+		sc_end SC_CLOAKINGEXCEED;
+		sc_end SC_CAMOUFLAGE;
+		sc_end SC__INVISIBILITY;
+		pcblock 1,1; // Block Skills/Items
+
+		mapannounce "bg_sc",bg_get_data($@BG_Team1,2) + " Stone has been stole by [ " + strcharinfo(0) + " ]",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+		//bg_rankpoints "sc_stole",1;
+
+		addtimer 2000, "Flavius_SC::OnFlash";
+		set .Point,0;
+		stopnpctimer;
+	}
+	else if( .Point == 0 && getcharid(4) == $@BG_Team1 && set(.@Stone,callfunc("SC_StoneCheck",getcharid(0))) > 0 )
+	{ // Check if user got a Stone
+		initnpctimer;
+		set .Point,.@Stone;
+		set .Count, 0;
+		deltimer "Flavius_SC::OnFlash";
+
+		mapannounce "bg_sc",bg_get_data($@BG_Team1,2) + " Stone captured by [ " + strcharinfo(0) + " ]",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+		//bg_rankpoints "sc_captured",1;
+		pcblock 1,0; // UnBlock Skills/Items
+
+		setnpcdisplay strnpcinfo(3),bg_get_data($@BG_Team1,2) + " Stone",1905;
+		set getvariableofnpc(.Stone[.Point],"Flavius_SC"),0;
+	}
+	end;
+
+OnTimer2000:
+	initnpctimer;
+	getmapxy .@m$, .@x, .@y, BL_NPC;
+	viewpointmap "bg_sc",1, .@x, .@y, .Point, bg_info(bg_current_mode(), BG_INFO_COLOR);
+	specialeffect 223;
+	if( set(.Count, .Count + 1) >= 5 )
+	{
+		set .Count, 0;
+		donpcevent "Flavius_SC::OnTeam1Score";
+	}
+	end;
+
+OnBGStop:
+	stopnpctimer;
+	setnpcdisplay strnpcinfo(3),"Stone Point",1309;
+	set .Point, 0;
+	set .Count, 0;
+	end;
+}
+
+bg_sc,149,129,0	script	Stone Point::gsp4	1309,1,1,{
+	end;
+
+OnTouch:
+	if( $@BG_Status != 1 || bg_current_mode() != bg_info("bg_sc", BG_INFO_ID) || HP < 1 )
+		end;
+	if( .Point != 0 && getcharid(4) == $@BG_Team2 && callfunc("SC_StoneCheck",getcharid(0)) == 0 )
+	{ // Team 2 Stole
+		set getvariableofnpc(.Stone[.Point],"Flavius_SC"),getcharid(0);
+		setnpcdisplay strnpcinfo(3),"Stone Point",1309;
+
+		sc_end SC_HIDING;
+		sc_end SC_CLOAKING;
+		sc_end SC_CHASEWALK;
+		sc_end SC_CLOAKINGEXCEED;
+		sc_end SC_CAMOUFLAGE;
+		sc_end SC__INVISIBILITY;
+		pcblock 1,1; // Block Skills/Items
+
+		mapannounce "bg_sc",bg_get_data($@BG_Team1,2) + " Stone has been stole by [ " + strcharinfo(0) + " ]",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+		//bg_rankpoints "sc_stole",1;
+
+		addtimer 2000, "Flavius_SC::OnFlash";
+		set .Point,0;
+		stopnpctimer;
+	}
+	else if( .Point == 0 && getcharid(4) == $@BG_Team1 && set(.@Stone,callfunc("SC_StoneCheck",getcharid(0))) > 0 )
+	{ // Check if user got a Stone
+		initnpctimer;
+		set .Point,.@Stone;
+		set .Count, 0;
+		deltimer "Flavius_SC::OnFlash";
+
+		mapannounce "bg_sc",bg_get_data($@BG_Team1,2) + " Stone captured by [ " + strcharinfo(0) + " ]",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+		//bg_rankpoints "sc_captured",1;
+		pcblock 1,0; // UnBlock Skills/Items
+
+		setnpcdisplay strnpcinfo(3),bg_get_data($@BG_Team1,2) + " Stone",1905;
+		set getvariableofnpc(.Stone[.Point],"Flavius_SC"),0;
+	}
+	end;
+
+OnTimer2000:
+	initnpctimer;
+	getmapxy .@m$, .@x, .@y, BL_NPC;
+	viewpointmap "bg_sc",1, .@x, .@y, .Point, bg_info(bg_current_mode(), BG_INFO_COLOR);
+	specialeffect 223;
+	if( set(.Count, .Count + 1) >= 5 )
+	{
+		set .Count, 0;
+		donpcevent "Flavius_SC::OnTeam1Score";
+	}
+	end;
+
+OnBGStop:
+	stopnpctimer;
+	setnpcdisplay strnpcinfo(3),"Stone Point",1309;
+	set .Point, 0;
+	set .Count, 0;
+	end;
+}
+
+bg_sc,149,125,0	script	Stone Point::gsp5	1309,1,1,{
+	end;
+
+OnTouch:
+	if( $@BG_Status != 1 || bg_current_mode() != bg_info("bg_sc", BG_INFO_ID) || HP < 1 )
+		end;
+	if( .Point != 0 && getcharid(4) == $@BG_Team2 && callfunc("SC_StoneCheck",getcharid(0)) == 0 )
+	{ // Team 2 Stole
+		set getvariableofnpc(.Stone[.Point],"Flavius_SC"),getcharid(0);
+		setnpcdisplay strnpcinfo(3),"Stone Point",1309;
+
+		sc_end SC_HIDING;
+		sc_end SC_CLOAKING;
+		sc_end SC_CHASEWALK;
+		sc_end SC_CLOAKINGEXCEED;
+		sc_end SC_CAMOUFLAGE;
+		sc_end SC__INVISIBILITY;
+		pcblock 1,1; // Block Skills/Items
+
+		mapannounce "bg_sc",bg_get_data($@BG_Team1,2) + " Stone has been stole by [ " + strcharinfo(0) + " ]",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+		//bg_rankpoints "sc_stole",1;
+
+		addtimer 2000, "Flavius_SC::OnFlash";
+		set .Point,0;
+		stopnpctimer;
+	}
+	else if( .Point == 0 && getcharid(4) == $@BG_Team1 && set(.@Stone,callfunc("SC_StoneCheck",getcharid(0))) > 0 )
+	{ // Check if user got a Stone
+		initnpctimer;
+		set .Point,.@Stone;
+		set .Count, 0;
+		deltimer "Flavius_SC::OnFlash";
+
+		mapannounce "bg_sc",bg_get_data($@BG_Team1,2) + " Stone captured by [ " + strcharinfo(0) + " ]",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+		//bg_rankpoints "sc_captured",1;
+		pcblock 1,0; // UnBlock Skills/Items
+
+		setnpcdisplay strnpcinfo(3),bg_get_data($@BG_Team1,2) + " Stone",1905;
+		set getvariableofnpc(.Stone[.Point],"Flavius_SC"),0;
+	}
+	end;
+
+OnTimer2000:
+	initnpctimer;
+	getmapxy .@m$, .@x, .@y, BL_NPC;
+	viewpointmap "bg_sc",1, .@x, .@y, .Point, bg_info(bg_current_mode(), BG_INFO_COLOR);
+	specialeffect 223;
+	if( set(.Count, .Count + 1) >= 5 )
+	{
+		set .Count, 0;
+		donpcevent "Flavius_SC::OnTeam1Score";
+	}
+	end;
+
+OnBGStop:
+	stopnpctimer;
+	setnpcdisplay strnpcinfo(3),"Stone Point",1309;
+	set .Point, 0;
+	set .Count, 0;
+	end;
+}
+
+bg_sc,149,121,0	script	Stone Point::gsp6	1309,1,1,{
+	end;
+
+OnTouch:
+	if( $@BG_Status != 1 || bg_current_mode() != bg_info("bg_sc", BG_INFO_ID) || HP < 1 )
+		end;
+	if( .Point != 0 && getcharid(4) == $@BG_Team2 && callfunc("SC_StoneCheck",getcharid(0)) == 0 )
+	{ // Team 2 Stole
+		set getvariableofnpc(.Stone[.Point],"Flavius_SC"),getcharid(0);
+		setnpcdisplay strnpcinfo(3),"Stone Point",1309;
+
+		sc_end SC_HIDING;
+		sc_end SC_CLOAKING;
+		sc_end SC_CHASEWALK;
+		sc_end SC_CLOAKINGEXCEED;
+		sc_end SC_CAMOUFLAGE;
+		sc_end SC__INVISIBILITY;
+		pcblock 1,1; // Block Skills/Items
+
+		mapannounce "bg_sc",bg_get_data($@BG_Team1,2) + " Stone has been stole by [ " + strcharinfo(0) + " ]",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+		//bg_rankpoints "sc_stole",1;
+
+		addtimer 2000, "Flavius_SC::OnFlash";
+		set .Point,0;
+		stopnpctimer;
+	}
+	else if( .Point == 0 && getcharid(4) == $@BG_Team1 && set(.@Stone,callfunc("SC_StoneCheck",getcharid(0))) > 0 )
+	{ // Check if user got a Stone
+		initnpctimer;
+		set .Point,.@Stone;
+		set .Count, 0;
+		deltimer "Flavius_SC::OnFlash";
+
+		mapannounce "bg_sc",bg_get_data($@BG_Team1,2) + " Stone captured by [ " + strcharinfo(0) + " ]",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+		//bg_rankpoints "sc_captured",1;
+		pcblock 1,0; // UnBlock Skills/Items
+
+		setnpcdisplay strnpcinfo(3),bg_get_data($@BG_Team1,2) + " Stone",1905;
+		set getvariableofnpc(.Stone[.Point],"Flavius_SC"),0;
+	}
+	end;
+
+OnTimer2000:
+	initnpctimer;
+	getmapxy .@m$, .@x, .@y, BL_NPC;
+	viewpointmap "bg_sc",1, .@x, .@y, .Point, bg_info(bg_current_mode(), BG_INFO_COLOR);
+	specialeffect 223;
+	if( set(.Count, .Count + 1) >= 5 )
+	{
+		set .Count, 0;
+		donpcevent "Flavius_SC::OnTeam1Score";
+	}
+	end;
+
+OnBGStop:
+	stopnpctimer;
+	setnpcdisplay strnpcinfo(3),"Stone Point",1309;
+	set .Point, 0;
+	set .Count, 0;
+	end;
+}
+
+// Battleground Therapist
+// *********************************************************************
+bg_sc,172,129,5	script	Therapist in battle#sc1	95,{
+	mes "[Therapist in battle]";
+	mes "Just close your eyes, take a deep breath";
+	mes "and you will free yourself from the pain.";
+	specialeffect2 312;
+	percentheal 100,100;
+	repairall;
+	close2;
+	openstorage;
+	end;
+}
+
+bg_sc,28,65,5	script	Therapist in battle#sc2	95,{
+	mes "[Therapist in battle]";
+	mes "Just close your eyes, take a deep breath";
+	mes "and you will free yourself from the pain.";
+	specialeffect2 312;
+	percentheal 100,100;
+	repairall;
+	close2;
+	openstorage;
+	end;
+}
+
+// Battleground Respawn
+// *********************************************************************
+bg_sc,172,122,0	script	#guisc_respawn	139,{
+	end;
+
+OnBGStart:
+	initnpctimer;
+	end;
+
+OnBGStop:
+	stopnpctimer;
+	end;
+
+OnTimer24000:
+	misceffect 83;
+	end;
+
+OnTimer25000:
+	areapercentheal "bg_sc",166,118,177,129,100,100;
+	areawarp "bg_sc",166,118,177,129,"bg_sc",141,59;
+	initnpctimer;
+	end;
+}
+
+bg_sc,28,57,0	script	#crosc_respawn	139,{
+	end;
+
+OnBGStart:
+	initnpctimer;
+	end;
+
+OnBGStop:
+	stopnpctimer;
+	end;
+
+OnTimer24000:
+	misceffect 83;
+	end;
+
+OnTimer25000:
+	areapercentheal "bg_sc",22,54,33,65,100,100;
+	areawarp "bg_sc",22,54,33,65,"bg_sc",58,123;
+	initnpctimer;
+	end;
+}
+
+// Flags
+// *********************************************************************
+
+bg_sc,177,129,1	duplicate(Base Flag#bg)	Alpha Base#sc_1	973
+bg_sc,166,129,1	duplicate(Base Flag#bg)	Alpha Base#sc_2	973
+bg_sc,125,125,1	duplicate(Base Flag#bg)	Alpha Base#sc_3	973
+bg_sc,143,107,1	duplicate(Base Flag#bg)	Alpha Base#sc_4	973
+bg_sc,123,70,1	duplicate(Base Flag#bg)	Alpha Base#sc_5	973
+bg_sc,148,54,1	duplicate(Base Flag#bg)	Alpha Base#sc_6	973
+
+
+bg_sc,22,65,1	duplicate(Base Flag#bg)	Omega Base#sc_1	974
+bg_sc,33,65,1	duplicate(Base Flag#bg)	Omega Base#sc_2	974
+bg_sc,76,114,1	duplicate(Base Flag#bg)	Omega Base#sc_3	974
+bg_sc,56,76,1	duplicate(Base Flag#bg)	Omega Base#sc_4	974
+bg_sc,74,58,1	duplicate(Base Flag#bg)	Omega Base#sc_5	974
+bg_sc,51,130,1	duplicate(Base Flag#bg)	Omega Base#sc_6	974
+
+// MapFlags
+// *********************************************************************
+
+bg_sc	mapflag	battleground	2
+bg_sc	mapflag	nomemo
+bg_sc	mapflag	nosave	SavePoint
+bg_sc	mapflag	noteleport
+bg_sc	mapflag	nowarp
+bg_sc	mapflag	nowarpto
+bg_sc	mapflag	noreturn
+bg_sc	mapflag	nobranch
+bg_sc	mapflag	nopenalty
+//bg_sc	mapflag	noemergencycall
+bg_sc	mapflag	nodrop
diff --git a/npc/battleground-extended/7-bg_dom.txt b/npc/battleground-extended/7-bg_dom.txt
new file mode 100644
index 000000000..d767656bc
--- /dev/null
+++ b/npc/battleground-extended/7-bg_dom.txt
@@ -0,0 +1,543 @@
+// (c) 2008 - 2012 eAmod Project; Andres Garbanzo / Zephyrus
+//
+//  - gaiaro.staff@yahoo.com
+//  - MSN andresjgm.cr@hotmail.com
+//  - Skype: Zephyrus_cr
+//  - Site: http://dev.terra-gaming.com
+//
+// This file is NOT public - you are not allowed to distribute it.
+// Authorized Server List : http://dev.terra-gaming.com/index.php?/topic/72-authorized-eamod-servers/
+// eAmod is a non Free, extended version of eAthena Ragnarok Private Server.
+
+// ==============================================================================
+// BattleGround System - Tierra Domination
+// ==============================================================================
+
+// Battleground Engine
+// *********************************************************************
+
+-	script	Tierra_DOM	-1,{
+	end;
+
+OnTeamQuit:
+	bg_desert;
+	if( $@BG_Status != 0 && bg_current_mode() == bg_info("bg_dom", BG_INFO_ID) )
+		donpcevent "BG_Queue_Join::OnJoinEvent";
+	end;
+
+OnTeamDie:
+	// Check for Offensive or Defensive Kills
+	if( $@BG_Status != 1 || bg_current_mode() != bg_info("bg_dom", BG_INFO_ID) )
+		end;
+
+	if( !@killer_bg_id || @killer_bg_id == getcharid(4) )
+		end;
+
+	set .@Base, 0;
+	getmapxy .@m$, .@x, .@y, BL_PC;
+
+	if( .@x >= 126 && .@y >= 112 && .@x <= 149 && .@y <= 131 )
+		set .@Base, getvariableofnpc(.Owner,"Dom_N_Base"); // North
+	else if( .@x >= 86 && .@y >= 82 && .@x <= 113 && .@y <= 101 )
+		set .@Base, getvariableofnpc(.Owner,"Dom_C_Base"); // Center
+	else if( .@x >= 50 && .@y >= 52 && .@x <= 69 && .@y <= 69 )
+		set .@Base, getvariableofnpc(.Owner,"Dom_S_Base"); // South
+	else end; // Not Killed on Base territory
+
+	/*
+	if( .@Base == 1 )
+	{ // Team 1
+		if( getcharid(4) == $@BG_Team1 )
+			//bg_rankpoints "dom_off_kills",1,@killer_bg_src;
+		else
+			//bg_rankpoints "dom_def_kills",1,@killer_bg_src;
+	}
+	else if( .@Base == 2 )
+	{ // Team 2
+		if( getcharid(4) == $@BG_Team2 )
+			//bg_rankpoints "dom_off_kills",1,@killer_bg_src;
+		else
+			//bg_rankpoints "dom_def_kills",1,@killer_bg_src;
+	}*/
+	end;
+
+OnReady:
+	if( bg_current_mode() != bg_info("bg_dom", BG_INFO_ID) )
+		end;
+
+	set $@BG_Status, 1;
+	set .Team1_Score, 0;
+	set .Team2_Score, 0;
+	bg_updatescore "bg_dom",.Team1_Score,.Team2_Score;
+	donpcevent "Dom_N_Base::OnBase";
+	donpcevent "Dom_S_Base::OnBase";
+	donpcevent "Dom_C_Base::OnBase";
+	sleep 2000;
+	bg_warp $@BG_Team1,"bg_dom",142,59;
+	bg_warp $@BG_Team2,"bg_dom",57,123;
+	sleep 2000;
+	donpcevent "#guiDOM_respawn::OnBGStart";
+	donpcevent "#croDOM_respawn::OnBGStart";
+	end;
+
+OnBGTeam1Active:
+	warp "bg_dom",172,122;
+	donpcevent "BG_Queue_Join::OnJoinEvent";
+	end;
+
+OnBGTeam2Active:
+	warp "bg_dom",28,57;
+	donpcevent "BG_Queue_Join::OnJoinEvent";
+	end;
+	
+OnNScore:
+	if( set(.@North, getvariableofnpc(.Owner,"Dom_N_Base")) == 0 )
+		end; // No Owner
+
+	if( .@North == 1 )
+		set .Team1_Score, .Team1_Score + 1;
+	else
+		set .Team2_Score, .Team2_Score + 1;
+
+	donpcevent "Tierra_DOM::OnValidateScore";
+	end;
+
+OnSScore:
+	if( set(.@South, getvariableofnpc(.Owner,"Dom_S_Base")) == 0 )
+		end; // No Owner
+
+	if( .@South == 1 )
+		set .Team1_Score, .Team1_Score + 1;
+	else
+		set .Team2_Score, .Team2_Score + 1;
+
+	donpcevent "Tierra_DOM::OnValidateScore";
+	end;
+
+OnCScore:
+	if( set(.@Center, getvariableofnpc(.Owner,"Dom_C_Base")) == 0 )
+		end; // No Owner
+
+	if( .@Center == 1 )
+		set .Team1_Score, .Team1_Score + 1;
+	else
+		set .Team2_Score, .Team2_Score + 1;
+
+	donpcevent "Tierra_DOM::OnValidateScore";
+	end;
+
+OnValidateScore:
+	if( .Team1_Score > 35 )
+		set .Team1_Score, 35;
+	if( .Team2_Score > 35 )
+		set .Team2_Score, 35;
+
+	bg_updatescore "bg_dom",.Team1_Score,.Team2_Score; // Update Visual Score
+
+	if( .Team1_Score < 35 && .Team2_Score < 35 )
+		end; // No winners
+	
+OnPrematureEnd:
+	stopnpctimer "Dom_N_Base";
+	stopnpctimer "Dom_S_Base";
+	stopnpctimer "Dom_C_Base";
+	donpcevent "#guiDOM_respawn::OnBGStop";
+	donpcevent "#croDOM_respawn::OnBGStop";
+	set $@BG_Status, 2;
+	bg_reserve "bg_dom", true;
+	// =======================================================
+	// Team Rewards
+	// =======================================================
+	if( .Team1_Score >= 35 && .Team2_Score >= 35 )
+	{ // Tie
+		callfunc("Reward_BG","bg_dom", 0);
+		mapannounce "bg_dom","The battle is over. This is a Tie...!",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+	}
+	else if( .Team1_Score >= 35 )
+	{ // Team 1 Won
+		callfunc("Reward_BG","bg_dom", 1);
+		mapannounce "bg_dom","The " + bg_get_data($@BG_Team1,2) + " army has won the Battle of Tierra Domination!",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+	}
+	else if( .Team2_Score >= 35 )
+	{ // Team 2 Won
+		callfunc("Reward_BG","bg_dom", 2);
+		mapannounce "bg_dom","The " + bg_get_data($@BG_Team2,2) + " army has won the Battle of Tierra Domination!",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+	}
+	// =======================================================
+	set .Team1_Score, 0;
+	set .Team2_Score, 0;
+	sleep 5000;
+	bg_unbook "bg_dom";
+	donpcevent "BG_Queue_Join::OnRotate";
+	bg_updatescore "bg_dom",0,0;
+	end;
+}
+
+// Battleground Bases
+// *********************************************************************
+
+bg_dom,143,126,0	script	North Base::Dom_N_Base	1911,{
+	end;
+
+OnBase:
+	set .Owner, 0;
+	set .Balance, 0;
+	set .Tick, 0;
+	setnpcdisplay "Dom_N_Base","North Base",1911;
+	initnpctimer;
+	end;
+
+OnTimer1000:
+	stopnpctimer;
+	if( $@BG_Status != 1 || bg_current_mode() != bg_info("bg_dom", BG_INFO_ID) )
+		end;
+
+	set .@Team1Count, bg_getareausers($@BG_Team1,"bg_dom",138,120,149,131);
+	set .@Team2Count, bg_getareausers($@BG_Team2,"bg_dom",138,120,149,131);
+	set .Balance, .Balance + set(.@Balance, .@Team1Count - .@Team2Count);
+
+	if( .Balance < -50 )
+		set .Balance, -50;
+	else if( .Balance > 50 )
+		set .Balance, 50;
+
+	switch( .Owner )
+	{
+	case 0:
+		if( .Balance == 50 )
+		{
+			set .Balance, 50;
+			set .Owner, 1; // Team 1
+			setnpcdisplay "Dom_N_Base",bg_get_data($@BG_Team1,2) + " Base",1912;
+			mapannounce "bg_dom","North Base captured by " + bg_get_data($@BG_Team1,2),1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+			//bg_rankpoints_area $@BG_Team1,"bg_dom",126,112,149,131,"dom_bases",1;
+		}
+		else if( .Balance == -50 )
+		{
+			set .Balance, -50;
+			set .Owner, 2; // Team 2
+			setnpcdisplay "Dom_N_Base",bg_get_data($@BG_Team2,2) + " Base",1913;
+			mapannounce "bg_dom","North Base captured by " + bg_get_data($@BG_Team2,2),1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+			//bg_rankpoints_area $@BG_Team2,"bg_dom",126,112,149,131,"dom_bases",1;
+		}
+		break;
+	case 1:
+		if( .Balance <= 0 )
+		{ // Team 1 lost Control
+			set .Owner, 0;
+			setnpcdisplay "Dom_N_Base","North Base",1911;
+			mapannounce "bg_dom",bg_get_data($@BG_Team1,2) + " lost control of the North Base",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+		}
+		break;
+	case 2:
+		if( .Balance >= 0 )
+		{ // Team 2 lost Control
+			set .Owner, 0;
+			setnpcdisplay "Dom_N_Base","North Base",1911;
+			mapannounce "bg_dom",bg_get_data($@BG_Team2,2) + " lost control of the North Base",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+		}
+		break;
+	}
+
+	if( .@Balance > 0 )
+		specialeffect 236;
+	else if( .@Balance < 0 )
+		specialeffect 225;
+	else if( .Owner == 1 )
+		specialeffect 236;
+	else if( .Owner == 2 )
+		specialeffect 225;
+	else
+		specialeffect 223;
+
+	switch( .Owner )
+	{
+	case 0: viewpointmap "bg_dom",1,143,126,1,0xFFFFFF; break;
+	case 1: viewpointmap "bg_dom",1,143,126,1,bg_info(bg_current_mode(), BG_INFO_COLOR); break;
+	case 2: viewpointmap "bg_dom",1,143,126,1,bg_info(bg_current_mode(), BG_INFO_COLOR); break;
+	}
+
+	if( .Owner == 0 )
+		set .Tick, 0;
+	else if( set(.Tick, .Tick + 1) == 7 )
+	{
+		donpcevent "Tierra_DOM::OnNScore";
+		set .Tick, 0;
+	}
+
+	initnpctimer;
+	end;
+}
+
+bg_dom,100,91,0	script	Center Base::Dom_C_Base	1911,{
+	end;
+
+OnBase:
+	set .Owner, 0;
+	set .Balance, 0;
+	set .Tick, 0;
+	setnpcdisplay "Dom_C_Base","Center Base",1911;
+	initnpctimer;
+	end;
+
+OnTimer1000:
+	stopnpctimer;
+	if( $@BG_Status != 1 || bg_current_mode() != bg_info("bg_dom", BG_INFO_ID) )
+		end;
+
+	set .@Team1Count, bg_getareausers($@BG_Team1,"bg_dom",96,88,103,95);
+	set .@Team2Count, bg_getareausers($@BG_Team2,"bg_dom",96,88,103,95);
+	set .Balance, .Balance + set(.@Balance, .@Team1Count - .@Team2Count);
+
+	if( .Balance < -50 )
+		set .Balance, -50;
+	else if( .Balance > 50 )
+		set .Balance, 50;
+
+	switch( .Owner )
+	{
+	case 0:
+		if( .Balance == 50 )
+		{
+			set .Balance, 50;
+			set .Owner, 1; // Team 1
+			setnpcdisplay "Dom_C_Base",bg_get_data($@BG_Team1,2) + " Base",1912;
+			mapannounce "bg_dom","Center Base captured by " + bg_get_data($@BG_Team1,2),1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+			//bg_rankpoints_area $@BG_Team1,"bg_dom",86,82,113,101,"dom_bases",1;
+		}
+		else if( .Balance == -50 )
+		{
+			set .Balance, -50;
+			set .Owner, 2; // Team 2
+			setnpcdisplay "Dom_C_Base",bg_get_data($@BG_Team2,2) + " Base",1913;
+			mapannounce "bg_dom","Center Base captured by Croix Team",1,0xFF0000;
+			//bg_rankpoints_area $@BG_Team2,"bg_dom",86,82,113,101,"dom_bases",1;
+		}
+		break;
+	case 1:
+		if( .Balance <= 0 )
+		{ // Team 1 lost Control
+			set .Owner, 0;
+			setnpcdisplay "Dom_C_Base","Center Base",1911;
+			mapannounce "bg_dom",bg_get_data($@BG_Team1,2) + " lost control of the Center Base",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+		}
+		break;
+	case 2:
+		if( .Balance >= 0 )
+		{ // Team 2 lost Control
+			set .Owner, 0;
+			setnpcdisplay "Dom_C_Base","Center Base",1911;
+			mapannounce "bg_dom",bg_get_data($@BG_Team2,2) + " lost control of the Center Base",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+		}
+		break;
+	}
+
+	if( .@Balance > 0 )
+		specialeffect 236;
+	else if( .@Balance < 0 )
+		specialeffect 225;
+	else if( .Owner == 1 )
+		specialeffect 236;
+	else if( .Owner == 2 )
+		specialeffect 225;
+	else
+		specialeffect 223;
+
+	switch( .Owner )
+	{
+	case 0: viewpointmap "bg_dom",1,100,91,3,0xFFFFFF; break;
+	case 1: viewpointmap "bg_dom",1,100,91,3,bg_info(bg_current_mode(), BG_INFO_COLOR); break;
+	case 2: viewpointmap "bg_dom",1,100,91,3,bg_info(bg_current_mode(), BG_INFO_COLOR); break;
+	}
+
+	if( .Owner == 0 )
+		set .Tick, 0;
+	else if( set(.Tick, .Tick + 1) == 7 )
+	{
+		donpcevent "Tierra_DOM::OnCScore";
+		set .Tick, 0;
+	}
+
+	initnpctimer;
+	end;
+}
+
+bg_dom,55,58,0	script	South Base::Dom_S_Base	1911,{
+	end;
+
+OnBase:
+	set .Owner, 0;
+	set .Balance, 0;
+	set .Tick, 0;
+	setnpcdisplay "Dom_S_Base","South Base",1911;
+	initnpctimer;
+	end;
+
+OnTimer1000:
+	stopnpctimer;
+	if( $@BG_Status != 1 || bg_current_mode() != bg_info("bg_dom", BG_INFO_ID) )
+		end;
+
+	set .@Team1Count, bg_getareausers($@BG_Team1,"bg_dom",50,52,61,63);
+	set .@Team2Count, bg_getareausers($@BG_Team2,"bg_dom",50,52,61,63);
+	set .Balance, .Balance + set(.@Balance, .@Team1Count - .@Team2Count);
+
+	if( .Balance < -50 )
+		set .Balance, -50;
+	else if( .Balance > 50 )
+		set .Balance, 50;
+
+	switch( .Owner )
+	{
+	case 0:
+		if( .Balance == 50 )
+		{
+			set .Balance, 50;
+			set .Owner, 1; // Team 1
+			setnpcdisplay "Dom_S_Base",bg_get_data($@BG_Team1,2) + " Base",1912;
+			mapannounce "bg_dom","South Base captured by " + bg_get_data($@BG_Team1,2),1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+			//bg_rankpoints_area $@BG_Team1,"bg_dom",50,52,69,69,"dom_bases",1;
+		}
+		else if( .Balance == -50 )
+		{
+			set .Balance, -50;
+			set .Owner, 2; // Team 2
+			setnpcdisplay "Dom_S_Base",bg_get_data($@BG_Team2,2) + " Base",1913;
+			mapannounce "bg_dom","South Base captured by " + bg_get_data($@BG_Team2,2),1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+			//bg_rankpoints_area $@BG_Team2,"bg_dom",50,52,69,69,"dom_bases",1;
+		}
+		break;
+	case 1:
+		if( .Balance <= 0 )
+		{ // Team 1 lost Control
+			set .Owner, 0;
+			setnpcdisplay "Dom_S_Base","North Base",1911;
+			mapannounce "bg_dom",bg_get_data($@BG_Team1,2) + " lost control of the South Base",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+		}
+		break;
+	case 2:
+		if( .Balance >= 0 )
+		{ // Team 2 lost Control
+			set .Owner, 0;
+			setnpcdisplay "Dom_S_Base","North Base",1911;
+			mapannounce "bg_dom",bg_get_data($@BG_Team2,2) + " lost control of the South Base",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+		}
+		break;
+	}
+
+	if( .@Balance > 0 )
+		specialeffect 236;
+	else if( .@Balance < 0 )
+		specialeffect 225;
+	else if( .Owner == 1 )
+		specialeffect 236;
+	else if( .Owner == 2 )
+		specialeffect 225;
+	else
+		specialeffect 223;
+
+	switch( .Owner )
+	{
+	case 0: viewpointmap "bg_dom",1,55,58,2,0xFFFFFF; break;
+	case 1: viewpointmap "bg_dom",1,55,58,2,bg_info(bg_current_mode(), BG_INFO_COLOR); break;
+	case 2: viewpointmap "bg_dom",1,55,58,2,bg_info(bg_current_mode(), BG_INFO_COLOR); break;
+	}
+
+	if( .Owner == 0 )
+		set .Tick, 0;
+	else if( set(.Tick, .Tick + 1) == 7 )
+	{
+		donpcevent "Tierra_DOM::OnSScore";
+		set .Tick, 0;
+	}
+
+	initnpctimer;
+	end;
+}
+
+// Battleground Therapist
+// *********************************************************************
+bg_dom,172,128,5	script	Therapist in battle#DOM2	95,{
+	mes "[Therapist in battle]";
+	mes "Just close your eyes, take a deep breath";
+	mes "and you will free yourself from the pain.";
+	specialeffect2 312;
+	percentheal 100,100;
+	repairall;
+	close2;
+	openstorage;
+	end;
+}
+
+bg_dom,28,64,5	script	Therapist in battle#DOM1	95,{
+	mes "[Therapist in battle]";
+	mes "Just close your eyes, take a deep breath";
+	mes "and you will free yourself from the pain.";
+	specialeffect2 312;
+	percentheal 100,100;
+	repairall;
+	close2;
+	openstorage;
+	end;
+}
+
+// Battleground Respawn
+// *********************************************************************
+bg_dom,172,122,0	script	#guiDOM_respawn	139,{
+	end;
+
+OnBGStart:
+	initnpctimer;
+	end;
+
+OnBGStop:
+	stopnpctimer;
+	end;
+
+OnTimer24000:
+	misceffect 83;
+	end;
+
+OnTimer25000:
+	areapercentheal "bg_dom",166,118,177,129,100,100;
+	areawarp "bg_dom",166,118,177,129,"bg_dom",142,59;
+	initnpctimer;
+	end;
+}
+
+bg_dom,28,57,0	script	#croDOM_respawn	139,{
+	end;
+
+OnBGStart:
+	initnpctimer;
+	end;
+
+OnBGStop:
+	stopnpctimer;
+	end;
+
+OnTimer24000:
+	misceffect 83;
+	end;
+
+OnTimer25000:
+	areapercentheal "bg_dom",22,54,33,65,100,100;
+	areawarp "bg_dom",22,54,33,65,"bg_dom",57,123;
+	initnpctimer;
+	end;
+}
+
+// MapFlags
+// *********************************************************************
+
+bg_dom	mapflag	battleground	2
+bg_dom	mapflag	nomemo
+bg_dom	mapflag	nosave	SavePoint
+bg_dom	mapflag	noteleport
+bg_dom	mapflag	nowarp
+bg_dom	mapflag	nowarpto
+bg_dom	mapflag	noreturn
+bg_dom	mapflag	nobranch
+bg_dom	mapflag	nopenalty
+//bg_dom	mapflag	noemergencycall
+bg_dom	mapflag	nodrop
diff --git a/npc/battleground-extended/8-bg_rush.txt b/npc/battleground-extended/8-bg_rush.txt
new file mode 100644
index 000000000..38627a35c
--- /dev/null
+++ b/npc/battleground-extended/8-bg_rush.txt
@@ -0,0 +1,529 @@
+// (c) 2008 - 2012 eAmod Project; Andres Garbanzo / Zephyrus
+//
+//  - gaiaro.staff@yahoo.com
+//  - MSN andresjgm.cr@hotmail.com
+//  - Skype: Zephyrus_cr
+//  - Site: http://dev.terra-gaming.com
+//
+// This file is NOT public - you are not allowed to distribute it.
+// Authorized Server List : http://dev.terra-gaming.com/index.php?/topic/72-authorized-eamod-servers/
+// eAmod is a non Free, extended version of eAthena Ragnarok Private Server.
+
+// ==============================================================================
+// BattleGround System - Rush
+// ==============================================================================
+
+// Battleground Engine
+// *********************************************************************
+
+-	script	Rush	-1,{
+	end;
+
+OnInit:
+	setwall "bg_rush01",198,228,10,6,0,"Rush_wall_a";
+	setcell "bg_rush01",198,224,207,233,cell_basilica,1;
+	setwall "bg_rush02",142,48,10,6,0,"Rush_wall_b";
+	setcell "bg_rush02",142,44,151,53,cell_basilica,1;
+	setwall "bg_rush03",62,8,10,0,0,"Rush_wall_c";
+	setcell "bg_rush03",56,6,69,17,cell_basilica,1;
+	setwall "bg_rush04",266,290,10,6,0,"Rush_wall_d";
+	setcell "bg_rush04",266,286,275,295,cell_basilica,1;
+	// Select your castle, -1 to randomize. 0 is bg_rush01, etc..
+	set .Index,-1;
+	end;
+
+OnTeam1Quit:
+OnTeam2Quit:
+	bg_desert;
+	if( $@BG_Status != 0 && bg_current_mode() == bg_info(.Castle$, BG_INFO_ID) )
+		donpcevent "BG_Queue_Join::OnJoinEvent";
+	end;
+
+OnReady:
+	set .Castle$, bg_get_data($@BG_Team1, 4);
+	
+	if (.Castle$ == "bg_rush01") {
+		set .GX,202; set .GY,230; set .CX,202; set .CY,226;
+		set .Index, 0;
+	} else if (.Castle$ == "bg_rush02") {
+		set .GX,146; set .GY, 50; set .CX,146; set .CY, 46;
+		set .Index, 1;
+	} else if (.Castle$ == "bg_rush03") {
+		set .GX, 60; set .GY, 13; set .CX, 64; set .CY, 13;
+		set .Index, 2;
+	} else if (.Castle$ == "bg_rush04") {
+		set .GX,270; set .GY,292; set .CX,270; set .CY,288;
+		set .Index, 3;
+	} 
+	
+	if( bg_current_mode() != bg_info(.Castle$, BG_INFO_ID) )
+		end;
+
+	set $@BG_Status, 1;
+	initnpctimer;
+	initnpctimer "Rush_Respawn";
+	set .Team1_Score, 0;
+	set .Team2_Score, 0;
+	set .Defender, 0; // No Defender
+	// Emperium =====================
+	if (.Castle$ == "bg_rush01") {
+		bg_monster 0,.Castle$,158,174,"Emperium",1288,"Rush::OnEmperium";
+	} else if (.Castle$ == "bg_rush02") {
+		bg_monster 0,.Castle$,271,29,"Emperium",1288,"Rush::OnEmperium";
+	} else if (.Castle$ == "bg_rush03") {
+		bg_monster 0,.Castle$,28,102,"Emperium",1288,"Rush::OnEmperium";
+	} else if (.Castle$ == "bg_rush04") {
+		bg_monster 0,.Castle$,245,167,"Emperium",1288,"Rush::OnEmperium";
+	}
+	// ======================================
+	sleep 1000;
+	if (.Castle$ == "bg_rush01") {
+		bg_warp $@BG_Team1,.Castle$,43,229;
+		bg_warp $@BG_Team2,.Castle$,43,229;
+	} else if (.Castle$ == "bg_rush02") {
+		bg_warp $@BG_Team1,.Castle$,252,271;
+		bg_warp $@BG_Team2,.Castle$,252,271;
+	} else if (.Castle$ == "bg_rush03") {
+		bg_warp $@BG_Team1,.Castle$,216,103;
+		bg_warp $@BG_Team2,.Castle$,216,103;
+	} else if (.Castle$ == "bg_rush04") {
+		bg_warp $@BG_Team1,.Castle$,100,280;
+		bg_warp $@BG_Team2,.Castle$,100,280;
+	}
+	sleep 4000;
+	mapannounce .Castle$,"Move on warriors!! Let's capture this Castle!!",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+	end;
+
+OnBGTeamActive:
+	if (.Castle$ == "bg_rush01") {
+		warp .Castle$,43,229;
+	} else if (.Castle$ == "bg_rush02") {
+		warp .Castle$,252,271;
+	} else if (.Castle$ == "bg_rush03") {
+		warp .Castle$,216,103;
+	} else if (.Castle$ == "bg_rush04") {
+		warp .Castle$,100,280;
+	}
+	donpcevent "BG_Queue_Join::OnJoinEvent";
+	end;
+
+OnTimer60000:
+	mapannounce .Castle$,"Battle of Rush will ends in 6 minutes",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+	end;
+
+OnTimer360000:
+	mapannounce .Castle$,"Battle of Rush will ends in 1 minute",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+	end;
+
+OnEmperium:
+	if( $@BG_Status != 1 || bg_current_mode() != bg_info(.Castle$, BG_INFO_ID) )
+		end;
+
+	if( .Defender == 0 )
+	{ // First Capture
+		initnpctimer;
+		set .Defender,getcharid(4);
+		mapannounce .Castle$,bg_get_data(.Defender,3) + " : Castle captured, now prepare to Defend it!!",1,bg_get_data(.Defender,4);
+
+		if( .Defender == $@BG_Team1 )
+		{
+			set .Team1_Score,1;
+			set .Attacker,$@BG_Team2;
+		}
+		else
+		{
+			set .Team2_Score,1;
+			set .Attacker,$@BG_Team1;
+		}
+
+		bg_warp .Attacker,"SavePoint",0,0; // To Cementery and Wait
+		bg_updatescore .Castle$,.Team1_Score,.Team2_Score;
+
+		// Emperium =====================
+		switch( .Index )
+		{
+		case 0: // =========================================================================
+			bg_monster .Defender,.Castle$,158,174,"Emperium",1288,"Rush::OnEmperium";
+			break;
+		case 1: // =========================================================================
+			bg_monster .Defender,.Castle$,271,29,"Emperium",1288,"Rush::OnEmperium";
+			break;
+		case 2: // =========================================================================
+			bg_monster .Defender,.Castle$,28,102,"Emperium",1288,"Rush::OnEmperium";
+			break;
+		case 3: // =========================================================================
+			bg_monster .Defender,.Castle$,245,167,"Emperium",1288,"Rush::OnEmperium";
+			break;
+		}
+		// ======================================
+		initnpctimer "Rush_Respawn";
+
+		sleep 5000;
+		mapannounce .Castle$,bg_get_data(.Attacker,3) + " : Capture the Castle, it's our last chance to Win!!",1,bg_get_data(.Attacker,4);
+		end;
+	}
+
+	// Second Capture
+	mapannounce .Castle$,bg_get_data(.Attacker,3) + " : Castle captured, we won the Battle!!",1,bg_get_data(.Attacker,4);
+	if( .Defender == $@BG_Team1 )
+		set .Team2_Score,2;
+	else
+		set .Team1_Score,2;
+
+	donpcevent "Rush::OnMatchEnd";
+	end;
+
+OnTimer420000:
+OnPrematureEnd:
+	if( .Defender == 0 )
+		mapannounce .Castle$,"Castle captured Fail. No winners",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+	else
+	{
+		mapannounce .Castle$,bg_get_data(.Defender,3) + " : Castle protected, we won the Battle!!",1,bg_get_data(.Defender,4);
+		if( .Defender == $@BG_Team1 )
+			set .Team1_Score,3;
+		else
+			set .Team2_Score,3;
+	}
+
+	donpcevent "Rush::OnMatchEnd";
+	end;
+
+OnMatchEnd:
+	stopnpctimer;
+	stopnpctimer "Rush_Respawn";
+	killmonster .Castle$,"Rush::OnEmperium";
+	bg_updatescore .Castle$,.Team1_Score,.Team2_Score;
+	set $@BG_Status, 2;
+	bg_reserve .Castle$, true;
+	// =======================================================
+	// Team Rewards
+	// =======================================================
+	if( .Team1_Score > .Team2_Score )
+	{
+		callfunc("Reward_BG",.Castle$, 1);
+	}
+	else if( .Team2_Score > .Team1_Score )
+	{
+		callfunc("Reward_BG",.Castle$, 2);
+	}
+	else
+	{
+		callfunc("Reward_BG",.Castle$, 0);
+	}
+	// =======================================================
+	set .Team1_Score, 0;
+	set .Team2_Score, 0;
+	sleep 5000;
+	bg_unbook .Castle$;
+	donpcevent "BG_Queue_Join::OnRotate";
+	bg_updatescore .Castle$,.Team1_Score,.Team2_Score;
+	end;
+}
+
+// Battleground Respawn
+// *********************************************************************
+
+-	script	Rush_Respawn	-1,{
+	end;
+
+OnTimer25000:
+	set .@Castle$,getvariableofnpc(.Castle$,"Rush");
+	set .@Defender,getvariableofnpc(.Defender,"Rush");
+	.@announce_ok = 0;
+	switch( getvariableofnpc(.Index,"Rush") )
+	{
+	case 0: // bg_rush01 ========================================================================
+		areapercentheal .@Castle$,198,224,207,233,100,100;
+		if(getareausers(.@Castle$,198,229,207,233) > 0 || getareausers(.@Castle$,198,224,207,227) > 0)
+			.@announce_ok = 1;
+		if( .@Defender == 0 )
+			areawarp .@Castle$,198,224,207,233,.@Castle$,43,229;
+		else if( $@BG_Team1 == .@Defender )
+		{
+			areawarp .@Castle$,198,229,207,233,.@Castle$,71,36;
+			areawarp .@Castle$,198,224,207,227,.@Castle$,43,229;
+		}
+		else
+		{
+			areawarp .@Castle$,198,229,207,233,.@Castle$,43,229;
+			areawarp .@Castle$,198,224,207,227,.@Castle$,71,36;
+		}
+		break;
+	case 1: // bg_rush02 ========================================================================
+		areapercentheal .@Castle$,142,44,151,53,100,100;
+		if(getareausers(.@Castle$,142,49,151,53) > 0 || getareausers(.@Castle$,142,44,151,47) > 0)
+			.@announce_ok = 1;
+		if( .@Defender == 0 )
+			areawarp .@Castle$,142,44,151,53,.@Castle$,252,271;
+		else if( $@BG_Team1 == .@Defender )
+		{
+			areawarp .@Castle$,142,49,151,53,.@Castle$,40,235;
+			areawarp .@Castle$,142,44,151,47,.@Castle$,252,271;
+		}
+		else
+		{
+			areawarp .@Castle$,142,49,151,53,.@Castle$,252,271;
+			areawarp .@Castle$,142,44,151,47,.@Castle$,40,235;
+		}
+		break;
+	case 2: // bg_rush03 ========================================================================
+		areapercentheal .@Castle$,56,6,69,17,100,100;
+		if(getareausers(.@Castle$,56,6,61,17) > 0 || getareausers(.@Castle$,63,6,69,17) > 0)
+			.@announce_ok = 1;
+		if( .@Defender == 0 )
+			areawarp .@Castle$,56,6,69,17,.@Castle$,216,103;
+		else if( $@BG_Team1 == .@Defender )
+		{
+			areawarp .@Castle$,56,6,61,17,.@Castle$,31,190;
+			areawarp .@Castle$,63,6,69,17,.@Castle$,216,103;
+		}
+		else
+		{
+			areawarp .@Castle$,56,6,61,17,.@Castle$,216,103;
+			areawarp .@Castle$,63,6,69,17,.@Castle$,31,190;
+		}
+		break;
+	case 3: // bg_rush04 ========================================================================
+		areapercentheal .@Castle$,266,286,275,295,100,100;
+		if(getareausers(.@Castle$,266,291,275,295) > 0 || getareausers(.@Castle$,266,286,275,289) > 0)
+			.@announce_ok = 1;
+		if( .@Defender == 0 )
+			areawarp .@Castle$,266,286,275,295,.@Castle$,100,280;
+		else if( $@BG_Team1 == .@Defender )
+		{
+			areawarp .@Castle$,266,291,275,295,.@Castle$,116,89;
+			areawarp .@Castle$,266,286,275,289,.@Castle$,100,280;
+		}
+		else
+		{
+			areawarp .@Castle$,266,291,275,295,.@Castle$,100,280;
+			areawarp .@Castle$,266,286,275,289,.@Castle$,116,89;
+		}
+		break;
+	}
+	if(.@announce_ok)
+		mapannounce .@Castle$,"-- Reinforcements entering the Battle of Rush --",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
+	initnpctimer;
+	end;
+}
+
+// Battleground Therapist
+// *********************************************************************
+
+bg_rush01,199,233,6	script	Therapist in battle#rh1	95,{
+	mes "[Therapist in battle]";
+	mes "Just close your eyes, take a deep breath";
+	mes "and you will free yourself from the pain.";
+	specialeffect2 312;
+	percentheal 100,100;
+	repairall;
+	close2;
+	openstorage;
+	end;
+}
+
+bg_rush01,199,224,6	script	Therapist in battle#rh2	95,{
+	mes "[Therapist in battle]";
+	mes "Just close your eyes, take a deep breath";
+	mes "and you will free yourself from the pain.";
+	specialeffect2 312;
+	percentheal 100,100;
+	repairall;
+	close2;
+	openstorage;
+	end;
+}
+
+bg_rush02,145,52,4	script	Therapist in battle#rh3	95,{
+	mes "[Therapist in battle]";
+	mes "Just close your eyes, take a deep breath";
+	mes "and you will free yourself from the pain.";
+	specialeffect2 312;
+	percentheal 100,100;
+	repairall;
+	close2;
+	openstorage;
+	end;
+}
+
+bg_rush02,145,44,6	script	Therapist in battle#rh4	95,{
+	mes "[Therapist in battle]";
+	mes "Just close your eyes, take a deep breath";
+	mes "and you will free yourself from the pain.";
+	specialeffect2 312;
+	percentheal 100,100;
+	repairall;
+	close2;
+	openstorage;
+	end;
+}
+
+bg_rush03,58,15,4	script	Therapist in battle#rh5	95,{
+	mes "[Therapist in battle]";
+	mes "Just close your eyes, take a deep breath";
+	mes "and you will free yourself from the pain.";
+	specialeffect2 312;
+	percentheal 100,100;
+	repairall;
+	close2;
+	openstorage;
+	end;
+}
+
+bg_rush03,67,15,4	script	Therapist in battle#rh6	95,{
+	mes "[Therapist in battle]";
+	mes "Just close your eyes, take a deep breath";
+	mes "and you will free yourself from the pain.";
+	specialeffect2 312;
+	percentheal 100,100;
+	repairall;
+	close2;
+	openstorage;
+	end;
+}
+
+bg_rush04,269,294,6	script	Therapist in battle#rh7	95,{
+	mes "[Therapist in battle]";
+	mes "Just close your eyes, take a deep breath";
+	mes "and you will free yourself from the pain.";
+	specialeffect2 312;
+	percentheal 100,100;
+	repairall;
+	close2;
+	openstorage;
+	end;
+}
+
+bg_rush04,269,286,6	script	Therapist in battle#rh8	95,{
+	mes "[Therapist in battle]";
+	mes "Just close your eyes, take a deep breath";
+	mes "and you will free yourself from the pain.";
+	specialeffect2 312;
+	percentheal 100,100;
+	repairall;
+	close2;
+	openstorage;
+	end;
+}
+
+// Warp Portals
+// *********************************************************************
+
+bg_rush01,157,135,0	warp	rush106-1	1,1,bg_rush01,184,40
+bg_rush01,161,41,0	warp	rush102-1	1,1,bg_rush01,57,202
+bg_rush01,184,44,0	warp	rush106	1,1,bg_rush01,157,140
+bg_rush01,203,21,0	warp	rush105-1	1,1,bg_rush01,45,25
+bg_rush01,210,41,0	warp	rush101-1	1,1,bg_rush01,84,215
+bg_rush01,35,183,0	warp	rush104	1,1,bg_rush01,71,82
+bg_rush01,45,21,0	warp	rush105	1,1,bg_rush01,203,25
+bg_rush01,53,202,0	warp	rush102	1,1,bg_rush01,165,41
+bg_rush01,64,164,0	warp	rush103	1,1,bg_rush01,98,25
+bg_rush01,71,86,0	warp	rush104-1	1,1,bg_rush01,35,187
+bg_rush01,88,215,0	warp	rush101	1,1,bg_rush01,206,41
+bg_rush01,98,21,0	warp	rush103-1	1,1,bg_rush01,64,168
+
+bg_rush02,259,212,0	warp	rush201	1,1,bg_rush02,72,240
+bg_rush02,75,240,0	warp	rush201-1	1,5,bg_rush02,256,212
+bg_rush02,232,189,0	warp	rush202	1,1,bg_rush02,74,261
+bg_rush02,78,261,0	warp	rush202-1	1,1,bg_rush02,236,189
+bg_rush02,229,208,0	warp	rush203	1,1,bg_rush02,70,282
+bg_rush02,74,282,0	warp	rush203-1	1,1,bg_rush02,225,208
+bg_rush02,7,261,0	warp	rush204	1,1,bg_rush02,55,30
+bg_rush02,59,30,0	warp	rush204-1	1,1,bg_rush02,11,261
+bg_rush02,28,31,0	warp	rush205	1,1,bg_rush02,251,42
+bg_rush02,254,45,0	warp	rush205-1	1,1,bg_rush02,24,31
+
+bg_rush03,194,71,0	warp	rush301	1,1,bg_rush03,129,194
+bg_rush03,125,194,0	warp	rush301-1	1,1,bg_rush03,199,70
+bg_rush03,164,86,0	warp	rush302	1,1,bg_rush03,66,189
+bg_rush03,70,189,0	warp	rush302-1	1,1,bg_rush03,166,81
+bg_rush03,150,67,0	warp	rush303	1,1,bg_rush03,9,187
+bg_rush03,5,187,0	warp	rush303-1	1,1,bg_rush03,151,62
+bg_rush03,165,232,0	warp	rush304	1,1,bg_rush03,193,49
+bg_rush03,188,49,0	warp	rush304-1	1,1,bg_rush03,165,228
+bg_rush03,195,42,0	warp	rush305	1,1,bg_rush03,19,227
+bg_rush03,15,227,0	warp	rush305-1	1,1,bg_rush03,195,46
+bg_rush03,13,175,0	warp	rush306	1,1,bg_rush03,162,194
+bg_rush03,166,194,0	warp	rush306-1	1,1,bg_rush03,13,179
+bg_rush03,156,231,0	warp	rush307	1,1,bg_rush03,18,88
+bg_rush03,14,88,0	warp	rush307-1	1,1,bg_rush03,156,227
+
+bg_rush04,106,217,0	warp	rush407	1,1,bg_rush04,131,15
+bg_rush04,115,210,0	warp	rush408	1,1,bg_rush04,92,215
+bg_rush04,135,15,0	warp	rush407-1	1,1,bg_rush04,110,217
+bg_rush04,135,92,0	warp	rush402-1	1,1,bg_rush04,34,282
+bg_rush04,152,92,0	warp	rush404-1	1,1,bg_rush04,59,255
+bg_rush04,154,16,0	warp	rush414	1,1,bg_rush04,252,11
+bg_rush04,17,206,0	warp	rush406-1	1,1,bg_rush04,29,219
+bg_rush04,212,46,0	warp	rush415	1,1,bg_rush04,225,158
+bg_rush04,225,154,0	warp	rush415-1	1,1,bg_rush04,212,42
+bg_rush04,237,74,0	warp	rush412-1	1,1,bg_rush04,62,213
+bg_rush04,256,11,0	warp	rush414-1	1,1,bg_rush04,159,16
+bg_rush04,266,47,0	warp	rush409-1	1,1,bg_rush04,45,175
+bg_rush04,27,215,0	warp	rush406-2	1,1,bg_rush04,17,202
+bg_rush04,34,286,0	warp	rush402	1,1,bg_rush04,131,92
+bg_rush04,38,243,0	warp	rush406	1,1,bg_rush04,29,219
+bg_rush04,38,259,0	warp	rush403-1	1,1,bg_rush04,43,271
+bg_rush04,42,175,0	warp	rush409	1,1,bg_rush04,266,43
+bg_rush04,43,191,0	warp	rush410-1	1,1,bg_rush04,70,185
+bg_rush04,47,271,0	warp	rush403	1,1,bg_rush04,38,255
+bg_rush04,50,248,0	warp	rush405	1,1,bg_rush04,54,229
+bg_rush04,58,232,0	warp	rush405-1	1,1,bg_rush04,62,213
+bg_rush04,63,255,0	warp	rush404	1,1,bg_rush04,156,92
+bg_rush04,65,215,0	warp	rush412	1,1,bg_rush04,233,74
+bg_rush04,66,223,0	warp	rush401	1,1,bg_rush04,96,53
+bg_rush04,70,182,0	warp	rush410	1,1,bg_rush04,39,191
+bg_rush04,79,244,0	warp	rush413-1	1,1,bg_rush04,91,250
+bg_rush04,88,248,0	warp	rush411-1	1,1,bg_rush04,76,242
+bg_rush04,90,218,0	warp	rush408-1	1,1,bg_rush04,111,210
+bg_rush04,92,53,0	warp	rush401-1	1,1,bg_rush04,62,223
+bg_rush04,93,209,0	warp	rush411	1,1,bg_rush04,92,250
+bg_rush04,95,251,0	warp	rush413	1,1,bg_rush04,91,209
+
+// MapFlags
+// *********************************************************************
+
+bg_rush01	mapflag	battleground	2
+bg_rush01	mapflag	nomemo
+bg_rush01	mapflag	nosave	SavePoint
+bg_rush01	mapflag	noteleport
+bg_rush01	mapflag	nowarp
+bg_rush01	mapflag	nowarpto
+bg_rush01	mapflag	noreturn
+bg_rush01	mapflag	nobranch
+bg_rush01	mapflag	nopenalty
+bg_rush01	mapflag	nodrop
+
+bg_rush02	mapflag	battleground	2
+bg_rush02	mapflag	nomemo
+bg_rush02	mapflag	nosave	SavePoint
+bg_rush02	mapflag	noteleport
+bg_rush02	mapflag	nowarp
+bg_rush02	mapflag	nowarpto
+bg_rush02	mapflag	noreturn
+bg_rush02	mapflag	nobranch
+bg_rush02	mapflag	nopenalty
+bg_rush02	mapflag	nodrop
+
+bg_rush03	mapflag	battleground	2
+bg_rush03	mapflag	nomemo
+bg_rush03	mapflag	nosave	SavePoint
+bg_rush03	mapflag	noteleport
+bg_rush03	mapflag	nowarp
+bg_rush03	mapflag	nowarpto
+bg_rush03	mapflag	noreturn
+bg_rush03	mapflag	nobranch
+bg_rush03	mapflag	nopenalty
+bg_rush03	mapflag	nodrop
+
+bg_rush04	mapflag	battleground	2
+bg_rush04	mapflag	nomemo
+bg_rush04	mapflag	nosave	SavePoint
+bg_rush04	mapflag	noteleport
+bg_rush04	mapflag	nowarp
+bg_rush04	mapflag	nowarpto
+bg_rush04	mapflag	noreturn
+bg_rush04	mapflag	nobranch
+bg_rush04	mapflag	nopenalty
+bg_rush04	mapflag	nodrop
diff --git a/npc/battleground-extended/bg_common.txt b/npc/battleground-extended/bg_common.txt
new file mode 100644
index 000000000..4796f8499
--- /dev/null
+++ b/npc/battleground-extended/bg_common.txt
@@ -0,0 +1,524 @@
+// ==============================================================================
+// = BY VYKIMO
+// ==============================================================================
+// BattleGround Extended System - Core NPCs
+// ==============================================================================
+// NEW! 
+// BG UI supported
+// *********************************************************************
+// ==============================================================================
+//  Mapflags
+bat_room	mapflag	nomemo
+bat_room	mapflag	nowarpto
+bat_room	mapflag	nowarp
+bat_room	mapflag	nobranch
+bat_room	mapflag	nopenalty
+bat_room	mapflag	noteleport
+bat_room	mapflag	nosave	SavePoint
+bat_room	mapflag	town
+
+// Fonction reward
+// Reward_BG(Equipe1,Equipe2)
+function	script	Reward_BG	{
+	
+	// Premature end
+	if($@PrematureEnd && !$PREMATURE_REWARDS)
+		return;
+	
+	if(getargcount() >= 2) {
+	
+		.@bgmap$ = getarg(0);
+		.@result = getarg(1);
+
+		// Add reward if option is set
+		.@add_to_reward = $REWARDS_VARIATIONS ? (bg_get_data($@BG_Team1,0) + bg_get_data($@BG_Team2,0))/2 : 0;
+	
+		.@add_to_reward += getarg(2,0);
+		
+		// Reward both teams
+		bg_reward_all(.@bgmap$,$@BG_Team1,$@BG_Team2,$BGREWARD_ITID,.@add_to_reward,.@result);	
+		
+	}
+	return;
+}
+
+// Battleground Queue Admin
+// *********************************************************************
+bat_room,0,0,0	script	BG_Queue_Join	-1,{
+	end;
+	
+	
+// ================================== BattleGround Hour ======================================
+// Uncomment to have Scheduled Battleground :
+/*
+OnReloadMapServer:
+	if(!agitcheck3() && !agitcheck2() && !agitcheck())
+		end;
+		
+OnMon1800:
+OnMon1900:
+OnTue2100:
+OnTue2200:
+OnThu1900:
+OnThu2000:
+OnFri2000:
+OnFri2100:
+OnSat1800:
+OnSat1900:
+	switch( gettime(DT_DAYOFWEEK) ) {
+		case MONDAY:
+		case SATURDAY:
+			if( gettime(DT_HOUR) >= 18 && gettime(DT_HOUR) < 19 && !bgcheck() ) bgstart();
+			if( gettime(DT_HOUR) == 19 && bgcheck() ) bgend;
+			break;
+		case TUESDAY:
+			if( gettime(DT_HOUR) >= 21 && gettime(DT_HOUR) < 22 && !bgcheck()  ) bgstart();
+			if( gettime(DT_HOUR) == 22 && bgcheck() ) bgend;
+			break;
+		case THURSDAY:
+			if( gettime(DT_HOUR) >= 19 && gettime(DT_HOUR) < 20 && !bgcheck()  ) bgstart();
+			if( gettime(DT_HOUR) == 20 && bgcheck() ) bgend;
+			break;
+		case FRIDAY:
+			if( gettime(DT_HOUR) >= 20 && gettime(DT_HOUR) < 21 && !bgcheck()  ) bgstart();
+			if( gettime(DT_HOUR) == 21 && bgcheck() ) bgend;
+			break;
+	}
+	end;
+*/
+// OR
+// 24H/24 Battleground
+// Uncomment to have 24/24 BG :
+
+OnReloadMapServer:
+	if(!agitcheck3() && !agitcheck2() && !agitcheck() && !bgcheck())
+		bgstart();
+		
+	end;
+
+// ================================== BattleGround Happy Hour ===================================
+// BattleGround Happy Hour
+OnDoHappyHour:
+OnClock1600:
+OnClock1800:
+OnClock2000:
+OnClock2200:
+	switch( gettime(DT_DAYOFWEEK) )
+	{
+	case MONDAY:
+	case WEDNESDAY:
+	case FRIDAY:
+		if( gettime(DT_HOUR) >= 20 && gettime(DT_HOUR) < 22 )
+		{
+			bgannounce "-- Battleground Happy Hour has begun --",0x00FF00;
+			setbattleflag "bg_reward_rates",120; // +20% Reward Rates
+			end;
+		}
+		
+		if( gettime(DT_HOUR) == 22 )
+		{
+			bgannounce "-- Battleground Happy Hour is over --",0x00BFFF;
+			setbattleflag "bg_reward_rates",100; // Normal Rates
+			end;
+		}
+		break;
+	case TUESDAY:
+	case THURSDAY:
+	case SATURDAY:
+		if( gettime(DT_HOUR) >= 16 && gettime(DT_HOUR) < 18 )
+		{
+			bgannounce "-- Battleground Happy Hour has begun --",0x00FF00;
+			setbattleflag "bg_reward_rates",120; // +20% Reward Rates
+			end;
+		}
+		
+		if( gettime(DT_HOUR) == 18 )
+		{
+			bgannounce "-- Battleground Happy Hour is over --",0x00BFFF;
+			setbattleflag "bg_reward_rates",100; // Normal Rates
+			end;
+		}
+		break;
+	}
+	end;
+
+
+// ======================================== OnEvents ========================================
+OnAgitStart:
+	if(bgcheck())
+		bgend();
+	end;
+	
+// 1 minute waiting after woe end
+OnAgitEnd:
+	sleep 60000;
+	donpcevent "BG_Queue_Join::OnReloadMapServer";
+	end;
+
+OnBGGlobalStart:
+	bgannounce "==== The Battleground is starting ==== You can join using the Battleground Button.",0xBFFF00;
+	sleep 1000;
+	// On lance la rotation
+	donpcevent "BG_Queue_Join::OnRotate";
+	end;
+	
+OnBGEnd:
+	bgannounce "==== The Battleground just ended. ====",0xBFFF00;
+	// On stoppe la rotation
+	stopnpctimer;
+	end;
+// ======================================== Commands ========================================
+// @joinbg
+OnDoJoin:	
+	if($@BG_Status == 2) {
+		dispbottom "Please retry in few seconds, just wait for the end of the current mode.";
+	} else {
+		if(bgcheck()) {
+			dispbottom .@atcmd_command$+" trying to join the queue. @leavebg to quit the queue.";
+			bg_joinbg(.BG_Names$[.@BG_Index]);
+		} else {
+			dispbottom .@atcmd_command$+" failed. Command available when the battleground is on.";
+		}
+	}
+end;
+
+// @leavebg
+OnDoLeave: 
+	if(bgcheck()) {
+		dispbottom "@leavebg trying to quit the queue.";
+		bg_leavebg(.BG_Names$[.@BG_Index]);
+	} else 
+		dispbottom "@leavebg failed. Command available when the battleground is on.";
+	end;
+
+// ======================================== CONFIG ========================================
+OnInit:
+	// Configuration
+	// *****************************************************
+	// Rewards when premature end (0 players in one team) ?
+	$PREMATURE_REWARDS = 1;
+	// Rewards variation depending on number of users
+	$REWARDS_VARIATIONS = 0;
+	// Reward item id
+	// 7804 : Battleground Badges
+	// 7773 : War Badges
+	// 7829 : Valor Badges
+	// 7828 : Bravery Badges
+	$BGREWARD_ITID = 7804;
+	// ================================================
+	// Min level to enter BG lobby
+	$@BG_MinLevel = 80;
+	// *****************************************************
+	// Battleground Modes
+	$@BG_Count = bg_info("bg_ctf", BG_TOTAL_ARENA);
+	// Main Code
+	// *****************************************************
+	bindatcmd "leavebg", strnpcinfo(3)+"::OnDoLeave";
+	bindatcmd "joinbg", strnpcinfo(3)+"::OnDoJoin";
+	bindatcmd "rotatebg", strnpcinfo(3)+"::OnRotate", 99;
+	donpcevent "BG_Queue_Join::OnDoHappyHour";
+	bgend();
+	// Warps Teams
+	if( $@BG_Team1 ) { bg_warp $@BG_Team1,"bat_room",155,150; bg_destroy $@BG_Team1; set $@BG_Team1, 0; }
+	if( $@BG_Team2 ) { bg_warp $@BG_Team2,"bat_room",155,150; bg_destroy $@BG_Team2; set $@BG_Team2, 0; }
+	donpcevent "BG_Queue_Join::OnReloadMapServer";
+	.Mode_Precedent = -1;		
+	end;
+
+OnRotate:
+	set $@BG_Status, 0;	
+	// Warps Teams
+	if( $@BG_Team1 ) { bg_destroy $@BG_Team1; set $@BG_Team1, 0; }
+	if( $@BG_Team2 ) { bg_destroy $@BG_Team2; set $@BG_Team2, 0; }
+	
+OnTimer180000:
+	stopnpctimer;
+	$@PrematureEnd = 0;
+	
+	if( $@BG_Status > 0 )
+		end;
+	
+	.@BG_Index = bg_current_mode();
+	if(bg_modeselection() == 2)
+		.Mode_Precedent = .@BG_Index;
+	else if(bg_modeselection() == 1) {
+		// End script if bg ended
+		if(!bgcheck())	end;
+		
+		set .@Old_BG_Index, .@BG_Index;
+		
+		// Move to Next Arena
+		if( set(.@BG_Index,.@BG_Index + 1) > $@BG_Count )
+			set .@BG_Index,1; // Restart Rotation
+
+		if(.@BG_Index == $@PB_BG_Index && !$PB_AVAILABLE) {
+			if($TD_AVAILABLE)
+				.@BG_Index = $@TD_BG_Index;
+			else 
+				.@BG_Index = 1;
+			
+		} else if(.@BG_Index == $@TD_BG_Index && !$TD_AVAILABLE)
+			.@BG_Index = 1;
+		
+		bg_set_current_mode(.@BG_Index);
+
+		if (.@Old_BG_Index > 0) {
+			bg_move_queue(bg_info(.@Old_BG_Index, BG_INFO_NAME), bg_info(.@BG_Index, BG_INFO_NAME));
+		}
+
+		initnpctimer; // Rotation start
+	}
+	
+	set .@msg$, "[ Battleground ] ~ " + bg_info(bg_current_mode(), BG_INFO_NAME) + " -- Ready to accept new challengers -- @joinbg to join the battle.";
+	bgannounce .@msg$,0x00FFFF;
+	end;
+	
+// Everytime someone joins/leaves, verify number of players
+OnJoinEvent:	
+	set .@BG_Count1, bg_get_data($@BG_Team1,0);
+	set .@BG_Count2, bg_get_data($@BG_Team2,0);
+	
+	if(.@BG_Count1 <= 0 || .@BG_Count2 <= 0) {	
+		$@PrematureEnd = 1;	
+		set .@msg$, "[ Battleground ] - No more enough players. " + bg_info(bg_current_mode(), BG_INFO_NAME) + " will end soon.";
+		bgannounce .@msg$,0xBFFF00;
+		bg_premature_end(bg_current_mode());		
+	} else {
+		set .@msg$, "[ Battleground ] - " + bg_info(bg_current_mode(), BG_INFO_NAME) + " -- B: " + .@BG_Count1 + "/" + bg_info(bg_current_mode(), BG_INFO_MAX_PLAYERS) + ", R: " + .@BG_Count2 + "/" + bg_info(bg_current_mode(), BG_INFO_MAX_PLAYERS) + " (Playing)";
+		bgannounce .@msg$,0xBFFF00;
+	}	
+	end;
+}
+// Registration NPC
+// *********************************************************************
+bat_room,153,157,4	script	Battle Recruiter::BG_Register	10127,{
+	mes "[^1AAF9B Battle Recruiter ^000000]";
+	mes "This is the Battleground Information and Registration service.";
+	mes "What do you want to do?";
+	next;
+	switch( select("^FF0000Full round Badges^000000:^FFA500Battleground's Modes^000000:Quit") )
+	{
+	case 3: close;
+	case 1:
+		mes "[^1AAF9B Battle Recruiter ^000000]";
+		mes "You can exchange your BG partipation points, a full round of each won BG, for a random number of ^FF0000"+ getitemname($BGREWARD_ITID) +"^000000.";
+		mes "Let me check your points...";
+		next;
+		.@ok = 0;
+		for(.@i=1;.@i<=$@BG_Count;.@i++) {
+			mes bg_info(.@i, BG_INFO_NAME)+" : ^0000FF" + getd(bg_info(.@i, BG_INFO_VARIABLE)) + "^000000";
+			if( getd(bg_info(.@i, BG_INFO_VARIABLE)) > 0) .@ok++;
+		}
+		next;
+		if( .@ok == $@BG_Count)
+		{
+			specialeffect 618;
+			
+			for(.@i=1;.@i<=$@BG_Count;.@i++)
+				set getd(bg_info(.@i, BG_INFO_VARIABLE)),getd(bg_info(.@i, BG_INFO_VARIABLE))-1;
+
+			getitem $BGREWARD_ITID,rand(40,60);
+			mes "[^1AAF9B Battle Recruiter ^000000]";
+			mes "Here are Badges for you!!";
+			mes "I hope you can find inside it a big surprise.";
+			mes "Talk to me if you want to exchange more.";
+		}
+		else
+		{
+			mes "[^1AAF9B Battle Recruiter ^000000]";
+			mes "To exchange your points, you need at least one of each Battleground.";
+			mes "Play all kinds of BG's!";
+		}
+		close;
+	case 2:
+		mes "[^1AAF9B Battle Recruiter ^000000]";
+		mes "Battlegrounds Arena are different kinds of games where Teams fight for victory.";
+		mes "What do you want to do?";
+		next;
+		switch( select("About the Battleground") )
+		{
+		case 1:
+			mes "[^1AAF9B Battle Recruiter ^000000]";
+			mes "Tell me... what battleground you don't understand?";
+			next;
+			switch( select("Capture the Flag:Team DeathMatch:Stone Control:Eye of Storm:Domination:Conquest:Rush:KvM" ) )
+			{
+			case 1:
+				mes "[^FFA500Battle Recruiter^000000]";
+				mes "The objective of the Flavius Battle CTF is to score 3 points before your enemy, by capture their Flag.";
+				next;
+				mes "[^FFA500Battle Recruiter^000000]";
+				mes "To capture a Flag you need to take the enemy flag, and bring it to your base flag.";
+				next;
+				mes "[^FFA500Battle Recruiter^000000]";
+				mes "If your base flag is captured too, you need to kill the flag carrier and take the flag back to your base.";
+				break;
+			case 2:
+				mes "[^FFA500Battle Recruiter^000000]";
+				mes "Kill all the enemy players to let their Team without points.";
+				mes "Protect our army.";
+				break;
+			case 3:
+				mes "[^FFA500Battle Recruiter^000000]";
+				mes "Take the Stones in the middle of the battlefield and put in on your base, in the Stone Points.";
+				next;
+				mes "[^FFA500Battle Recruiter^000000]";
+				mes "Each Stone will give points to your team. First team reach 99 points wins the game.";
+				next;
+				mes "[^FFA500Battle Recruiter^000000]";
+				mes "Protect your stones from to be captured by the enemy.";
+				break;
+			case 4:
+				mes "[^FFA500Battle Recruiter^000000]";
+				mes "There are two bases, North and South which teams can capture by holding position on the Base more than the other team.";
+				next;
+				mes "[^FFA500Battle Recruiter^000000]";
+				mes "Each base will give you points each 5 seconds of Domination. If your Team control both bases the amount of points increases.";
+				next;
+				mes "[^FFA500Battle Recruiter^000000]";
+				mes "To get aditional points, in the middle there is a Flag spawn, capture it and put it on any of your team Bases.";
+				next;
+				mes "[^FFA500Battle Recruiter^000000]";
+				mes "The first Team reach 99 points wins the match.";
+				break;
+			case 5:
+				mes "[^FFA500Battle Recruiter^000000]";
+				mes "There are three bases, North, Center and South which teams can capture by holding position on the Base more than the other team.";
+				next;
+				mes "[^FFA500Battle Recruiter^000000]";
+				mes "Each base will give you points each 5 seconds of Domination.";
+				next;
+				mes "[^FFA500Battle Recruiter^000000]";
+				mes "The first Team reach 99 points wins the match.";
+				break;			
+			case 6:
+				mes "[^FFA500Battle Recruiter^000000]";
+				mes "If you are Attacking, destroy the enemy defenses and it's Flag.";
+				next;
+				mes "[^FFA500Battle Recruiter^000000]";
+				mes "If you are Defending, protect your castle defenses and the Flag.";
+				break;
+			case 7:
+				mes "[^FFA500Battle Recruiter^000000]";
+				mes "Fight to capture the Castle and organize your team to defend it.";
+				next;
+				mes "[^FFA500Battle Recruiter^000000]";
+				mes "If you fail on the first capture, kill the defender and take it for your team.";
+				break;
+			case 8:
+				mes "[^1AAF9B Battle Recruiter ^000000]";
+				mes "Fight to drop down the opponent's points to 0.";
+				next;
+				mes "[^1AAF9B Battle Recruiter ^000000]";
+				mes "Each player represent one point, if you kill him your team win a point and his team loose one point.";
+				next;
+				mes "[^1AAF9B Battle Recruiter ^000000]";
+				mes "5 minutes of fighting. The team with the high score win the game.";
+				break;
+			case 9:
+				mes "[^1AAF9B Battle Recruiter ^000000]";
+				mes "It is a soccer game, the goal is to score more goals than the opposing team during the 4 minutes of the match.";
+				next;
+				mes "[^1AAF9B Battle Recruiter ^000000]";
+				mes "You can not hit your opponents but be careful not to take the ball in your face...";				
+				next;
+				mes "[^1AAF9B Battle Recruiter ^000000]";
+				mes "If a player dies in the penalty area, a throw-in is made by the team on which the foul was committed.";
+				break;
+			case 10:
+				mes "[^1AAF9B Battle Recruiter ^000000]";
+				mes "You have to put the Fumbi in the opposing goal.";
+				next;
+				mes "[^1AAF9B Battle Recruiter ^000000]";
+				mes "To take the Fumbi you just have to touch it when it's on the ground.";
+				next;
+				mes "[^1AAF9B Battle Recruiter ^000000]";
+				mes "Goals, kills and Fumbi possession will give you points.";
+				break;
+			}
+			break;
+		}
+		close;
+	}
+	end;
+}
+
+// General Guillaume
+// *********************************************************************
+bat_room,160,159,3	script	General Guillaume	420,{
+	cutin "bat_kiyom2",2;
+	mes "[General Guillaume]";
+	mes "Hot-blooded adventurer, we need your ability to win this battle.";
+	next;
+	cutin "bat_kiyom1",2;
+	mes "[General Guillaume]";
+	mes "Our great king, Marcel Marollo VII, is very sick lately. His Majesty has declared that he chosen either me or Prince Croix as the next king amongst his 9 sons.";
+	next;
+	mes "[General Guillaume]";
+	mes "Two kings can't share a nation!";
+	mes "Only the one victorious from His Majesty's appointed battle will be enthroned.";
+	next;
+	mes "[General Guillaume]";
+	mes "This is however, not just a battle between us. This battle will determine the future of this country. I pledge on my honor to prove that I'm the one who can protect this Maroll from outside threats.";
+	close2;
+	cutin "",255;
+	end;
+}
+
+// General Croix
+// *********************************************************************
+bat_room,160,140,3	script	Prince Croix	416,{
+	cutin "bat_crua1",2;
+	mes "[Prince Croix]";
+	mes "Wise adventurer, why don't you lend us your power for victory?";
+	next;
+	cutin "bat_crua2",2;
+	mes "[Prince Croix]";
+	mes "I do not wish to shed blood, but I have no choice but to fight for the possibility of peace and for the sake of my people.";
+	next;
+	mes "[Prince Croix]";
+	mes "General Guillaume may have an advantage in this battle as he is the great general of Maroll, but that doesn't automatically mean he'll win. I want to win this battle so that I can grant a better future for my people.";
+	close2;
+	cutin "",255;
+	end;
+}
+
+// Guard Dummy
+// *********************************************************************
+
+bat_room,161,141,3	script	Prince Croix's Aid::bat_aid	415,{ end; }
+bat_room,161,139,3	duplicate(bat_aid)	Prince Croix's Aid::bat_aid2	415
+bat_room,161,160,3	duplicate(bat_aid)	General Guillaume's Aid::bat_aid3	419
+bat_room,161,158,3	duplicate(bat_aid)	General Guillaume's Aid::bat_aid4	419
+
+// Flags
+// *********************************************************************
+
+-	script	Base Flag#bg	-1,{ end; }
+
+// BattleGround Warper - Exit
+// *********************************************************************
+
+bat_room,148,150,4	script	Teleporter#bat	124,{
+	mes "[Teleporter]";
+	mes "Do you wish to leave the battlefield? Use my service to return to town.";
+	next;
+	if( select("Leave:Don't Leave") == 2 )
+	{
+		mes "[Teleporter]";
+		mes "I'll be here whenever you're in need of my service.";
+		close;
+	}
+	mes "[Teleporter]";
+	mes "You will be sent back to " + getsavepoint(0) + ".";
+	close2;
+	warp getsavepoint(0), getsavepoint(1), getsavepoint(2);
+	end;
+}
+
+// Kafra
+// *********************************************************************
+bat_room,148,147,4	script	Kafra Staff::kaf_bat	861,{
+	cutin "kafra_09",2;
+	callfunc "F_Kafra",0,2,1,150,0;
+}
diff --git a/npc/battleground-extended/bg_dealers.txt b/npc/battleground-extended/bg_dealers.txt
new file mode 100644
index 000000000..022f61451
--- /dev/null
+++ b/npc/battleground-extended/bg_dealers.txt
@@ -0,0 +1,770 @@
+//===== rAthena Script ======================================= 
+//= BattleGround System - Item Dealer
+//===== By: ================================================== 
+//= L0ne_W0lf & Vykimo
+//===== Current Version: ===================================== 
+//= 2.0
+//===== Compatible With: ===================================== 
+//= rAthena Project
+//============================================================
+
+bat_room,159,150,3	script	KVM Logistic Officer#a	10187,{
+	if (countitem(7773)) {
+		set .@pointstoadd,countitem(7773);
+		delitem 7773,.@pointstoadd;
+		set kvm_point,kvm_point+.@pointstoadd;
+		mes "[Logistics]";
+		mes "Are those "+getitemname(7773)+"s I see?";
+		mes "We no longer accept that currency,";
+		mes "but I can exchange those for you,";
+		mes "So you have "+.@pointstoadd+" "+getitemname(7773)+"s?";
+		mes "Alright, all set, you now have ^580080"+ kvm_point +"^000000 KVM Points.";
+		next;
+	}
+	if (checkweight(1201,1) == 0) {
+		mes "- Wait a minute !! -";
+		mes "- Currently you're carrying -";
+		mes "- too many items with you. -";
+		mes "- Please try again -";
+		mes "- after you loose some weight. -";
+		close;
+	}
+	mes "[Logistics]";
+	mes "Hello?";
+	mes "I am in charge of distributing";
+	mes "reward items for KVM points. Any";
+	mes "wrong selection of items will not";
+	mes "be reversed. Please be carefull.";
+	mes "Select the next step please.";
+	next;
+	set .@name$,strcharinfo(0);
+	switch(select("Read the KVM Catalogue.:Purchase KVM Items.:Confirm KVM Points.:Explanation of KVM Rewards.:Explanation of KVM Points.")) {
+	case 1:
+		mes "[Logistics]";
+		mes "Here is the catalogue of KVM items.";
+		mes "Each weapon requires 2,000 points";
+		mes "and each armor from 10 to 1,200";
+		mes "points. So, be carefull when";
+		mes "selecting a reward.";
+		close2;
+		readbook 11017,1;
+		end;
+	case 2:
+		mes "[Logistics]";
+		mes "Wich items do you want to see? As";
+		mes "for the detailed specification of";
+		mes "the items, please refer to the";
+		mes "^3131FFCatalogue^000000.";
+		next;
+		switch(select("Weapon:Armor/Accessory:Mass-Production Armor/Accessory:Popularized Armor/Accessory")) {
+		case 1:
+			mes "[Logistics]";
+			mes "You have selected the Weapon Category.";
+			mes "Please select a sub-category.";
+			next;
+			switch(select("Dagger/Sword/Spear:Staff/Mace/Axe/Shuriken:Bow/Katar/Instrument/Whip:Book/Knuckle:Revolver/Rifle/Gun/Grenade Launcher")) {
+			case 1:
+				mes "[Logistics]";
+				mes "You have selected the Dagger/Sword/Spear category.";
+				mes "Please select a sub-category.";
+				next;
+				switch(select("Dagger:One-handed Sword:Two-handed Sword:One-handed Spear:Two-handed Spear")) {
+				case 1: callsub PurchaseItem,13042,0,1; //Krieger_Dagger1 
+				case 2:
+					mes "[Logistics]";
+					mes "You have selected the 'One-handed Sword' category.";
+					mes "There are 3 One-handed Swords: Glorious Flamberge, Glorious Rapier and Glorious Holy Avenger.";
+					mes "If you want their details, please refer to the KVM Catalogue.";
+					mes "Please select one of them.";
+					next;
+					switch(select("Glorious Flamberge:Glorious Rapier:Glorious Holy Avenger")) {
+					case 1: callsub PurchaseItem,13416,0,0; //Krieger_Onehand_Sword1
+					case 2: callsub PurchaseItem,13417,0,0; //Krieger_Onehand_Sword2
+					case 3: callsub PurchaseItem,13418,0,0; //Krieger_Onehand_Sword3
+					}
+				case 3: callsub PurchaseItem,1187,0,1; //Krieger_Twohand_Sword1
+				case 4: callsub PurchaseItem,1426,0,1; //Krieger_Onehand_Spear1
+				case 5: callsub PurchaseItem,1486,0,1; //Krieger_Twohand_Spear1
+				}
+			case 2:
+				mes "[Logistics]";
+				mes "You have selected the 'Staff/Mace/Axe/Shuriken' category.";
+				mes "Please select a sub-category.";
+				next;
+				switch(select("Staff:Mace:One-handed Axe:Two-handed Axe:Shuriken")) {
+				case 1:
+					mes "[Logistics]";
+					mes "You have selected the 'Staff' category.";
+					mes "There are 3 Staffs: a Two-handed Weapon Glorious Destruction Staff, a One-handed Glorious Arc Wand and a Glorious Healing Staff.";
+					mes "If you want their details, please refer to the KVM Catalogue.";
+					mes "Please select one of them.";
+					next;
+					switch(select("Glorious Destruction Staff:Glorious Arc Wand:Glorious Healing Staff")) {
+					case 1: callsub PurchaseItem,2002,0,0; //Krieger_Twohand_Staff1
+					case 2: callsub PurchaseItem,1640,0,0; //Krieger_Onehand_Staff1
+					case 3: callsub PurchaseItem,1641,0,0; //Krieger_Onehand_Staff2
+					}
+				case 2: callsub PurchaseItem,1546,0,1; //Krieger_Onehand_Mace1
+				case 3: callsub PurchaseItem,1310,0,1; //Krieger_Onehand_Axe1
+				case 4: callsub PurchaseItem,1382,0,1; //Krieger_Twohand_Axe1
+				case 5: callsub PurchaseItem,13307,0,1; //Krieger_Huuma_Shuriken1
+				}
+			case 3:
+				mes "[Logistics]";
+				mes "You have selected the Bow/Katar/Instrument/Whip category.";
+				mes "Please select a sub-category.";
+				next;
+				switch(select("Bow:Katar:Instrument:Whip")) {
+				case 1: callsub PurchaseItem,1743,0,1; //Krieger_Bow1
+				case 2:
+					mes "[Logistics]";
+					mes "You have selected the 'Katar' category.";
+					mes "There are 2 Katars: Glorious Bloody Roar and Glorious Jamadhar.";
+					mes "If you want their details, please refer to the KVM Catalogue.";
+					mes "Please select one of them.";
+					next;
+					switch(select("Glorious Bloody Roar:Glorious Jamadhar")) {
+					case 1: callsub PurchaseItem,1281,0,0; //Krieger_Katar1
+					case 2: callsub PurchaseItem,1282,0,0; //Krieger_Katar2
+					}
+				case 3: callsub PurchaseItem,1927,0,1; //Krieger_Instrument1
+				case 4: callsub PurchaseItem,1981,0,1; //Krieger_Whip1
+				}
+			case 4:
+				mes "[Logistics]";
+				mes "You have selected the Book/Knuckle category.";
+				mes "Please select a sub-category.";
+				next;
+				switch(select("Book:Knuckle")) {
+				case 1:
+					mes "[Logistics]";
+					mes "You have selected 'Book'.";
+					mes "There are 2 Books: Glorious Tablet and Glorious Apocalypse.";
+					mes "If you want their details, please refer to the KVM Catalogue.";
+					mes "Please select one of them.";
+					next;
+					switch(select("Glorious Tablet:Glorious Apocalypse")) {
+					case 1: callsub PurchaseItem,1576,0,0; //Krieger_Book1
+					case 2: callsub PurchaseItem,1577,0,0; //Krieger_Book2
+					}
+				case 2:
+					mes "[Logistics]";
+					mes "You have selected the 'Knuckle' category.";
+					mes "There are 2 Knuckles: Glorious Claw and Glorious Fist.";
+					mes "If you want their details, please refer to the KVM Catalogue.";
+					mes "Please select one of them.";
+					next;
+					switch(select("Glorious Claw:Glorious Fist")) {
+					case 1: callsub PurchaseItem,1826,0,0; //Krieger_Knuckle1
+					case 2: callsub PurchaseItem,1827,0,0; //Krieger_Knuckle2
+					}
+				}
+			case 5:
+				mes "[Logistics]";
+				mes "You have selected the 'Revolver/Rifle/Gun/Grenade Launcher' category.";
+				mes "Please select a sub-category.";
+				next;
+				switch(select("Revolver:Rifle:Gatling Gun:Shotgun:Grenade Launcher")) {
+				case 1: callsub PurchaseItem,13110,0,1; //Krieger_Pistol1
+				case 2: callsub PurchaseItem,13176,0,1; //Krieger_Rifle1
+				case 3: callsub PurchaseItem,13177,0,1; //Krieger_Gatling1
+				case 4: callsub PurchaseItem,13178,0,1; //Krieger_Shotgun1
+				case 5: callsub PurchaseItem,13179,0,1; //Krieger_Launcher1
+				}
+			}
+		case 2:
+			mes "[Logistics]";
+			mes "You have selected the 'Armor/Accessory' category.";
+			mes "Please select a sub-category.";
+			next;
+			switch(select("Armor:Cloak:Shoes:Accessory")) {
+			case 1: callsub PurchaseItem,2394,1,2; //Krieger_Suit1
+			case 2: callsub PurchaseItem,2549,2,2; //Krieger_Muffler1
+			case 3: callsub PurchaseItem,2444,3,2; //Krieger_Shoes1
+			case 4: callsub PurchaseItem,2772,4,2; //Krieger_Ring1
+			}
+		case 3:
+			mes "[Logistics]";
+			mes "You have selected the 'Mass-Production Armor/Accessory' category.";
+			mes "Please select a sub-category.";
+			next;
+			switch(select("Mass-Production Armor:Mass-Production Shoes:Mass-Production Accessory")) {
+			case 1: callsub PurchaseItem,2395,5,3; //Krieger_Suit2
+			case 2: callsub PurchaseItem,2445,6,3; //Krieger_Shoes2
+			case 3: callsub PurchaseItem,2773,7,3; //Krieger_Ring2
+			}
+		case 4:
+			mes "[Logistics]";
+			mes "You have selected the 'Popularized Armor/Accessory' category.";
+			mes "Please select a sub-category.";
+			next;
+			switch(select("Popularized Armor:Popularized Shoes:Popularized Accessory")) {
+			case 1: callsub PurchaseItem,2396,8,4; //Krieger_Suit3
+			case 2: callsub PurchaseItem,2446,9,4; //Krieger_Shoes3
+			case 3: callsub PurchaseItem,2774,10,4; //Krieger_Ring3
+			}
+		}
+	case 3:
+		mes "[Logistics]";
+		mes ""+ .@name$ +", your current points are ^580080"+ kvm_point +"^000000 KVM Points.";
+		close;
+	case 4:
+		mes "[Logistics]";
+		mes "There are 3 categories in KVM Rewards: Weapon/Armor.Accessory.";
+		next;
+		mes "[Logistics]";
+		mes "Weapon rewards require 2,000 KVM points for each.";
+		mes "There are 3 types of Armor rewards and they require 840/630/580 KVM points fo each.";
+		mes "Accessory rewards require 1,200 KVM points for each.";
+		next;
+		mes "[Logistics]";
+		mes "Kreiger Weapons are LV 4 Weapons, they can be upgraded and will have special effects: Slaughter, Destruction and Blessing.";
+		next;
+		mes "[Logistics]";
+		mes "When you can wear all 3 armors, you can have a special set of options.";
+		mes "Also, when Kreiger Accessory rewards are worn with medalsm it will bring you special set rewards.";
+		next;
+		mes "[Logistics]";
+		mes "Finally, there are Mass-Production Armor and Accessory rewards.";
+		mes "Players whose Lvl is higher than 60 can equip Mass-Production Armors and there is a Lvl limit for Popularized Armor as well.";
+		close;
+	case 5:
+		mes "[Logistics]";
+		mes "KVM Points are rewarded when you win, lose or draw in Kreiger Von Midgard (KVM).";
+		mes "You can have special Rewards by using these points.";
+		close;
+	}
+
+PurchaseItem:
+	// Pricing for Weapon, Suit1, Muffler1, Shoes1, Ring1m Suit2, Shoes2, Ring2, Suit3, Shoes3, Ring3
+	setarray .@prices[0],2000,840,630,580,1200,120,70,200,15,10,30;
+
+	.@item_id = getarg(0);
+	.@req_setting = getarg(1);
+	.@item_type = getarg(2);
+
+	mes "[Logistics]";
+
+	if (!.@item_type)
+		mes "You have selected ^ff0000"+ getitemname(.@item_id) +"^000000.";
+	else if (.@item_type == 1)
+		mes "There is only one "+ callfunc("F_GetWeaponType",.@item_id) +": "+ getitemname(.@item_id) +".";
+	else if (.@item_type == 2) {
+		mes "You have selected '"+ callfunc("F_GetArmorType",.@item_id) +"'.";
+		mes "The armor for one whose Lvl is more than 80 is: ^ff0000"+ getitemname(.@item_id) +"^000000.";
+	}
+	else if (.@item_type == 3) {
+		mes "You have selected 'Mass-Production "+ callfunc("F_GetArmorType",.@item_id) +"'.";
+		mes "There is only one Mass-Production "+ callfunc("F_GetArmorType",.@item_id) +": ^ff0000"+ getitemname(.@item_id) +"^000000.";
+	}
+	else if (.@item_type == 4) {
+		mes "You have selected 'Popularized "+ callfunc("F_GetArmorType",.@item_id) +"'.";
+		mes "There is only one Popularized "+ callfunc("F_GetArmorType",.@item_id) +": ^ff0000"+ getitemname(.@item_id) +"^000000.";
+	}
+
+	if (!.@req_setting)
+		mes "It requires ^0000ff2,000^000000 KVM Points, and "+ .@name$ +", your points are: ^580080"+ kvm_point +"^000000.";
+	else if (.@req_setting == 4)
+		mes "It requires ^0000ff1,200^000000 KVM Points, and "+ .@name$ +", your points are: ^580080"+ kvm_point +"^000000.";
+	else
+		mes "It requires ^0000ff"+ .@prices[.@req_setting] +"^000000 KVM Points, and "+ .@name$ +", your points are: ^580080"+ kvm_point +"^000000.";
+
+	mes "Are you sure you want this item?";
+	next;
+	switch(select("No, I won't purchase it.:Yes, I will purchase it.")) {
+	case 1:
+		mes "[Logistics]";
+		mes "You have selected 'I won't purchase it'.";
+		mes "When purchasing an item, please be careful there are no refunds.";
+		break;
+	case 2:
+		if (kvm_point >= .@prices[.@req_setting]) {
+			kvm_point = kvm_point -.@prices[.@req_setting];
+			getitem .@item_id,1;
+			mes "[Logistics]";
+			mes "You have purchased a "+ getitemname(.@item_id) +".";
+			if (!.@req_setting)
+				mes "Your KVM Points are reduced by ^0000ff"+ .@req_setting +"^000000 points, your KVM Points are now ^580080"+kvm_point+"^000000.";
+			if (.@req_setting == 4)
+				mes "Your KVM Points are reduced by ^0000ff1,200^000000 points, your KVM Points are now ^580080"+kvm_point+"^000000.";
+			else
+				mes "Your KVM Points are reduced by ^0000ff"+ .@prices[.@req_setting] +"^000000 points, your KVM Points are now ^580080"+kvm_point+"^000000.";
+		}
+		else {
+			mes "[Logistics]";
+			if (!.@req_setting)
+				mes "You need ^0000ff2,000^000000 KVM Points to purchase this item.";
+			else if (.@req_setting == 4)
+				mes "You need ^0000ff1,200^000000 KVM Points to purchase this item.";
+			else
+				mes "You need ^0000ff"+ .@prices[.@req_setting] +"^000000 KVM Points to purchase this item.";
+			mes "However, your KVM Points are now ^580080"+ kvm_point +"^000000.";
+			mes "Which are not enough to buy it.";
+			mes "When you get enough points, please come back again.";
+		}
+	}
+	close;
+OnInit:
+    waitingroom "KvM pts Business",0;
+	end;
+}
+
+// Badges Exchange
+//============================================================
+bat_room,159,146,3	script	Telma	10121,{
+	mes "[Telma]";
+	mes "Welcome, mighty warrior.";
+	mes "Do you need supply for your battles?";
+	mes "I can exchange you for a nice amount of your badges.";
+	next;
+	switch( select("WoE Items:BG Items") )
+	{
+	case 1: // WoE Items
+		{
+			switch( select("^0000FFWoE Exclusive^000000:Other Items (All):Other Items (Genetic):Other Items (Guillotine Cross):Other Items (Warlock):Other Items (Mechanics):Other Items (Sorcerer):Other Items (Rune Knight)") )
+			{
+			case 1: // WoE Supply Items
+				setarray .@Items[0],   547, 505, 12016, 12030, 12029, 12031, 6217, 12262;
+				setarray .@Amount[0],  100, 100,    20,    10,    10,    10,   10,    10;
+				setarray .@Value[0],   100, 100,    80,    25,    25,    25,   30,    20;
+				set .@cID, getbattleflag("woe_reserved_char_id");
+				set .@Tarjet$, "War of Emperium or GvG";
+				break;				
+			case 2: // Other Items (All)
+				setarray .@Items[0],  12072, 12077, 12082, 12087, 12092, 12097, 12429, 12430, 12431, 12432, 12433, 12434, 7776;
+				setarray .@Amount[0],     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,    1;
+				setarray .@Value[0],     20,    20,    20,    20,    20,    20,    20,    20,    20,    20,    20,    20, 2000;
+				set .@cID, 0;
+				set .@Tarjet$, "Everywhere";
+				break;				
+			case 3: // Other Items (Genetic)
+				setarray .@Items[0],   7136,  7137,  6217,  6210,  7139,  7135,  6211,  7138,  6212, 13260, 13261, 13262, 13263, 13264;
+				setarray .@Amount[0],     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1;
+				setarray .@Value[0],     75,    20,    30,    15,    20,    20,    20,    30,    30,    30,    30,    30,    30,    30;
+				set .@cID, 0;
+				set .@Tarjet$, "Everywhere";
+				break;				
+			case 4: // Other Items (Guillotine Cross)
+				setarray .@Items[0],    678, 12717, 12722, 12720, 12718,  6128, 12724, 12723, 12721, 12719;
+				setarray .@Amount[0],     1,     1,     1,     1,     1,     1,     1,     1,     1,     1;
+				setarray .@Value[0],     75,   300,   300,   300,   300,   300,   300,   300,   300,   300;
+				set .@cID, 0;
+				set .@Tarjet$, "Everywhere";
+				break;				
+			case 5: // Other Items (Warlock)
+				setarray .@Items[0],  6195, 6196;
+				setarray .@Amount[0],    1,    1;
+				setarray .@Value[0],  1500, 1500;
+				set .@cID, 0;
+				set .@Tarjet$, "Everywhere";
+				break;				
+			case 6: // Other Items (Mecanics)
+				setarray .@Items[0],  1549;
+				setarray .@Amount[0],    1;
+				setarray .@Value[0],  1500;
+				set .@cID, 0;
+				set .@Tarjet$, "Everywhere";
+				break;				
+			case 7: // Other Items (Sorcerer)
+				setarray .@Items[0],  1025, 997, 996, 995, 994;
+				setarray .@Amount[0],   10,   5,   5,   5,   5;
+				setarray .@Value[0],    10,  25,  25,  25,  25;
+				set .@cID, 0;
+				set .@Tarjet$, "Everywhere";
+				break;				
+			case 8: // Other Items (RK)
+				setarray .@Items[0],  12731, 12728, 12732, 12733, 12729, 12730, 12726, 12725, 12727;
+				setarray .@Amount[0],     1,     1,     1,     1,     1,     1,     1,     1,     1;
+				setarray .@Value[0],     35,    35,    35,    35,    35,    35,    35,    35,    35;
+				set .@cID, 0;
+				set .@Tarjet$, "Everywhere";
+				break;
+			}
+		}
+		break;
+		
+	case 2: 
+		{
+			switch( select("BG Exclusive (All):BG Exclusive (Genetic):BG Exclusive (Guillotine Cross):BG Exclusive (Warlock):BG Exclusive (Sorcerer):BG Exclusive (Archbishop):BG Exclusive (Rune Knight)") )
+			{
+			case 1: // BG Supply (all)
+				setarray .@Items[0],   12016, 547, 505, 12072, 12077, 12082, 12087, 12092, 12097, 12429, 12430, 12431, 12432, 12433, 12434, 12029, 12030, 12031, 12262;
+				setarray .@Amount[0],     25, 100, 100,    10,    10,    10,    10,    10,    10,    10,    10,    10,    10,    10,    10,    10,    10,    10,    10;
+				setarray .@Value[0],       1,   1,   1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1;
+				set .@cID, getbattleflag("bg_reserved_char_id");
+				set .@Tarjet$, "Battleground";
+				break;
+			case 2: // BG Supply (Genetic)
+				setarray .@Items[0],   7136, 7137, 6217, 6210, 7139, 7135, 6211, 7138, 6212, 13260, 13261, 13262, 13263, 13264;
+				setarray .@Amount[0],    25,   20,   10,   10,   15,   25,   10,   10,   10,     5,     5,     5,     5,     5;
+				setarray .@Value[0],      1,    1,    1,    1,    1,    1,    1,    1,    1,     1,     1,     1,     1,     1;
+				set .@cID, getbattleflag("bg_reserved_char_id");
+				set .@Tarjet$, "Battleground";
+				break;
+			case 3: // BG Supply (Guillotine Cross)
+				setarray .@Items[0],   678, 12717, 12722, 12720, 12718, 6128, 12724, 12723, 12721, 12719;
+				setarray .@Amount[0],   25,     5,     5,     5,     5,   10,     5,     5,     5,     5;
+				setarray .@Value[0],     1,     1,     1,     1,     1,    1,     1,     1,     1,     1;
+				set .@cID, getbattleflag("bg_reserved_char_id");
+				set .@Tarjet$, "Battleground";
+				break;
+			case 4: // BG Supply (Warlock)
+				setarray .@Items[0],   715, 716;
+				setarray .@Amount[0],   25,  25;
+				setarray .@Value[0],     1,   1;
+				set .@cID, getbattleflag("bg_reserved_char_id");
+				set .@Tarjet$, "Battleground";
+				break;
+			case 5: // BG Supply (Sorcerer)
+				setarray .@Items[0],   715, 716, 1025, 997, 996, 995, 994;
+				setarray .@Amount[0],   25,  25,   10,   5,   5,   5,   5;
+				setarray .@Value[0],     1,   1,    1,   1,   1,   1,   1;
+				set .@cID, getbattleflag("bg_reserved_char_id");
+				set .@Tarjet$, "Battleground";
+				break;
+			case 6: // BG Supply (Archbishop)
+				setarray .@Items[0],   523;
+				setarray .@Amount[0],   25;
+				setarray .@Value[0],     1;
+				set .@cID, getbattleflag("bg_reserved_char_id");
+				set .@Tarjet$, "Battleground";
+				break;
+			case 7: // BG Supply (Rune Knight)
+				setarray .@Items[0],   12731, 12728, 12732, 12733, 12729, 12730, 12726, 12725, 12727;
+				setarray .@Amount[0],      2,     2,     2,     2,     2,     2,     2,     2,     2;
+				setarray .@Value[0],       1,     1,     1,     1,     1,     1,     1,     1,     1;
+				set .@cID, getbattleflag("bg_reserved_char_id");
+				set .@Tarjet$, "Battleground";
+				break;
+			}
+		}
+		break;
+	}
+
+	set .@Menu$, "";
+	for( set .@i, 0; .@i < getarraysize(.@Items); set .@i, .@i + 1 )
+		set .@Menu$, .@Menu$ + .@Amount[.@i] + " " + getitemname(.@Items[.@i]) + " (" + .@Value[.@i] + " badges):";
+	set .@j, select(.@Menu$) - 1;
+
+	mes "[Telma]";
+	mes "^0000FF" + .@Amount[.@j] + " " + getitemname(.@Items[.@j]) + "^000000";
+	mes "It will cost you " + .@Value[.@j] + " badges per pack.";
+	mes "Remember this can only be used on " + .@Tarjet$ + ".";
+	next;
+	
+	mes "[Telma]";
+	mes "But tell me first, where do you want to receive the items?";
+	next;
+	set .@Destiny, select("Here, in my Inventory:Direct to my Storage") - 1;
+
+	mes "[Telma]";
+	mes "How many packets do you want to buy? (1..50)";
+	next;
+
+	input .@total;
+	if( .@total < 1 || .@total > 50 )
+	{
+		mes "[Telma]";
+		mes "I am sorry, please input a value from 1 to 50.";
+		mes "Talk to me again when you do your selections.";
+		close;
+	}
+	
+	set .@vtotal, .@total * .@Value[.@j]; // Value of all Packages
+	set .@total, .@total * .@Amount[.@j]; // Total Amount of Items
+
+	if( .@Destiny )
+	{ // Check Storage Space Limit
+		if( .@cID )
+		{
+			if( checkspace(.@Items[.@j],.@total,1,0,0,254,0,.@cID&0xffff,(.@cID>>16)&0xffff) == 0 )
+			{
+				mes "[Telma]";
+				mes "It's seen your storage cannot accept more items.";
+				mes "Go to your store and check the free space.";
+				close;
+			}
+		}
+		else
+		{
+			if( checkspace(.@Items[.@j],.@total,1,0,0,0,0,0,0) == 0 )
+			{
+				mes "[Telma]";
+				mes "It's seen your storage cannot accept more items.";
+				mes "Go to your store and check the free space.";
+				close;
+			}
+		}
+	}
+	else
+	{ // Check Weight Limit
+		if( checkweight(.@Items[.@j],.@total) == 0 )
+		{
+			mes "[Telma]";
+			mes "It's seen you can't carry the stuff you want to buy.";
+			mes "Go and store some items on your Kafra Storage.";
+			close;
+		}
+	}
+
+	if( countitem(7828) + countitem(7829) + countitem(7773) < .@vtotal )
+	{
+		mes "[Telma]";
+		mes "Required Badges: ^0000FF" + .@vtotal + "^000000";
+		mes "You do not have enough badges. Sorry...";
+		mes "Participate in Battleground arenas to receive it.";
+		close;
+	}
+	set .@vcount, .@vtotal;
+	set .@i7828, 0;
+	set .@i7829, 0;
+	set .@i7773, 0;
+
+	// Bravery Badges
+	if( countitem(7828) > 0 )
+	{
+		mes "[Telma]";
+		mes "Required Badges: ^0000FF" + .@vcount + "^000000";
+		mes "Bravery Badges to expend:";
+		next;
+		input .@i7828;
+		if( .@i7828 < 0 || .@i7828 > countitem(7828) )
+		{
+			mes "[Telma]";
+			mes "Invalid number... Sorry.";
+			close;
+		}
+		
+		if( .@i7828 > .@vcount ) set .@i7828,.@vcount;
+		set .@vcount, .@vcount - .@i7828;
+	}
+
+	// Valor Badges
+	if( .@vcount && countitem(7829) > 0 )
+	{
+		mes "[Telma]";
+		mes "Required Badges: ^0000FF" + .@vcount + "^000000";
+		mes "Valor Badges to expend:";
+		next;
+		input .@i7829;
+		if( .@i7829 < 0 || .@i7829 > countitem(7829) )
+		{
+			mes "[Telma]";
+			mes "Invalid number... Sorry.";
+			close;
+		}
+		
+		if( .@i7829 > .@vcount ) set .@i7829,.@vcount;
+		set .@vcount, .@vcount - .@i7829;
+	}
+
+	// Heroism Badges
+	if( .@vcount && countitem(7773) > 0 )
+	{
+		mes "[Telma]";
+		mes "Required Badges: ^0000FF" + .@vcount + "^000000";
+		mes "Heroism Badges to expend:";
+		next;
+		input .@i7773;
+		if( .@i7773 < 0 || .@i7773 > countitem(7773) )
+		{
+			mes "[Telma]";
+			mes "Invalid number... Sorry.";
+			close;
+		}
+
+		if( .@i7773 > .@vcount ) set .@i7773, .@vcount;
+		set .@vcount, .@vcount - .@i7773;
+	}
+
+	// Final Checks
+	if( .@vcount != 0 )
+	{
+		mes "[Telma]";
+		mes "Sorry, not enough badges to pay the total value.";
+		close;
+	}
+
+	mes "[Telma]";
+	mes "Are you ready to pay and receive your items?";
+	mes "Your payment details:";
+	mes "^0000FF" + .@i7828 + "^000000 Bravery Badges";
+	mes "^0000FF" + .@i7829 + "^000000 Valor Badges";
+	mes "^0000FF" + .@i7773 + "^000000 Heroism Badges";
+	next;
+
+	if( select("Yes, let's do it:I am sorry... not this time") == 2 )
+	{
+		mes "[Telma]";
+		mes "Ok, come again if you change your mind.";
+		close;
+	}
+
+	if( .@Destiny )
+	{ // Check Storage Space Limit
+		if( .@cID )
+		{
+			if( checkspace(.@Items[.@j],.@total,1,0,0,254,0,.@cID&0xffff,(.@cID>>16)&0xffff) == 0 )
+			{
+				mes "[Telma]";
+				mes "It's seen your storage cannot accept more items.";
+				mes "Go to your store and check the free space.";
+				close;
+			}
+		}
+		else
+		{
+			if( checkspace(.@Items[.@j],.@total,1,0,0,0,0,0,0) == 0 )
+			{
+				mes "[Telma]";
+				mes "It's seen your storage cannot accept more items.";
+				mes "Go to your store and check the free space.";
+				close;
+			}
+		}
+	}
+	else
+	{ // Check Weight Limit
+		if( checkweight(.@Items[.@j],.@total) == 0 )
+		{
+			mes "[Telma]";
+			mes "It's seen you can't carry the stuff you want to buy.";
+			mes "Go and store some items on your Kafra Storage.";
+			close;
+		}
+	}
+
+	if( .@i7828 > countitem(7828) || .@i7829 > countitem(7829) || .@i7773 > countitem(7773) )
+	{
+		mes "[Telma]";
+		mes "What!?, are you a magician or a thief? What did you do with your badges!?";
+		mes "Get out of here!";
+		close;
+	}
+
+	delitem 7828,.@i7828;
+	delitem 7829,.@i7829;
+	delitem 7773,.@i7773;
+
+	if( .@cID )
+	{
+		if( .@Destiny )
+			storeitem2 .@Items[.@j],.@total,1,0,0,254,0,.@cID&0xffff,(.@cID>>16)&0xffff;
+		else
+			getitem2 .@Items[.@j],.@total,1,0,0,254,0,.@cID&0xffff,(.@cID>>16)&0xffff;
+	}
+	else
+	{
+		if( .@Destiny )
+			storeitem .@Items[.@j],.@total;
+		else
+			getitem .@Items[.@j],.@total;
+	}
+
+	mes "[Telma]";
+	mes "Here it is... Now take care and fight for the honor and glory of your prince.";
+	close;
+OnInit:
+    waitingroom "Goods Business",0;
+	end;
+}
+
+bat_room,1,1,3	itemshop	BraveryExchanger	111,7828,13036:100,13411:100,1425:100,1632:100,1634:100,1543:100,1924:100,1978:100,1574:100,1824:100,1183:100,1380:100,13305:100,1279:100,1739:100,13108:100,13172:100,2538:50,2539:50,2540:50,2435:50,2436:50,2437:50,2376:80,2377:80,2378:80,2379:80,2380:80,2381:80,2382:80,2720:500,2721:500,2722:500,2723:500,2724:500,2725:500,2733:500
+bat_room,1,1,3	itemshop	ValorExchanger	111,7829,13037:100,13410:100,1633:100,1635:100,1542:100,1923:100,1977:100,1575:100,1823:100,1184:100,1482:100,1379:100,13306:100,1280:100,1738:100,13171:100,13173:100,13174:100,2538:50,2539:50,2540:50,2435:50,2436:50,2437:50,2376:80,2377:80,2378:80,2379:80,2380:80,2381:80,2382:80,2720:500,2721:500,2722:500,2723:500,2724:500,2725:500,2733:500
+bat_room,1,1,3	itemshop	HeroismExchanger	111,7773,1187:2000,1281:2000,1282:2000,1310:2000,1382:2000,1426:2000,1486:2000,1546:2000,1576:2000,1577:2000,1640:2000,1641:2000,1743:2000,1826:2000,1827:2000,1927:2000,1981:2000,2002:2000,13042:2000,13110:2000,13176:2000,13177:2000,13178:2000,13179:2000,13307:2000,13416:2000,13417:2000,13418:2000,2394:840,2395:170,2396:25,2444:580,2445:70,2446:15,2549:630,2772:1200,2773:280,2774:40
+
+bat_room,159,154,3	script	Erundek	10132,{
+	mes "[Erundek]";
+	mes "Welcome, mighty warrior.";
+	mes "What can I do for you today ?";
+	next;
+	switch( select("Exchange Bravery Badges","Exchange Valor Badges","Exchange Heroism Badges","Hmm, nothing I guess.") )
+	{
+		case 4:
+			mes "[Erundek]";
+			mes "As you wish.";
+			mes "See you later.";
+			close;
+		case 1: // Bravery Badges
+			mes "[Erundek]";
+			mes "So you want to exchange ^0000FFBravery Badges^000000 from the Battle of Tierra Valley.";
+			mes "Close this window to open shop.";
+			close2;
+			callshop "BraveryExchanger",0;
+			end;
+		case 2: // Valor Badges
+			mes "[Erundek]";
+			mes "So you want to exchange ^FF0000Valor Badges^000000 from the Battle of Flavius.";
+			mes "Close this window to open shop.";
+			close2;
+			callshop "ValorExchanger",0;
+			end;
+		case 3: // Heroism Badges
+			mes "[Erundek]";
+			mes "So you want to exchange ^FFA500Heroism Badges^000000 from the Battle of Kriger Von Midgard.";
+			mes "Close this window to open shop.";
+			close2;
+			callshop "HeroismExchanger",0;
+			end;
+	}
+OnInit:
+    waitingroom "Badges Business",0;
+	end;
+}
+
+bat_room,148,153,4	script	Location::Mount_Rent	875,{
+	if (bgcheck()){
+		setmadogear;
+		setcart;
+		setfalcon;
+		setdragon;
+		setriding;
+		specialeffect2 911;
+	} else {
+		mes "[^1AAF9BLocation^000000]";
+		mes "I work only during Battleground, please come back later.";
+	}
+	end;
+}
+
+bat_room,163,152,2	script	Exchange Machine#bg	564,{
+	input .@cb,0,100000;
+	if(.@cb == 0) end;
+	// 7804 : Battleground Badges
+	// 7773 : War Badges
+	// 7829 : Valor Badges
+	// 7828 : Bravery Badges
+	switch(select("War Badges:Valor Badges:Bravery Badges")) {
+		case 1:
+			if(countitem(7804) >= .@cb) {
+				delitem 7804, .@cb; 
+				getitem 7773, .@cb;
+				.@ok = 1;
+			}
+			break;
+		case 2:
+			if(countitem(7804) >= .@cb) {
+				delitem 7804, .@cb; 
+				getitem 7829, .@cb;
+				.@ok = 1;
+			}
+			break;
+		case 3:
+			if(countitem(7804) >= .@cb) {
+				delitem 7804, .@cb; 
+				getitem 7828, .@cb;
+				.@ok = 1;
+			}
+			break;
+	}
+	if(.@ok) {
+		specialeffect 618;
+		dispbottom "[Exchange Machine] You successfully exchanged " + .@cb + " Battleground Badge(s).";
+	} else
+		dispbottom "[Exchange Machine] No enough Battleground Badges for the exchange.";
+	end;
+	
+OnInit:
+    waitingroom "BG Badges Exchanger",0;
+	end;
+}
diff --git a/npc/battleground-extended/bg_entering.txt b/npc/battleground-extended/bg_entering.txt
new file mode 100644
index 000000000..08b42ff89
--- /dev/null
+++ b/npc/battleground-extended/bg_entering.txt
@@ -0,0 +1,186 @@
+// BG + PVP warper
+// By Vykimo
+
+1@pop3,49,73,0	script	Lightalzen Sanctuary	10042,{
+warp "x_lhz",0,0;
+	OnInit:
+	OnTimer1000:
+	delwaitingroom;
+	waitingroom "("+ (getmapusers("x_lhz")) +" players) Lightalzen Sanctuary",0;
+	initnpctimer;
+end;
+}
+1@pop3,66,73,0	script	Prontera Sanctuary	10043,{
+warp "x_prt",0,0;
+	OnInit:
+	OnTimer1000:
+	delwaitingroom;
+	waitingroom "("+ (getmapusers("x_prt")) +" players) Prontera Sanctuary ",0;
+	initnpctimer;
+end;
+}
+1@pop3,58,77,0	script	Rachel Sanctuary	10044,{
+warp "x_ra",0,0;
+	OnInit:
+	OnTimer1000:
+	delwaitingroom;
+	waitingroom "("+ (getmapusers("x_ra")) +" players) Rachel Sanctuary",0;
+	initnpctimer;
+end;
+}
+
+prontera,148,174,6	script	PVP & Battleground#j	734,{
+	if(bgcheck())
+	{
+		mes "^404040[^808080" + strnpcinfo(1) + "^404040]^000000";
+		mes "You can now participate in the Battleground and win prizes with your badges. Do you want to participate in the Battleground?";
+		next;
+		menu
+		"Participate in the Battleground (^FF0000" + (bg_get_data($@BG_Team1,0)+bg_get_data($@BG_Team2,0)) + " players^000000)",L_BG,
+		"Free PVP Arena (^FF0000" + (getmapusers("x_lhz")+getmapusers("x_prt")+getmapusers("x_ra")) + " players^000000)",L_PVP,
+		"Cancel",-;
+		close;
+	}
+		mes "^404040[^808080" + strnpcinfo(1) + "^404040]^000000";
+		mes "Hello, I can get you into the PVP arena of the server.";
+		next;
+		menu
+		"Free PVP Arena (^FF0000" + (getmapusers("x_lhz")+getmapusers("x_prt")+getmapusers("x_ra")) + " players^000000)",L_PVP,
+		"Access the battleground room",L_BG,
+		"Cancel",-;
+		close;
+
+L_PVP:
+	mes "^404040[^808080" + strnpcinfo(1) + "^404040]^000000";
+	mes "PVP Rules :";
+	mes " ";
+	mes "- It is forbidden to Kill Deco (that is kill a player, then immediately disconnect to avoid being killed).";
+	mes " ";
+	mes "- It is forbidden to Kill Raise (kill and revive the same player without his consent).";
+	mes " ";
+	mes "- It is strictly forbidden to Double Account to booster for the PVP / WOE and BG.";
+	close2;
+	getmapxy(@pvp_lmap$,@pvp_lx,@pvp_ly,BL_PC);
+	warp "1@pop3",57,68;
+	sc_end SC_ALL;
+	end;
+
+L_BG:
+	if( BaseLevel < 79 )
+	{
+		mes "^404040[^808080" + strnpcinfo(1) + "^404040]^000000";
+		mes "You must be minimum level base 80 to access to the battleground.";
+		close;
+	}
+	mes "^404040[^808080" + strnpcinfo(1) + "^404040]^000000";
+	mes "BG Rules :";
+	mes " ";
+	mes "- It is forbidden to Kill Deco (that is kill a player, then immediately disconnect to avoid being killed).";
+	mes " ";
+	mes "- It is forbidden to Kill Raise (kill and revive the same player without his consent).";
+	mes " ";
+	mes "- It is strictly forbidden to Double Account to booster for the PVP / WOE and BG.";
+	close2;
+	warp "bat_room",155,150;
+	end;
+	
+// To prevent debug in mapserver
+OnInit:
+	sleep 2000;
+	goto L_Next;
+	end;
+	
+OnTimer5000:
+	stopnpctimer;
+	set .nbr_joueurBG,(bg_get_data($@BG_Team1,0)+bg_get_data($@BG_Team2,0));
+	set .@nbr_joueurPVP,(getmapusers("x_lhz")+getmapusers("x_prt")+getmapusers("x_ra"));
+	delwaitingroom;
+L_Next:
+	if(.nbr_joueurBG >=1) 
+		waitingroom .nbr_joueurBG + " Player"+(.nbr_joueurBG>1?"s":"")+" in BG",0;
+	else if(.@nbr_joueurPVP >=1) 
+		waitingroom .@nbr_joueurPVP + " Player"+(.@nbr_joueurPVP>1?"s":"")+" in PVP",0;
+	else
+		waitingroom "No players",0;
+	initnpctimer;
+	end;
+	
+OnBGGlobalStart:
+	while(bgcheck()) {
+		//if(bg_queue_data(getvariableofnpc(.BG_Queue,"BG_Queue_Join"),0)>0)
+			specialeffect 367;
+		sleep 1500;
+	}
+	end;
+}
+
+// Exits
+1@pop3,53,62,0	script	Exit Hole	10065,{
+	warp @pvp_lmap$,@pvp_lx,@pvp_ly;
+	end;
+}
+
+-	script	PVP Exit	10119,{
+	mes "[ ^1AAF9BPvP Warper^000000 ]";
+	mes "Hello ^0000ff"+strcharinfo(0)+"^000000 !";
+	mes "Do you want to exit Arena?";
+	next;
+	menu "Yes",L_Sortir,"No",-;
+	mes "[ ^1AAF9BPvP Warper^000000 ]";
+	mes "As you want.";
+	close;
+	
+L_Sortir:
+	close2;
+	dispbottom "[ Exit ] : Going back town in 3seconds.";
+	progressbar "green",3;
+	warp "SavePoint",0,0;
+	end;
+	
+}
+x_prt,63,124,5	duplicate(PVP Exit)	PVP Exit#1	10119
+x_prt,75,10,3	duplicate(PVP Exit)	PVP Exit#2	10119
+x_lhz,119,102,5	duplicate(PVP Exit)	PVP Exit#3	10119
+x_lhz,22,102,3	duplicate(PVP Exit)	PVP Exit#4	10119
+x_ra,121,73,3	duplicate(PVP Exit)	PVP Exit#5	10119
+x_ra,20,73,5	duplicate(PVP Exit)	PVP Exit#6	10119
+
+//====================================================================================
+
+1@pop3	mapflag	nosave	SavePoint
+1@pop3	mapflag	nowarp
+1@pop3	mapflag	noteleport
+1@pop3	mapflag	nomemo
+
+x_lhz	mapflag	nopenalty
+x_lhz	mapflag	nosave	SavePoint
+x_lhz	mapflag	nowarp
+x_lhz	mapflag	noteleport
+x_lhz	mapflag	nomemo
+x_lhz	mapflag	pvp
+x_lhz	mapflag	loadevent
+x_lhz	mapflag	noreturn
+x_lhz	mapflag	nobranch
+x_lhz	mapflag	pvp_noguild
+
+x_prt	mapflag	nopenalty
+x_prt	mapflag	nosave	SavePoint
+x_prt	mapflag	nowarp
+x_prt	mapflag	noteleport
+x_prt	mapflag	nomemo
+x_prt	mapflag	pvp
+x_prt	mapflag	loadevent
+x_prt	mapflag	noreturn
+x_prt	mapflag	nobranch
+x_prt	mapflag	pvp_noguild
+
+x_ra	mapflag	nopenalty
+x_ra	mapflag	nosave	SavePoint
+x_ra	mapflag	nowarp
+x_ra	mapflag	noteleport
+x_ra	mapflag	nomemo
+x_ra	mapflag	pvp
+x_ra	mapflag	loadevent
+x_ra	mapflag	noreturn
+x_ra	mapflag	nobranch
+x_ra	mapflag	pvp_noguild
diff --git a/npc/re/scripts_athena.conf b/npc/re/scripts_athena.conf
index 5f101c5a3..ed6f1f593 100644
--- a/npc/re/scripts_athena.conf
+++ b/npc/re/scripts_athena.conf
@@ -10,7 +10,7 @@ npc: npc/re/other/global_npcs.txt
 npc: npc/re/airports/izlude.txt
 
 // --------------------- Battle Grounds -------------------------
-npc: npc/re/battleground/bg_common.txt
+//npc: npc/re/battleground/bg_common.txt
 
 // --------------------------- Cities ---------------------------
 npc: npc/re/cities/alberta.txt
diff --git a/npc/scripts_athena.conf b/npc/scripts_athena.conf
index c16cf9ab5..b57c133bc 100644
--- a/npc/scripts_athena.conf
+++ b/npc/scripts_athena.conf
@@ -13,21 +13,21 @@ npc: npc/airports/yuno.txt
 
 // --------------------- Battle Grounds -------------------------
 // - Flavius ----------------------------------------------------
-npc: npc/battleground/flavius/flavius_enter.txt
-npc: npc/battleground/flavius/flavius01.txt
-npc: npc/battleground/flavius/flavius02.txt
+//npc: npc/battleground/flavius/flavius_enter.txt
+//npc: npc/battleground/flavius/flavius01.txt
+//npc: npc/battleground/flavius/flavius02.txt
 // - Kreiger Von Midgard ----------------------------------------
-npc: npc/battleground/kvm/kvm_enter.txt
-npc: npc/battleground/kvm/kvm_item_pay.txt
-npc: npc/battleground/kvm/kvm01.txt
-npc: npc/battleground/kvm/kvm02.txt
-npc: npc/battleground/kvm/kvm03.txt
+//npc: npc/battleground/kvm/kvm_enter.txt
+//npc: npc/battleground/kvm/kvm_item_pay.txt
+//npc: npc/battleground/kvm/kvm01.txt
+//npc: npc/battleground/kvm/kvm02.txt
+//npc: npc/battleground/kvm/kvm03.txt
 // - Tierra Gorge -----------------------------------------------
-npc: npc/battleground/tierra/tierra_enter.txt
-npc: npc/battleground/tierra/tierra01.txt
-npc: npc/battleground/tierra/tierra02.txt
+//npc: npc/battleground/tierra/tierra_enter.txt
+//npc: npc/battleground/tierra/tierra01.txt
+//npc: npc/battleground/tierra/tierra02.txt
 // --------------------------------------------------------------
-npc: npc/battleground/bg_common.txt
+//npc: npc/battleground/bg_common.txt
 
 // --------------------------- Cities ---------------------------
 npc: npc/cities/alberta.txt
diff --git a/npc/scripts_custom.conf b/npc/scripts_custom.conf
index fb46627e4..683b24d83 100644
--- a/npc/scripts_custom.conf
+++ b/npc/scripts_custom.conf
@@ -6,6 +6,19 @@
 
 //npc: npc/location/to/script.txt
 
+// ----------------------- Custom BG By Vykimo -----------------------
+npc: npc/battleground-extended/bg_entering.txt
+npc: npc/battleground-extended/bg_common.txt
+npc: npc/battleground-extended/bg_dealers.txt
+npc: npc/battleground-extended/1-bg_ctf.txt
+npc: npc/battleground-extended/2-bg_tdm.txt
+npc: npc/battleground-extended/3-bg_eoe.txt
+npc: npc/battleground-extended/4-bg_conquest.txt
+npc: npc/battleground-extended/5-bg_kvm.txt
+npc: npc/battleground-extended/6-bg_sc.txt
+npc: npc/battleground-extended/7-bg_dom.txt
+npc: npc/battleground-extended/8-bg_rush.txt
+
 // ----------------------- Basic Scripts -----------------------
 //npc: npc/custom/warper.txt
 //npc: npc/custom/jobmaster.txt
diff --git a/src/custom/atcommand.inc b/src/custom/atcommand.inc
index 9dd4a3856..19c593fef 100644
--- a/src/custom/atcommand.inc
+++ b/src/custom/atcommand.inc
@@ -17,3 +17,296 @@
 //	clif_specialeffect(&sd->bl, EF_HEARTCASTING, AREA);
 //	return 0;
 //}
+
+
+
+
+// Battleground Extended by Vykimo
+ACMD_FUNC(bgstart) {
+	
+	nullpo_retr(-1, sd);
+	
+	if (bg_flag) {
+		clif_displaymessage(fd, "Battleground is currently in progress.");
+		return -1;
+	}
+
+	bg_flag = true;
+	bg_start();
+	clif_displaymessage(fd, "Battleground has been initiated");
+
+	return 0;
+}
+
+ACMD_FUNC(bgend) {
+	
+	nullpo_retr(-1, sd);
+	
+	if (!bg_flag) {
+		clif_displaymessage(fd, "Battleground is currently not in progress.");
+		return -1;
+	}
+
+	bg_flag = false;
+	bg_end();
+	clif_displaymessage(fd, "Battleground has been ended.");
+
+	return 0;
+}
+
+ACMD_FUNC(listenbg)
+{
+	sd->state.bg_listen = (sd->state.bg_listen == 0);
+	
+	if( sd->state.bg_listen )
+		clif_displaymessage(fd, "You will receive Battleground announcements.");
+	else
+		clif_displaymessage(fd, "You will not receive Battleground announcements.");
+
+	return 0;
+}
+
+ACMD_FUNC(order)
+{
+	char tempmes[CHAT_SIZE_MAX];
+	nullpo_retr(-1,sd);
+
+	memset(tempmes, '\0', sizeof(tempmes));
+	memset(atcmd_output, '\0', sizeof(atcmd_output));
+
+	if( !message || !*message || sscanf(message, "%255[^\n]", tempmes) < 0)
+	{
+		clif_displaymessage(fd, "Please, enter a message (usage: @order <message>).");
+		return -1;
+	}
+	
+
+	if( map_getmapflag(sd->bl.m, MF_BATTLEGROUND) )
+	{
+		if( !sd->bmaster_flag )
+		{
+			clif_displaymessage(fd, "This command is reserved for Team Leaders Only.");
+			return -1;
+		}
+		sprintf(atcmd_output, msg_txt(sd,270), "[BG Order]", tempmes);	// *%s %s*
+		clif_broadcast2(&sd->bl, atcmd_output, (int)strlen(atcmd_output)+1, sd->bmaster_flag->color, 0x190, 20, 0, 0, BG);
+	}
+	else
+	{
+		if( !sd->state.gmaster_flag )
+		{
+			clif_displaymessage(fd, "This command is reserved for Guild Leaders Only.");
+			return -1;
+		}
+		sprintf(atcmd_output, msg_txt(sd,270), "[WOE Order]", tempmes);	// *%s %s*
+		clif_broadcast2(&sd->bl, atcmd_output, (int)strlen(atcmd_output)+1, 0xFF0000, 0x190, 20, 0, 0, GUILD);
+	}
+
+	return 0;
+}
+ACMD_FUNC(leader)
+{
+	struct map_session_data *pl_sd;
+	nullpo_retr(-1,sd);
+	if( !sd->bmaster_flag )
+		clif_displaymessage(fd, "This command is reserved for Team Leaders Only.");
+	else if( sd->ud.skilltimer != INVALID_TIMER )
+		clif_displaymessage(fd, "Command not allow while casting a skill.");
+	else if( !message || !*message )
+		clif_displaymessage(fd, "Please, enter the new Leader name (usage: @leader <name>).");
+	else if( (pl_sd = map_nick2sd((char *)message,false)) == NULL )
+		clif_displaymessage(fd, msg_txt(sd,3)); // Character not found.
+	else if( sd->bg_id != pl_sd->bg_id )
+		clif_displaymessage(fd, "Destination Player is not in your Team.");
+	else if( sd == pl_sd )
+		clif_displaymessage(fd, "You are already the Team Leader.");
+	else
+	{ // Everytest OK!
+		sprintf(atcmd_output, "Team Leader transfered to [%s]", pl_sd->status.name);
+		clif_broadcast2(&sd->bl, atcmd_output, (int)strlen(atcmd_output)+1, sd->bmaster_flag->color, 0x190, 20, 0, 0, BG);
+
+		sd->bmaster_flag->leader_char_id = pl_sd->status.char_id;
+		pl_sd->bmaster_flag = sd->bmaster_flag;
+		sd->bmaster_flag = NULL;
+
+		clif_name_area(&sd->bl);
+		clif_name_area(&pl_sd->bl);
+		return 0;
+	}
+	return -1;
+}
+
+ACMD_FUNC(reportafk)
+{
+	struct map_session_data *pl_sd;
+	nullpo_retr(-1,sd);
+	if( !sd->bg_id )
+		clif_displaymessage(fd, "This command is reserved for Battleground Only.");
+	else if( !sd->bmaster_flag && battle_config.bg_reportafk_leaderonly )
+		clif_displaymessage(fd, "This command is reserved for Team Leaders Only.");
+	else if( !message || !*message )
+		clif_displaymessage(fd, "Please, enter the character name (usage: @reportafk/votekick <name>).");
+	else if( (pl_sd = map_nick2sd((char *)message,false)) == NULL )
+		clif_displaymessage(fd, msg_txt(sd,3)); // Character not found.
+	else if( sd->bg_id != pl_sd->bg_id )
+		clif_displaymessage(fd, "Destination Player is not in your Team.");
+	else if( sd == pl_sd )
+		clif_displaymessage(fd, "You cannot kick yourself.");
+	else if( pl_sd->state.bg_afk == 0 )
+		clif_displaymessage(fd, "The player is not AFK on this Battleground.");
+	else
+	{ // Everytest OK!
+		std::shared_ptr<s_battleground_data> bg = util::umap_find(bg_team_db, sd->bg_id);
+		if( !bg )
+			return -1;
+
+		bg_team_leave(pl_sd, false, true, 2);
+		clif_displaymessage(pl_sd->fd, "You have been kicked from Battleground because of your AFK status.");
+		pc_setpos(pl_sd,pl_sd->status.save_point.map,pl_sd->status.save_point.x,pl_sd->status.save_point.y,CLR_TELEPORT);
+		clif_refresh(pl_sd);
+
+		sprintf(atcmd_output, "- AFK [%s] Kicked -", pl_sd->status.name);
+		clif_broadcast2(&sd->bl, atcmd_output, (int)strlen(atcmd_output)+1, bg->color, 0x190, 20, 0, 0, BG);
+		return 0;
+	}
+	return -1;
+}
+/*==========================================
+ * Guild Skill Usage for Guild Masters
+ *------------------------------------------*/
+ACMD_FUNC(guildskill)
+{
+	int i, skillnum = 0, skilllv = 0;
+	t_tick tick = gettick();
+
+	const struct { char skillstr[3]; int id; } skills[] = {
+		{ "BO",	10010 },
+		{ "RG",	10011 },
+		{ "RS",	10012 },
+		{ "EC",	10013 },
+	};
+
+	// Check for Skill ID
+	for( i = 0; i < ARRAYLENGTH(skills); i++ )
+	{
+		if( strncmpi(message, skills[i].skillstr, 3) == 0 )
+		{
+			skillnum = skills[i].id;
+			break;
+		}
+	}
+	if( !skillnum )
+	{
+		clif_displaymessage(fd, "Invalid Skill string. Use @guildskill EC/RS/RG/BO");
+		return -1;
+	}
+
+	if( !map_getmapflag(sd->bl.m, MF_BATTLEGROUND) ) {
+		if( sd->state.gmaster_flag )
+			skilllv = guild_checkskill(sd->guild, skillnum);
+		else {
+			clif_displaymessage(fd, "This command is reserved for Guild Leaders Only.");
+			return -1;
+		}
+	} else {
+		std::shared_ptr<s_battleground_data> bg;
+		if( (bg = sd->bmaster_flag) != NULL )
+			skilllv = bg_checkskill(bg, skillnum);
+		else {
+			clif_displaymessage(fd, "This command is reserved for Team Leaders Only.");
+			return -1;
+		}
+	}
+
+	if( pc_cant_act(sd) || pc_issit(sd) || skill_isNotOk(skillnum, sd) || sd->ud.skilltimer != -1 || sd->sc.option&(OPTION_WEDDING|OPTION_XMAS|OPTION_SUMMER) || sd->state.only_walk || sd->sc.data[SC_BASILICA] )
+		return -1;
+
+	if( DIFF_TICK(tick, sd->ud.canact_tick) < 0 )
+		return -1;
+
+	if( sd->menuskill_id )
+	{
+		if( sd->menuskill_id == SA_TAMINGMONSTER )
+			sd->menuskill_id = sd->menuskill_val = 0; //Cancel pet capture.
+		else if( sd->menuskill_id != SA_AUTOSPELL )
+			return -1; //Can't use skills while a menu is open.
+	}
+
+	sd->skillitem = sd->skillitemlv = 0;
+	if( skilllv ) unit_skilluse_id(&sd->bl, sd->bl.id, skillnum, skilllv);
+	return 0;
+}
+
+ACMD_FUNC(voteleader)
+{
+	struct map_session_data* pl_sd;
+	nullpo_retr(-1, sd);
+	if (sd->ud.skilltimer != INVALID_TIMER)
+		clif_displaymessage(fd, "Command not allow while casting a skill.");
+	else if (!sd->bg_id)
+		clif_displaymessage(fd, "You should be in a Battelground in order to use the command.");
+	else if (!message || !*message)
+		clif_displaymessage(fd, "Please, enter the new Leader name (usage: @voteleader <name>).");
+	else if ((pl_sd = map_nick2sd((char*)message, false)) == NULL)
+		clif_displaymessage(fd, msg_txt(sd, 3)); // Character not found.
+	else if (sd->bg_id != pl_sd->bg_id)
+		clif_displaymessage(fd, "Destination Player is not in your Team.");
+	else
+	{ // Everytest OK!
+
+		std::map<map_session_data*, map_session_data*>::iterator it;
+		std::shared_ptr<s_battleground_data> bgteam = util::umap_find(bg_team_db, sd->bg_id);
+
+		it = bgteam->voteleader.find(sd);
+		if (it != bgteam->voteleader.end())
+			bgteam->voteleader.erase(it);
+		
+		bgteam->voteleader.insert( std::pair<map_session_data*, map_session_data*> (sd, pl_sd));
+		
+		clif_displaymessage(fd, "Your vote for leadership was counted successfully");
+		
+		 if ((battle_config.bg_min_vote_leader > 0 && bgteam->voteleader.size() >= battle_config.bg_min_vote_leader) || bgteam->voteleader.size() >= bgteam->members.size()) {
+			 struct map_session_data* leader_sd;
+			 struct map_session_data* old_leader_sd;
+			 int max_counter = 0;
+
+			 for (auto& b : bgteam->members)
+			 {
+				 if (b.sd->bmaster_flag) {
+					 old_leader_sd = b.sd;
+					 break;
+				 }
+			 }
+			 for (auto const& b : bgteam->voteleader)
+			 {
+				 int count = 0;
+				 for (auto const& p : bgteam->voteleader) count += p.second == b.second;
+				 if (count >= max_counter) {
+					 max_counter = count;
+					 leader_sd = b.second;
+				 }
+			 }
+			 bgteam->voteleader.clear();
+			 if (leader_sd && old_leader_sd) {
+				 sprintf(atcmd_output, "Team %d Leader transfered from [%s] to [%s]", bgteam->id, old_leader_sd->status.name, leader_sd->status.name);
+				 clif_broadcast2(&old_leader_sd->bl, atcmd_output, (int)strlen(atcmd_output) + 1, bgteam->color, 0x190, 20, 0, 0, BG);
+
+				 if (leader_sd != old_leader_sd) {
+					 old_leader_sd->bmaster_flag->leader_char_id = leader_sd->status.char_id;
+					 leader_sd->bmaster_flag = old_leader_sd->bmaster_flag;
+					 old_leader_sd->bmaster_flag = NULL;
+
+					 clif_name_area(&old_leader_sd->bl);
+					 clif_name_area(&leader_sd->bl);
+				 }
+			 }
+		 }
+		 else {
+
+			 sprintf(atcmd_output, "[%d/%d] voted to change Team %d Leader, vote with @voteleader <char name>", bgteam->voteleader.size(), (battle_config.bg_min_vote_leader > 0) ? battle_config.bg_min_vote_leader : bgteam->members.size(), bgteam->id);
+			 clif_broadcast2(&sd->bl, atcmd_output, (int)strlen(atcmd_output) + 1, bgteam->color, 0x190, 20, 0, 0, BG);
+		 }
+		 return 0;
+	}
+	return -1;
+}
diff --git a/src/custom/atcommand_def.inc b/src/custom/atcommand_def.inc
index 54d9e74ba..8485ce1ac 100644
--- a/src/custom/atcommand_def.inc
+++ b/src/custom/atcommand_def.inc
@@ -9,3 +9,14 @@
  **/
 
 //ACMD_DEF(newcommand),
+
+// Battleground Extended by Vykimo
+ACMD_DEF(bgstart),
+ACMD_DEF(bgend),
+ACMD_DEF(guildskill),
+ACMD_DEF(listenbg),
+ACMD_DEF(order),
+ACMD_DEF(leader),
+ACMD_DEF(voteleader),
+ACMD_DEF(reportafk),
+ACMD_DEF2("votekick", reportafk),
diff --git a/src/custom/battle_config_init.inc b/src/custom/battle_config_init.inc
index e47aca9be..b755692bc 100644
--- a/src/custom/battle_config_init.inc
+++ b/src/custom/battle_config_init.inc
@@ -11,3 +11,15 @@
  *	 { "name", &battle_config.<variable name>, <default value>, <minimum value>, <maximum value> },
  **/
 
+	{ "bg_reward_rates",                    &battle_config.bg_reward_rates,                 100,    0,      INT_MAX,        },
+	{ "bg_reportafk_leaderonly",            &battle_config.bg_reportafk_leaderonly,         1,      0,      1,              },
+	{ "bg_idle_announce",                   &battle_config.bg_idle_announce,                0,      0,      INT_MAX,        },
+	{ "bg_idle_autokick",                   &battle_config.bg_idle_autokick,                0,      0,      INT_MAX,        },
+	{ "bg_queue_onlytowns",                 &battle_config.bg_queue_onlytowns,              1,      0,      1,              },
+	{ "bg_logincount_check",                &battle_config.bg_logincount_check,             1,      0,      1,              },
+	{ "bg_queue2team_balanced",             &battle_config.bg_queue2team_balanced,          1,      0,      1,              },
+	{ "bg_reserved_char_id",                &battle_config.bg_reserved_char_id,             999996, 0,      INT_MAX,        },
+	{ "woe_reserved_char_id",               &battle_config.woe_reserved_char_id,            999999, 0,      INT_MAX,        },
+	{ "bg_invincible_time",                 &battle_config.bg_invincible_time,              5000,   0,      INT_MAX,        },
+	{ "bg_mode_selection",                  &battle_config.bg_mode_selection,               0,      0,      1,              },
+	{ "bg_min_vote_leader",                 &battle_config.bg_min_vote_leader,              0,      0,      INT_MAX,        },
diff --git a/src/custom/battle_config_struct.inc b/src/custom/battle_config_struct.inc
index 017d99d07..f21f842d1 100644
--- a/src/custom/battle_config_struct.inc
+++ b/src/custom/battle_config_struct.inc
@@ -12,3 +12,6 @@
  *	 <datatype> name;
  **/
 
+	int bg_reserved_char_id;
+	int woe_reserved_char_id;
+	int bg_min_vote_leader;
diff --git a/src/custom/script.inc b/src/custom/script.inc
index 839b990cb..4692607b6 100644
--- a/src/custom/script.inc
+++ b/src/custom/script.inc
@@ -17,3 +17,849 @@
 //	script_pushint(st,1);
 //	return 0;
 //}
+BUILDIN_FUNC(bg_move_queue)
+{
+	const char*  from_bg_name = script_getstr(st,2);
+	const char* target_bg_name = script_getstr(st,3);
+	bg_move_team_queue(from_bg_name, target_bg_name);
+	return SCRIPT_CMD_SUCCESS;
+}
+
+BUILDIN_FUNC(bgcheck) {
+	script_pushint(st,bg_flag);
+	return SCRIPT_CMD_SUCCESS;
+}
+
+BUILDIN_FUNC(bgstart) {
+	if (bg_flag)
+		return SCRIPT_CMD_SUCCESS;
+	bg_flag = true;
+	bg_start();
+
+	return SCRIPT_CMD_SUCCESS;
+}
+
+BUILDIN_FUNC(bgend) {
+	if (!bg_flag)
+		return SCRIPT_CMD_SUCCESS;// Agit already Ended.
+	bg_flag = false;
+	bg_end();
+	
+	return SCRIPT_CMD_SUCCESS;
+}
+/// for bg
+BUILDIN_FUNC(bg_flagemblem) {
+	TBL_NPC* nd;
+	int g_id = script_getnum(st,2);
+
+	if( script_hasdata(st,3) )
+		nd = npc_name2id(script_getstr(st,3));
+	else
+		nd = map_id2nd(st->oid);
+
+	if(g_id < 0) return true;
+	if( nd == NULL ) {
+		ShowError("script:flagemblem: npc %d not found\n", st->oid);
+	} else if( nd->subtype != NPCTYPE_SCRIPT ) {
+		ShowError("script:flagemblem: unexpected subtype %d for npc %d '%s'\n", nd->subtype, st->oid, nd->exname);
+	} else {
+		std::shared_ptr<s_battleground_data> bgd = util::umap_find(bg_team_db, g_id);
+		if(bgd) {
+			bool changed;
+			g_id = (bgd->g->guild_id);
+			changed = ( nd->u.scr.guild_id != g_id )?true:false;
+			nd->u.scr.guild_id = g_id;
+			clif_guild_emblem_area(&nd->bl);
+			
+			/* guild flag caching */
+			if( g_id ) /* adding a id */
+				guild_flag_add(nd);
+			else if( changed ) /* removing a flag */
+				guild_flag_remove(nd);
+		}
+	}
+	return SCRIPT_CMD_SUCCESS;
+}
+BUILDIN_FUNC(pcblock)
+{
+	int id = 0, flag, type;
+	TBL_PC *sd = NULL;
+
+	type = script_getnum(st,2);
+	flag = script_getnum(st,3);
+	if( script_hasdata(st,4) )
+		id = script_getnum(st,4);
+
+	if( id && (sd = map_id2sd(id)) == NULL )
+		return SCRIPT_CMD_SUCCESS;
+	else
+		script_rid2sd(sd);
+
+	if( sd == NULL )
+		return SCRIPT_CMD_SUCCESS;
+
+	switch( type )
+	{
+		case 0: sd->ud.state.blockedmove = flag > 0; break;
+		case 1: 
+			sd->state.only_walk = flag > 0; 
+			sd->ud.state.blockedskill = flag > 0; 
+			pc_stop_attack(sd); //Stop attacking
+			break;
+	}
+ 
+	return SCRIPT_CMD_SUCCESS;
+}
+int viewpointmap_sub(struct block_list *bl, va_list ap)
+{
+	struct map_session_data *sd;
+	int npc_id, type, x, y, id, color;
+	npc_id = va_arg(ap,int);
+	type = va_arg(ap,int);
+	x = va_arg(ap,int);
+	y = va_arg(ap,int);
+	id = va_arg(ap,int);
+	color = va_arg(ap,int);
+	sd = (struct map_session_data *)bl;
+	clif_viewpoint(sd,npc_id,type,x,y,id,color);
+	return 0;
+}
+
+BUILDIN_FUNC(viewpointmap)
+{
+	int type,x,y,id,color,m;
+	const char *map_name;
+
+	map_name = script_getstr(st,2);
+	if( (m = map_mapname2mapid(map_name)) < 0 )
+		return 0; // Invalid Map
+
+	type=script_getnum(st,3);
+	x=script_getnum(st,4);
+	y=script_getnum(st,5);
+	id=script_getnum(st,6);
+	color=script_getnum(st,7);
+
+	map_foreachinmap(viewpointmap_sub,m,BL_PC,st->oid,type,x,y,id,color);
+	return 0;
+}
+BUILDIN_FUNC(checkspace)
+{
+	int nameid = 0, amount;
+	struct map_session_data *sd;
+
+	if( !script_rid2sd(sd) )
+		script_pushint(st,0);
+	else if( sd->storage.amount > MAX_STORAGE )
+		script_pushint(st,0); // Storage at max
+	else
+	{
+		struct script_data *data = script_getdata(st,2);
+		struct item_data *id;
+		struct item it;
+		int i;
+
+		get_val(st,data);
+		if( data_isstring(data) )
+		{
+			const char *name = conv_str(st,data);
+			std::shared_ptr<item_data> id = item_db.searchname( name );
+			if( id )
+				nameid = id->nameid;
+		}
+		else
+			nameid = conv_num(st,data);
+
+		memset(&it,0,sizeof(it));
+		amount = script_getnum(st,3);
+		it.nameid = nameid;
+		it.identify = script_getnum(st,4);
+		it.refine = script_getnum(st,5);
+		it.attribute = script_getnum(st,6);
+		it.card[0] = (short)script_getnum(st,7);
+		it.card[1] = (short)script_getnum(st,8);
+		it.card[2] = (short)script_getnum(st,9);
+		it.card[3] = (short)script_getnum(st,10);
+
+		if( nameid < 500 || amount <= 0 || (id = itemdb_exists(nameid)) == NULL || !itemdb_canstore(&it, pc_get_group_level(sd)) || !itemdb_isstackable2(id) )
+		{
+			script_pushint(st,0);
+			return 0;
+		}
+
+		if( itemdb_isstackable2(id) )
+		{
+			ARR_FIND(0,MAX_STORAGE,i,compare_item(&sd->storage.u.items_storage[i],&it,0));
+			if( i < MAX_STORAGE )
+			{ // Item on Storage
+				script_pushint(st,amount + sd->storage.u.items_storage[i].amount > MAX_AMOUNT ? 0 : 1);
+				return 0;
+			}
+		}
+
+		ARR_FIND(0,MAX_STORAGE,i,sd->storage.u.items_storage[i].nameid == 0);
+		if( i >= MAX_STORAGE )
+		{
+			script_pushint(st,0);
+			return 0;
+		}
+	
+		script_pushint(st,1); // Can be Stored
+	}
+
+	return 0;
+}
+
+BUILDIN_FUNC(storeitem)
+{
+	int nameid = 0, amount;
+	struct item it;
+	struct map_session_data *sd;
+	struct script_data *data;
+	int result = 1;
+
+	data = script_getdata(st,2);
+	get_val(st,data);
+	if( data_isstring(data) )
+	{ // "<item name>"
+		const char *name = conv_str(st,data);
+		std::shared_ptr<item_data> item_data = item_db.searchname( name );
+		if( item_data == nullptr )
+		{
+			ShowError("buildin_storeitem: Nonexistant item %s requested.\n", name);
+			result = 0; //No item created.
+		}
+		else
+			nameid = item_data->nameid;
+	}
+	else if( data_isint(data) )
+	{ // <item id>
+		nameid = conv_num(st,data);
+		if( nameid <= 0 || !itemdb_exists(nameid) )
+		{
+			ShowError("buildin_storeitem: Nonexistant item %d requested.\n", nameid);
+			result = 0;
+		}
+	}
+	else
+	{
+		ShowError("buildin_storeitem: invalid data type for argument #1 (%d).", data->type);
+		result = 0;
+	}
+
+	if( !itemdb_isstackable(nameid) )
+		result = 0;
+	if( (amount = script_getnum(st,3)) <= 0 )
+		result = 0;
+
+	if( script_hasdata(st,4) )
+		sd = map_id2sd(script_getnum(st,4)); // <Account ID>
+	else
+		script_rid2sd(sd); // Attached player
+
+	if( sd == NULL ) // no target
+		result = 0;
+
+	if( result )
+	{
+		memset(&it,0,sizeof(it));
+		it.nameid = nameid;
+		it.identify = 1;
+		if( storage_storageopen(sd) == 1 ) {
+			result = 0;
+		} else {
+			result = storage_additem2(sd,&it,amount);
+			storage_storageclose(sd);
+			if( result )
+				log_pick_pc(sd, LOG_TYPE_SCRIPT, amount, &it);
+		}
+	}
+
+	script_pushint(st,result);
+	return 0;
+}
+
+BUILDIN_FUNC(storeitem2)
+{
+	int nameid = 0, amount = 0;
+	int iden = 0,ref = 0,attr = 0,c1 = 0,c2 = 0,c3 = 0,c4 = 0;
+	struct map_session_data *sd;
+	struct script_data *data;
+	struct item it;
+	int result = 1;
+
+	data = script_getdata(st,2);
+	get_val(st,data);
+	if( data_isstring(data) )
+	{
+		const char *name = conv_str(st,data);
+		std::shared_ptr<item_data> item_data = item_db.searchname( name );
+		if( item_data == nullptr )
+		{
+			ShowError("buildin_storeitem2: Nonexistant item %s requested.\n", name);
+			result = 0;
+		}
+		else
+			nameid = item_data->nameid;
+	}
+	else if( data_isint(data) )
+	{
+		nameid = conv_num(st,data);
+		if( nameid <= 0 || !itemdb_exists(nameid) )
+		{
+			ShowError("buildin_storeitem2: Nonexistant item %d requested.\n", nameid);
+			result = 0;
+		}
+	}
+	else
+	{
+		ShowError("buildin_storeitem2: invalid data type for argument #1 (%d).", data->type);
+		result = 0;
+	}
+
+	if( !itemdb_isstackable(nameid) )
+		result = 0;
+	else if( (amount = script_getnum(st,3)) <= 0 )
+		result = 0;
+	else
+	{
+		iden = script_getnum(st,4);
+		ref = script_getnum(st,5);
+		attr = script_getnum(st,6);
+		c1 = (short)script_getnum(st,7);
+		c2 = (short)script_getnum(st,8);
+		c3 = (short)script_getnum(st,9);
+		c4 = (short)script_getnum(st,10);
+	}
+
+	if( script_hasdata(st,11) )
+		sd = map_id2sd(script_getnum(st,11));
+	else
+		script_rid2sd(sd);
+
+	if( sd == NULL )
+		result = 0;
+
+	if( result )
+	{
+		memset(&it,0,sizeof(it));
+		it.nameid = nameid;
+		it.identify = 1; // always Identify
+		it.refine = ref;
+		it.attribute = attr;
+		it.card[0] = (short)c1;
+		it.card[1] = (short)c2;
+		it.card[2] = (short)c3;
+		it.card[3] = (short)c4;
+		if( storage_storageopen(sd) == 1 ) {
+			result = 0;
+		} else {
+			result = storage_additem2(sd,&it,amount);
+			storage_storageclose(sd);
+			if( result )
+				log_pick_pc(sd, LOG_TYPE_SCRIPT, amount, &it);
+		}
+	}
+	script_pushint(st,result);
+	return 0;
+}
+
+/*==========================================
+ * itembound <item id>,<amount>{,<character ID>};
+ * itembound "<item name>",<amount>{,<character ID>};
+ *------------------------------------------*/
+BUILDIN_FUNC(itembound)
+{
+	int nameid,amount,i,flag;
+	struct item it;
+	TBL_PC *sd;
+	struct script_data *data;
+
+	data=script_getdata(st,2);
+	get_val(st,data);
+	if( data_isstring(data) )
+	{ // "<item name>"
+		const char *name=conv_str(st,data);
+		std::shared_ptr<item_data> item_data = item_db.searchname( name );
+		if( item_data == nullptr ){
+			ShowError("buildin_itembound: Nonexistant item %s requested.\n", name);
+			return 1; //No item created.
+		}
+		nameid=item_data->nameid;
+	}
+	else if( data_isint(data) )
+	{ // <item id>
+		nameid=conv_num(st,data);
+		if( nameid <= 0 || !itemdb_exists(nameid) )
+		{
+			ShowError("buildin_getitem: Nonexistant item %d requested.\n", nameid);
+			return 1; //No item created.
+		}
+	}
+	else
+	{
+		ShowError("buildin_itembound: invalid data type for argument #1 (%d).", data->type);
+		return 1;
+	}
+
+	if( itemdb_isstackable(nameid) || itemdb_type(nameid) == IT_PETEGG )
+	{
+		ShowError("buildin_itembound: invalid item type. Bound only work for non stackeable items (Item %d).", nameid);
+		return 1;
+	}
+
+	// <amount>
+	if( (amount=script_getnum(st,3)) <= 0)
+		return 0; //return if amount <=0, skip the useles iteration
+
+	memset(&it,0,sizeof(it));
+	it.nameid = nameid;
+	it.bound = 1;
+	it.identify = 1;
+
+	if( script_hasdata(st,4) )
+		sd = map_id2sd(script_getnum(st,4)); // <Account ID>
+	else
+		script_rid2sd(sd); // Attached player
+
+	if( sd == NULL ) // no target
+		return 0;
+
+	for( i = 0; i < amount; i++ )
+	{
+		if( (flag = pc_additem(sd, &it, 1, LOG_TYPE_SCRIPT)) )
+		{
+			clif_additem(sd, 0, 0, flag);
+			if( pc_candrop(sd,&it) )
+				map_addflooritem(&it,1,sd->bl.m,sd->bl.x,sd->bl.y,0,0,0,0,0);
+		}
+	}
+
+	return 0;
+}
+
+BUILDIN_FUNC(itembound2)
+{
+	int nameid,amount,i,flag;
+	int iden,ref,attr,c1,c2,c3,c4;
+	std::shared_ptr<item_data> item_data;
+	struct item item_tmp;
+	TBL_PC *sd;
+	struct script_data *data;
+
+	if( script_hasdata(st,11) )
+		sd = map_id2sd(script_getnum(st,11)); // <Account ID>
+	else
+		script_rid2sd(sd); // Attached player
+
+	if( sd == NULL ) // no target
+		return 0;
+
+	data = script_getdata(st,2);
+	get_val(st,data);
+	if( data_isstring(data) )
+	{
+		const char *name = conv_str(st,data);
+		item_data = item_db.searchname( name );
+		if( item_data != nullptr )
+			nameid = item_data->nameid;
+		else
+			nameid = UNKNOWN_ITEM_ID;
+	}
+	else
+		nameid = conv_num(st,data);
+
+	amount = script_getnum(st,3);
+	iden = script_getnum(st,4);
+	ref = script_getnum(st,5);
+	attr = script_getnum(st,6);
+	c1 = (short)script_getnum(st,7);
+	c2 = (short)script_getnum(st,8);
+	c3 = (short)script_getnum(st,9);
+	c4 = (short)script_getnum(st,10);
+	
+	if( nameid < 0 || (item_data = item_db.find(nameid)) == nullptr || itemdb_isstackable2( item_data.get() ) )
+		return 0;
+
+	memset(&item_tmp,0,sizeof(item_tmp));
+	item_tmp.nameid = nameid;
+	if( item_data->type == IT_WEAPON || item_data->type == IT_ARMOR )
+		ref = cap_value(ref,0,MAX_REFINE);
+	else if( item_data->type == IT_PETEGG )
+	{
+		ShowError("buildin_itembound2: invalid item type. Pet Egg cannot be set as rental items.\n");
+		return 1;
+	}
+	else
+	{ // Should not happen
+		iden = 1;
+		ref = attr = 0;
+	}
+
+	item_tmp.identify = iden;
+	item_tmp.refine = ref;
+	item_tmp.attribute = attr;
+	item_tmp.card[0] = (short)c1;
+	item_tmp.card[1] = (short)c2;
+	item_tmp.card[2] = (short)c3;
+	item_tmp.card[3] = (short)c4;
+	item_tmp.bound = 1;
+
+	for( i = 0; i < amount; i++ )
+	{
+		if ((flag = pc_additem(sd, &item_tmp, 1, LOG_TYPE_SCRIPT)))
+		{
+			clif_additem(sd, 0, 0, flag);
+			if( pc_candrop(sd,&item_tmp) )
+				map_addflooritem(&item_tmp,1,sd->bl.m,sd->bl.x,sd->bl.y,0,0,0,0,0);
+		}
+	}
+
+	return 0;
+}
+/*
+ *==========================================
+ */
+BUILDIN_FUNC(countstorageitem) {
+	TBL_PC* sd = NULL;
+	int i, type, count = 0;
+	struct item_data* item_data;
+	struct s_storage* gstor;
+	struct s_storage* stor;
+	struct item tmp_it;
+	type = script_getnum(st, 2);
+	if (script_hasdata(st, 11))
+		map_id2sd(script_getnum(st, 11));
+	else
+		script_rid2sd(sd);
+	if (!sd) return SCRIPT_CMD_SUCCESS;
+	if (sd != NULL && (item_data = itemdb_exists(script_getnum(st, 3))) != NULL) {
+		tmp_it.nameid = item_data->nameid;
+		tmp_it.identify = script_getnum(st, 4);
+		tmp_it.refine = script_getnum(st, 5);
+		tmp_it.attribute = script_getnum(st, 6);
+		tmp_it.card[0] = script_getnum(st, 7);
+		tmp_it.card[1] = script_getnum(st, 8);
+		tmp_it.card[2] = script_getnum(st, 9);
+		tmp_it.card[3] = script_getnum(st, 10);
+
+		switch (type) {
+		case 0:
+			stor = &sd->storage;
+			if (stor == NULL) {
+				return SCRIPT_CMD_SUCCESS;
+			}
+			if (sd->state.storage_flag) {
+				if (sd->state.storage_flag == 1) {
+					sd->state.storage_flag = 0;
+					storage_storageclose(sd);
+				}
+				else {
+					sd->state.storage_flag = 0;
+					storage_guild_storageclose(sd);
+				}
+			}
+			sd->state.storage_flag = 1;
+			for (i = 0; i < MAX_STORAGE; i++) {
+				if ((&stor->u.items_storage[i] != NULL)
+					&& stor->u.items_storage[i].amount > 0
+					&& compare_item(&stor->u.items_storage[i], &tmp_it, 1))
+					count += stor->u.items_storage[i].amount;
+			}
+			sd->state.storage_flag = 0;
+			storage_storageclose(sd);
+			script_pushint(st, count);
+			break;
+		case 1:
+			if (sd->status.guild_id && (gstor = guild2storage2(sd->status.guild_id))) {
+				for (i = 0; i < MAX_GUILD_STORAGE; i++) {
+					if ((&gstor->u.items_storage[i] != NULL)
+						&& gstor->u.items_storage[i].amount > 0
+						&& compare_item(&gstor->u.items_storage[i], &tmp_it, 1)
+						)
+						count += gstor->u.items_storage[i].amount;
+				}
+				script_pushint(st, count);
+			}
+			break;
+		default:
+			ShowError("Invalid type specified in countstorageitem");
+			script_pushint(st, -1);
+			return SCRIPT_CMD_FAILURE;
+		}
+	}
+	return SCRIPT_CMD_SUCCESS;
+}
+/*==========================================
+ * inv2stor,item_id,item_nb,attribute,refine,identify,c0,c1,c2,c3{,charid}
+ *------------------------------------------*/
+BUILDIN_FUNC(inv2stor) {
+	TBL_PC* sd = NULL;
+	int i;
+	struct item_data* item_data;
+	struct item tmp_it;
+	int item_id = script_getnum(st, 2);
+	int item_nb = script_getnum(st, 3);
+	if (script_hasdata(st, 11))
+		map_id2sd(script_getnum(st, 11));
+	else
+		script_rid2sd(sd);
+
+	nullpo_ret(sd);
+
+	if ((item_data = itemdb_exists(item_id)) != NULL) {
+		tmp_it.nameid = item_data->nameid;
+		tmp_it.identify = script_getnum(st, 4);
+		tmp_it.refine = script_getnum(st, 5);
+		tmp_it.attribute = script_getnum(st, 6);
+		tmp_it.card[0] = script_getnum(st, 7);
+		tmp_it.card[1] = script_getnum(st, 8);
+		tmp_it.card[2] = script_getnum(st, 9);
+		tmp_it.card[3] = script_getnum(st, 10);
+
+		ARR_FIND(0, MAX_INVENTORY, i, ((&sd->inventory.u.items_inventory[i] != NULL)
+			&& compare_item(&sd->inventory.u.items_inventory[i], &tmp_it, 1)));
+		if (i < MAX_INVENTORY) {
+			storage_storageadd(sd, &sd->storage, i, item_nb);
+			storage_storageclose(sd);
+		}
+	}
+	script_pushint(st, 1);
+	return SCRIPT_CMD_SUCCESS;
+}
+
+/*==========================================
+ * inv2stor,item_id,item_nb,attribute,refine,identify,c0,c1,c2,c3{,charid}
+*------------------------------------------*/
+BUILDIN_FUNC(stor2inv) {
+	TBL_PC* sd = NULL;
+	int i;
+	struct item_data* item_data;
+	struct item tmp_it;
+	int item_id = script_getnum(st, 2);
+	int item_nb = script_getnum(st, 3);
+
+	if (script_hasdata(st, 11))
+		map_id2sd(script_getnum(st, 11));
+	else
+		script_rid2sd(sd);
+	nullpo_ret(sd);
+
+	if ((item_data = itemdb_exists(item_id)) != NULL) {
+		tmp_it.nameid = item_data->nameid;
+		tmp_it.identify = script_getnum(st, 4);
+		tmp_it.refine = script_getnum(st, 5);
+		tmp_it.attribute = script_getnum(st, 6);
+		tmp_it.card[0] = script_getnum(st, 7);
+		tmp_it.card[1] = script_getnum(st, 8);
+		tmp_it.card[2] = script_getnum(st, 9);
+		tmp_it.card[3] = script_getnum(st, 10);
+		ARR_FIND(0, MAX_STORAGE, i, ((&sd->storage.u.items_storage[i] != NULL)
+			&& compare_item(&sd->storage.u.items_storage[i], &tmp_it, 1))
+		);
+		if (i < MAX_STORAGE) {
+			storage_storageget(sd, &sd->storage, i, item_nb);
+		}
+	}
+	script_pushint(st, 1);
+	return SCRIPT_CMD_SUCCESS;
+}
+
+BUILDIN_FUNC(unitisfighting)
+{
+	struct block_list* bl;
+	struct unit_data *ud;
+
+	if (script_rid2bl(2, bl)) {
+		ud = unit_bl2ud(bl);
+		script_pushint(st, (ud->attacktimer != INVALID_TIMER));
+	} else
+		script_pushint(st, 0);
+	
+	return SCRIPT_CMD_SUCCESS;
+}
+
+BUILDIN_FUNC(bg_getitem)
+{
+	int bg_id, nameid, amount;
+
+	bg_id = script_getnum(st,2);
+	nameid = script_getnum(st,3);
+	amount = script_getnum(st,4);
+
+	bg_team_getitem(bg_id, nameid, amount);
+	return SCRIPT_CMD_SUCCESS;
+}
+BUILDIN_FUNC(bg_reward)
+{
+	int team_id, nameid, amount, kafrapoints, quest_id, add_value, bg_arena;
+	const char *var;
+	
+	team_id = script_getnum(st,2);
+	nameid = script_getnum(st,3);
+	amount = script_getnum(st,4);
+	kafrapoints = script_getnum(st,5);
+	quest_id = script_getnum(st,6);
+	var = script_getstr(st,7);
+	add_value = script_getnum(st,8);
+	bg_arena = script_getnum(st,9);
+
+	bg_team_rewards(team_id, nameid, amount, kafrapoints, quest_id, var, add_value, bg_arena);
+	return SCRIPT_CMD_SUCCESS;
+}
+
+BUILDIN_FUNC(bg_reward_all)
+{
+	int team_id1, team_id2, nameid, amount, bg_result;
+	const char *bg_map;
+	
+	bg_map = script_getstr(st,2);
+	team_id1 = script_getnum(st,3);
+	team_id2 = script_getnum(st,4);
+	nameid = script_getnum(st,5);
+	amount = script_getnum(st,6);
+	bg_result = script_getnum(st,7);
+
+	bg_team_rewards_all(bg_map, team_id1, team_id2, nameid, amount, bg_result);
+	return SCRIPT_CMD_SUCCESS;
+}
+
+BUILDIN_FUNC(bgannounce)
+{
+	const char *mes       = script_getstr(st,2);
+	const char *fontColor = script_hasdata(st,3) ? script_getstr(st,3) : "0xFFFFFF";
+	int         fontType  = script_hasdata(st,4) ? script_getnum(st,4) : 0x190; // default fontType (FW_NORMAL)
+	int         fontSize  = script_hasdata(st,5) ? script_getnum(st,5) : 12;    // default fontSize
+	int         fontAlign = script_hasdata(st,6) ? script_getnum(st,6) : 0;     // default fontAlign
+	int         fontY     = script_hasdata(st,7) ? script_getnum(st,7) : 0;     // default fontY
+
+	clif_broadcast2(NULL, mes, (int)strlen(mes)+1, strtol(fontColor, (char **)NULL, 0), fontType, fontSize, fontAlign, fontY, BG_LISTEN);
+	return 0;
+}
+BUILDIN_FUNC(bg_clean)
+{
+	int bg_id = script_getnum(st,2);
+	bg_team_clean(bg_id, false);
+	return SCRIPT_CMD_SUCCESS;
+}
+
+BUILDIN_FUNC(bg_logincount)
+{
+	struct map_session_data *sd;
+	int i = 0;
+
+	if(script_rid2sd(sd))
+		i = battleground_countlogin(sd,true);
+
+	script_pushint(st,i);
+	return SCRIPT_CMD_SUCCESS;
+}
+
+BUILDIN_FUNC(bg_team_reveal)
+{
+	int bg_id;
+
+	bg_id = script_getnum(st,2);
+	std::shared_ptr<s_battleground_data> bg = util::umap_find(bg_team_db, bg_id);
+	if( !bg )
+		return SCRIPT_CMD_SUCCESS;
+
+	bg->reveal_pos = true; // Reveal Position Mode
+	return SCRIPT_CMD_SUCCESS;
+}
+BUILDIN_FUNC(bg_leavebg)
+{
+	if (!battle_config.feature_bgqueue) {
+		script_pushint(st, false);
+		return SCRIPT_CMD_SUCCESS;
+	}
+
+	const char* name = script_getstr(st, 2);
+	struct map_session_data* sd = NULL;
+
+	if (!script_rid2sd(sd)) {
+		ShowError("bg_joinbg: player not attached.\n");
+		script_pushint(st, false);
+		return SCRIPT_CMD_FAILURE;
+	}
+
+	bool success;
+
+	if (sd->bg_queue_id > 0) {
+		std::shared_ptr<s_battleground_queue> queue = bg_search_queue(sd->bg_queue_id);
+
+		if (queue && queue->state == QUEUE_STATE_SETUP_DELAY) {
+			script_pushint(st, false);
+			return SCRIPT_CMD_SUCCESS; // Make the cancel button do nothing if the entry window is open. Otherwise it'll crash the game when you click on both the queue status and entry status window.
+		} else
+			success = bg_queue_leave(sd);
+
+		clif_bg_queue_cancel_result(success, name, sd);
+		script_pushint(st, true);
+	}
+	else {
+		script_pushint(st, false);
+	}
+
+	return SCRIPT_CMD_SUCCESS;
+}
+
+BUILDIN_FUNC(bg_modeselection)
+{
+	script_pushint(st, battle_config.bg_mode_selection);
+	return SCRIPT_CMD_SUCCESS;
+}
+
+BUILDIN_FUNC(bg_current_mode)
+{
+	int mode = bg_get_mode();
+	script_pushint(st, mode);
+	return SCRIPT_CMD_SUCCESS;
+}
+
+BUILDIN_FUNC(bg_set_current_mode)
+{
+	int mode = script_getnum(st, 2);
+	bg_set_mode(mode);
+	return SCRIPT_CMD_SUCCESS;
+}
+
+BUILDIN_FUNC(bg_joinbg)
+{
+	if (!battle_config.feature_bgqueue)
+		return SCRIPT_CMD_SUCCESS;
+
+	const char* name = script_getstr(st, 2);
+	struct map_session_data* sd = NULL;
+
+	if (!script_rid2sd(sd)) {
+		ShowError("bg_joinbg: player not attached.\n");
+		return SCRIPT_CMD_FAILURE;
+	}
+
+	if (sd->bg_queue_id > 0) {
+		//ShowWarning("clif_parse_bg_queue_apply_request: Received duplicate queue application: %d from player %s (AID:%d CID:%d).\n", type, sd->status.name, sd->status.account_id, sd->status.char_id);
+		clif_bg_queue_apply_result(BG_APPLY_DUPLICATE, name, sd); // Duplicate application warning
+		return SCRIPT_CMD_SUCCESS;
+	}
+
+	bg_queue_join_solo(name, sd);
+
+	return SCRIPT_CMD_SUCCESS;
+}
+
+BUILDIN_FUNC(bg_premature_end)
+{
+	int bgid = script_getnum(st, 2);
+
+	for (const auto& queue : bg_queues) {
+		if (queue->id != bgid || queue->state == QUEUE_STATE_SETUP_DELAY || queue->state == QUEUE_STATE_ENDED)
+			continue;
+		if (queue->state == QUEUE_STATE_ACTIVE && queue->map) {
+			npc_event_do(queue->map->bgendcallscript.c_str());
+			break;
+		}
+	}
+
+	return SCRIPT_CMD_SUCCESS;
+}
diff --git a/src/custom/script_def.inc b/src/custom/script_def.inc
index 886399273..e2e5d6fc6 100644
--- a/src/custom/script_def.inc
+++ b/src/custom/script_def.inc
@@ -9,3 +9,32 @@
  **/
 
 //BUILDIN_DEF(example,""),
+	BUILDIN_DEF(bg_move_queue, "ss"),
+	BUILDIN_DEF(viewpointmap,"siiiii"),
+	BUILDIN_DEF(storeitem2,"viiiiiiii?"),
+	BUILDIN_DEF(checkspace,"viiiiiiii"),
+	BUILDIN_DEF(itembound2,"viiiiiiii?"),
+	BUILDIN_DEF(storeitem,"vi?"),
+	BUILDIN_DEF(itembound,"vi?"),
+	BUILDIN_DEF(countstorageitem,"iiiiiiiii?"),
+	BUILDIN_DEF(stor2inv,"iiiiiiiii?"),
+	BUILDIN_DEF(inv2stor,"iiiiiiiii?"),
+	BUILDIN_DEF(bgstart,""),
+	BUILDIN_DEF(bgend,""),
+	BUILDIN_DEF(bgcheck,""),
+	BUILDIN_DEF(bg_flagemblem,"i"),	// Flag Emblem
+	BUILDIN_DEF(pcblock,"ii?"),
+	BUILDIN_DEF(unitisfighting,"i"),
+	BUILDIN_DEF(bg_team_reveal,"i"),
+	BUILDIN_DEF(bg_getitem,"iii"),
+	BUILDIN_DEF(bg_reward,"iiiiisii"),
+	BUILDIN_DEF(bg_reward_all,"siiiii"),
+	BUILDIN_DEF(bgannounce,"s?????"),
+	BUILDIN_DEF(bg_logincount,""),
+	BUILDIN_DEF(bg_clean,"i"),
+	BUILDIN_DEF(bg_joinbg, "s"),
+	BUILDIN_DEF(bg_current_mode, ""),
+	BUILDIN_DEF(bg_set_current_mode, "i"),
+	BUILDIN_DEF(bg_modeselection, ""),
+	BUILDIN_DEF(bg_leavebg, "s"),
+	BUILDIN_DEF(bg_premature_end, "i"),
diff --git a/src/map/atcommand.cpp b/src/map/atcommand.cpp
index 87ef88ff6..e082f312c 100644
--- a/src/map/atcommand.cpp
+++ b/src/map/atcommand.cpp
@@ -25,6 +25,7 @@
 #include "../common/utils.hpp"
 
 #include "achievement.hpp"
+#include "battleground.hpp"
 #include "battle.hpp"
 #include "channel.hpp"
 #include "chat.hpp"
@@ -4058,9 +4059,9 @@ ACMD_FUNC(reload) {
 
 		for (auto &bg : bg_queues) {
 				for (auto &bg_sd : bg->teama_members)
-					bg_team_leave(bg_sd, false, false); // Kick Team A from battlegrounds
+					bg_team_leave(bg_sd, false, false, 1); // Kick Team A from battlegrounds
 				for (auto &bg_sd : bg->teamb_members)
-					bg_team_leave(bg_sd, false, false); // Kick Team B from battlegrounds
+					bg_team_leave(bg_sd, false, false, 1); // Kick Team B from battlegrounds
 				bg_queue_clear(bg, true);
 		}
 
@@ -4270,6 +4271,10 @@ ACMD_FUNC(mapinfo) {
 		strcat(atcmd_output, " NoGo |"); //
 	if (map_getmapflag(m_id, MF_NOMEMO))
 		strcat(atcmd_output, "  NoMemo |");
+	if (map_getmapflag(m_id, MF_ALLOW_BG_ITEMS))
+		strcat(atcmd_output, "  Allow_bg_items |");
+	if (map_getmapflag(m_id, MF_ALLOW_WOE_ITEMS))
+		strcat(atcmd_output, "  Allow_woe_items |");
 	clif_displaymessage(fd, atcmd_output);
 
 	sprintf(atcmd_output, msg_txt(sd,1065),  // No Exp Penalty: %s | No Zeny Penalty: %s
diff --git a/src/map/battle.cpp b/src/map/battle.cpp
index f5a20b557..866cd63da 100644
--- a/src/map/battle.cpp
+++ b/src/map/battle.cpp
@@ -1409,6 +1409,9 @@ int64 battle_calc_damage(struct block_list *src,struct block_list *bl,struct Dam
 
 	sc = status_get_sc(bl); //check target status
 
+	if (sc && sc->data[SC_FULLINVINCIBLE])
+		return 0;
+
 	if( sc && sc->data[SC_INVINCIBLE] && !sc->data[SC_INVINCIBLEOFF] )
 		return 1;
 
@@ -1918,7 +1921,7 @@ bool battle_can_hit_gvg_target(struct block_list *src,struct block_list *bl,uint
 		if ((status_bl_has_mode(bl,MD_SKILLIMMUNE) || (class_ == MOBID_EMPERIUM && !skill_get_inf2(skill_id, INF2_TARGETEMPERIUM))) && flag&BF_SKILL) //Skill immunity.
 			return false;
 		if( src->type != BL_MOB || mob_is_clone( ((struct mob_data*)src)->mob_id ) ){
-			struct guild *g = src->type == BL_PC ? ((TBL_PC *)src)->guild : guild_search(status_get_guild_id(src));
+			struct guild *g = src->type == BL_PC ? ((TBL_PC *)src)->guild : guild_search(clif_visual_guild_id(src));
 
 			if (class_ == MOBID_EMPERIUM && (!g || guild_checkskill(g,GD_APPROVAL) <= 0 ))
 				return false;
@@ -2542,7 +2545,7 @@ int battle_calc_chorusbonus(struct map_session_data *sd) {
 
 	int members = 0;
 
-	if (!sd || !sd->status.party_id)
+	if (!sd || (!sd->status.party_id && !map_getmapflag(sd->bl.m, MF_BATTLEGROUND)))
 		return 0;
 
 	members = party_foreachsamemap(party_sub_count_class, sd, 0, MAPID_THIRDMASK, MAPID_MINSTRELWANDERER);
@@ -3656,7 +3659,7 @@ static void battle_calc_skill_base_damage(struct Damage* wd, struct block_list *
 					ATK_ADDRATE(wd->damage, wd->damage2, sd->bonus.crit_atk_rate);
 				}
 #endif
-				if(sd->status.party_id && (skill=pc_checkskill(sd,TK_POWER)) > 0) {
+				if((sd->status.party_id || map_getmapflag(sd->bl.m, MF_BATTLEGROUND)) && (skill=pc_checkskill(sd,TK_POWER)) > 0) {
 					if( (i = party_foreachsamemap(party_sub_count, sd, 0)) > 1 ) { // exclude the player himself [Inkfish]
 						// Reduce count by one (self) [Tydus1]
 						i -= 1; 
@@ -8259,6 +8262,8 @@ int battle_check_target( struct block_list *src, struct block_list *target,int f
 				if( sc && sc->count ) {
 					if( sc->data[SC_VOICEOFSIREN] && sc->data[SC_VOICEOFSIREN]->val2 == target->id )
 						return -1;
+					if (sc->data[SC_FULLINVINCIBLE])
+						status_change_end(src, SC_FULLINVINCIBLE, INVALID_TIMER);
 				}
 			}
 			break;
@@ -8354,6 +8359,8 @@ int battle_check_target( struct block_list *src, struct block_list *target,int f
 
 			if( ((sd->state.block_action & PCBLOCK_IMMUNE) || (sc->data[SC_KINGS_GRACE] && s_bl->type != BL_PC)) && flag&BCT_ENEMY )
 				return 0; // Global immunity only to Attacks
+			if (sc->data[SC_FULLINVINCIBLE])
+				return 0;
 			if( sd->status.karma && s_bl->type == BL_PC && ((TBL_PC*)s_bl)->status.karma )
 				state |= BCT_ENEMY; // Characters with bad karma may fight amongst them
 			if( sd->state.killable ) {
@@ -8496,16 +8503,20 @@ int battle_check_target( struct block_list *src, struct block_list *target,int f
 		if( flag&(BCT_PARTY|BCT_ENEMY) )
 		{
 			int s_party = status_get_party_id(s_bl);
-			if( s_party && s_party == status_get_party_id(t_bl) && !(mapdata->flag[MF_PVP] && mapdata->flag[MF_PVP_NOPARTY]) && !(mapdata_flag_gvg(mapdata) && mapdata->flag[MF_GVG_NOPARTY]) && (!mapdata->flag[MF_BATTLEGROUND] || sbg_id == tbg_id) )
+			if( !mapdata->flag[MF_BATTLEGROUND] && s_party && s_party == status_get_party_id(t_bl) && !(mapdata->flag[MF_PVP] && mapdata->flag[MF_PVP_NOPARTY]) && !(mapdata_flag_gvg(mapdata) && mapdata->flag[MF_GVG_NOPARTY]) )
+				state |= BCT_PARTY;
+			else if(mapdata->flag[MF_BATTLEGROUND] && sbg_id == tbg_id)
 				state |= BCT_PARTY;
 			else
 				state |= BCT_ENEMY;
 		}
 		if( flag&(BCT_GUILD|BCT_ENEMY) )
 		{
-			int s_guild = status_get_guild_id(s_bl);
-			int t_guild = status_get_guild_id(t_bl);
-			if( !(mapdata->flag[MF_PVP] && mapdata->flag[MF_PVP_NOGUILD]) && s_guild && t_guild && (s_guild == t_guild || (!(flag&BCT_SAMEGUILD) && guild_isallied(s_guild, t_guild))) && (!mapdata->flag[MF_BATTLEGROUND] || sbg_id == tbg_id) )
+			int s_guild = clif_visual_guild_id(s_bl);
+			int t_guild = clif_visual_guild_id(t_bl);
+			if( !mapdata->flag[MF_BATTLEGROUND] && !(mapdata->flag[MF_PVP] && mapdata->flag[MF_PVP_NOGUILD]) && s_guild && t_guild && (s_guild == t_guild || (!(flag&BCT_SAMEGUILD) && guild_isallied(s_guild, t_guild))) )
+				state |= BCT_GUILD;
+			else if(mapdata->flag[MF_BATTLEGROUND] && sbg_id == tbg_id)
 				state |= BCT_GUILD;
 			else
 				state |= BCT_ENEMY;
@@ -8536,8 +8547,8 @@ int battle_check_target( struct block_list *src, struct block_list *target,int f
 		}
 		if( flag&BCT_GUILD || state&BCT_ENEMY )
 		{
-			int s_guild = status_get_guild_id(s_bl);
-			int t_guild = status_get_guild_id(t_bl);
+			int s_guild = clif_visual_guild_id(s_bl);
+			int t_guild = clif_visual_guild_id(t_bl);
 			if(s_guild && t_guild && (s_guild == t_guild || (!(flag&BCT_SAMEGUILD) && guild_isallied(s_guild, t_guild))))
 				state |= BCT_GUILD;
 		}
diff --git a/src/map/battle.hpp b/src/map/battle.hpp
index d3ce73e86..942b88524 100644
--- a/src/map/battle.hpp
+++ b/src/map/battle.hpp
@@ -516,6 +516,15 @@ struct Battle_Config
 	int bg_magic_damage_rate;
 	int bg_misc_damage_rate;
 	int bg_flee_penalty;
+	int bg_reward_rates;
+	int bg_invincible_time;
+	int bg_mode_selection;
+	int bg_idle_announce;
+	int bg_idle_autokick;
+	int bg_reportafk_leaderonly;
+	int bg_queue2team_balanced;
+	int bg_queue_onlytowns;
+	int bg_logincount_check;
 
 	// rAthena
 	int max_third_parameter;
diff --git a/src/map/battleground.cpp b/src/map/battleground.cpp
index 7aaf10d3e..1cc52a34b 100644
--- a/src/map/battleground.cpp
+++ b/src/map/battleground.cpp
@@ -12,7 +12,9 @@
 #include "../common/random.hpp"
 #include "../common/showmsg.hpp"
 #include "../common/strlib.hpp"
+#include "../common/socket.hpp"
 #include "../common/timer.hpp"
+#include "../common/utils.hpp"
 #include "../common/utilities.hpp"
 
 #include "battle.hpp"
@@ -26,6 +28,8 @@
 #include "party.hpp"
 #include "pc.hpp"
 #include "pet.hpp"
+#include "quest.hpp"
+#include "log.hpp"
 
 using namespace rathena;
 
@@ -33,6 +37,9 @@ BattlegroundDatabase battleground_db;
 std::unordered_map<int, std::shared_ptr<s_battleground_data>> bg_team_db;
 std::vector<std::shared_ptr<s_battleground_queue>> bg_queues;
 int bg_queue_count = 1;
+int bg_current_mode = 0;
+
+struct guild bg_guild[2]; // Temporal fake guild information
 
 const std::string BattlegroundDatabase::getDefaultLocation() {
 	return std::string(db_path) + "/battleground_db.yml";
@@ -70,6 +77,33 @@ uint64 BattlegroundDatabase::parseBodyNode(const YAML::Node &node) {
 		bg->name = name;
 	}
 
+	if (this->nodeExists(node, "Variable")) {
+		std::string var;
+		if (!this->asString(node, "Variable", var))
+			return 0;
+
+		var.resize(NAME_LENGTH);
+		bg->variable = var;
+	}
+
+	if (this->nodeExists(node, "Color")) {
+		unsigned int color;
+
+		if (!this->asUInt32(node, "Color", color))
+			return 0;
+
+		if (color > 0xFFFFFF) {
+			this->invalidWarning(node["color"], "Color invalid, capping to %d.\n", color, 0xFFFFFF);
+			color = MAX_LEVEL;
+		}
+
+		bg->color = color;
+	}
+	else {
+		if (!exists)
+			bg->color = 0xFFFFFF;
+	}
+
 	if (this->nodeExists(node, "MinPlayers")) {
 		int min;
 
@@ -159,7 +193,7 @@ uint64 BattlegroundDatabase::parseBodyNode(const YAML::Node &node) {
 		if (!exists)
 			bg->deserter_time = 600;
 	}
-
+	
 	if (this->nodeExists(node, "StartDelay")) {
 		uint32 delay;
 
@@ -172,6 +206,45 @@ uint64 BattlegroundDatabase::parseBodyNode(const YAML::Node &node) {
 			bg->start_delay = 0;
 	}
 
+	if (this->nodeExists(node, "RewardWinner")) {
+		int reward;
+
+		if (!this->asInt32(node, "RewardWinner", reward))
+			return 0;
+
+		bg->reward_winner = reward;
+	}
+	else {
+		if (!exists)
+			bg->reward_winner = 12;
+	}
+
+	if (this->nodeExists(node, "RewardLooser")) {
+		int reward;
+
+		if (!this->asInt32(node, "RewardLooser", reward))
+			return 0;
+
+		bg->reward_looser = reward;
+	}
+	else {
+		if (!exists)
+			bg->reward_looser = 5;
+	}
+
+	if (this->nodeExists(node, "RewardDraw")) {
+		int reward;
+
+		if (!this->asInt32(node, "RewardDraw", reward))
+			return 0;
+
+		bg->reward_draw = reward;
+	}
+	else {
+		if (!exists)
+			bg->reward_draw = 6;
+	}
+
 	if (this->nodeExists(node, "Join")) {
 		const YAML::Node &joinNode = node["Join"];
 
@@ -279,6 +352,18 @@ uint64 BattlegroundDatabase::parseBodyNode(const YAML::Node &node) {
 				}
 			}
 
+			if (this->nodeExists(location, "PrematureEndEvent")) {
+				if (!this->asString(location, "PrematureEndEvent", map_entry.bgendcallscript))
+					return 0;
+
+				map_entry.bgendcallscript.resize(EVENT_NAME_LENGTH);
+
+				if (map_entry.bgendcallscript.find("::On") == std::string::npos) {
+					this->invalidWarning(location["StartEvent"], "Battleground PrematureEndEvent label %s should begin with '::On', skipping.\n", map_entry.bgendcallscript.c_str());
+					return 0;
+				}
+			}
+
 			std::vector<std::string> team_list = { "TeamA", "TeamB" };
 
 			for (const auto &it : team_list) {
@@ -349,6 +434,11 @@ uint64 BattlegroundDatabase::parseBodyNode(const YAML::Node &node) {
 						team_ptr->bg_id_var.resize(NAME_LENGTH);
 					}
 
+					if (this->nodeExists(team[it], "Palette")) {
+						if (!this->asInt16(team[it], "Palette", team_ptr->palette))
+							return 0;
+					}
+
 					map_entry.id = count++;
 					map_entry.isReserved = false;
 				}
@@ -364,6 +454,48 @@ uint64 BattlegroundDatabase::parseBodyNode(const YAML::Node &node) {
 	return 1;
 }
 
+// Move BG Team from db
+int bg_move_team_queue(const char * from_bg_name, const char * target_bg_name)
+{
+	std::shared_ptr<s_battleground_type> bg = bg_search_name(from_bg_name);
+	if (!bg) {
+		return 0;
+	}
+
+	std::vector<struct map_session_data *> list;
+
+	for (const auto &queue : bg_queues) {
+		if (queue->id != bg->id)
+			continue;
+
+		for (const auto& sd : queue->teama_members) {
+			if (sd) {
+				list.push_back(sd);
+				bg_queue_leave(sd);
+			}
+		}
+		for (const auto& sd : queue->teamb_members) {
+			if (sd) {
+				list.push_back(sd);
+				bg_queue_leave(sd);
+			}
+		}
+	}
+
+	while (!list.empty()) {
+		struct map_session_data *sd2 = list.back();
+
+		list.pop_back();
+
+		if (sd2) {
+			status_change_end(&sd2->bl, SC_ENTRY_QUEUE_APPLY_DELAY, INVALID_TIMER);
+			bg_queue_join_multi(target_bg_name, sd2, { sd2 });
+		}
+	}
+
+	return 1;
+}
+
 /**
  * Search for a battleground based on the given name
  * @param name: Battleground name
@@ -381,6 +513,25 @@ std::shared_ptr<s_battleground_type> bg_search_name(const char *name)
 	return nullptr;
 }
 
+
+/**
+ * Search for a battleground based on the given map
+ * @param name: Battleground map name
+ * @return s_battleground_type on success or nullptr on failure
+ */
+std::shared_ptr<s_battleground_type> bg_search_mapname(const char* name)
+{
+	uint16 mapindex = mapindex_name2id(name);
+
+	for (auto& pair : battleground_db) {
+		for (auto& map : pair.second->maps) {
+			if (map.mapindex == mapindex) {
+				return pair.second;
+			}
+		}
+	}
+	return nullptr;
+}
 /**
  * Search for a Battleground queue based on the given queue ID
  * @param queue_id: Queue ID
@@ -413,6 +564,35 @@ struct map_session_data* bg_getavailablesd(s_battleground_data *bg)
 	return nullptr;
 }
 
+/*====================================================
+ * Start normal bg and triggers all npc OnBGGlobalStart
+ *---------------------------------------------------*/
+void bg_start(void)
+{
+	// Run All NPC_Event[BGStart]
+	int c = npc_event_doall("OnBGGlobalStart");
+	ShowStatus("NPC_Event:[OnBGGlobalStart] Run (%d) Events by @BGStart.\n",c);
+}
+
+/*====================================================
+ * End normal bg and triggers all npc OnAgitEnd
+ *---------------------------------------------------*/
+void bg_end(void)
+{
+	// Run All NPC_Event[BGEnd]
+	int c = npc_event_doall("OnBGEnd");
+	ShowStatus("NPC_Event:[OnBGtEnd] Run (%d) Events by @BGEnd.\n", c);
+}
+
+int bg_get_mode()
+{
+	return bg_current_mode;
+}
+void bg_set_mode(int mode)
+{
+	bg_current_mode = mode;
+}
+
 /**
  * Delete a Battleground team from the db
  * @param bg_id: Battleground ID
@@ -435,7 +615,34 @@ bool bg_team_delete(int bg_id)
 	
 	return false;
 }
+// Deletes BG Team from db
+int bg_team_clean(int bg_id, bool remove)
+{
+	std::shared_ptr<s_battleground_data> bgteam = util::umap_find(bg_team_db, bg_id);
+
+	if(!bgteam) return 0;
+
+	for (auto member = bgteam->members.begin(); member != bgteam->members.end(); member++) {
+		struct map_session_data *sd = member->sd;
+
+		if (sd) {
+			bg_team_leave(sd, true, false, 0);
+			member--;
+		}
+	}
 
+	if( remove )
+		bg_team_delete(bg_id);
+	else
+	{
+		bgteam->leader_char_id = 0;
+		bgteam->team_score = 0;
+		bgteam->creation_tick = 0;
+		bgteam->members.clear();
+	}
+
+	return 1;
+}
 /**
  * Warps a Battleground team
  * @param bg_id: Battleground ID
@@ -449,6 +656,12 @@ bool bg_team_warp(int bg_id, unsigned short mapindex, short x, short y)
 	std::shared_ptr<s_battleground_data> bgteam = util::umap_find(bg_team_db, bg_id);
 
 	if (bgteam) {
+		if (mapindex == 0)
+		{
+			mapindex = bgteam->cemetery.map;
+			x = bgteam->cemetery.x;
+			y = bgteam->cemetery.y;
+		}
 		for (const auto &pl_sd : bgteam->members)
 			pc_setpos(pl_sd.sd, mapindex, x, y, CLR_TELEPORT);
 
@@ -458,6 +671,23 @@ bool bg_team_warp(int bg_id, unsigned short mapindex, short x, short y)
 	return false;
 }
 
+int bg_reveal_pos(struct block_list *bl, va_list ap)
+{
+	struct map_session_data *pl_sd, *sd = NULL;
+	int flag, color;
+
+	pl_sd = (struct map_session_data *)bl;
+	sd = va_arg(ap,struct map_session_data *); // Source
+	flag = va_arg(ap,int);
+	color = va_arg(ap,int);
+
+	if( pl_sd->bg_id == sd->bg_id )
+		return 0; // Same Team
+
+	clif_viewpoint(pl_sd,sd->bl.id,flag,sd->bl.x,sd->bl.y,sd->bl.id,color);
+	return 0;
+}
+
 /**
  * Remove a player's Battleground map marker
  * @param sd: Player data
@@ -467,7 +697,14 @@ void bg_send_dot_remove(struct map_session_data *sd)
 	nullpo_retv(sd);
 
 	if( sd && sd->bg_id )
+	{
+		std::shared_ptr<s_battleground_data> bg = util::umap_find(bg_team_db, sd->bg_id);
 		clif_bg_xy_remove(sd);
+
+		int m;
+		if( bg && bg->reveal_pos && (m = map_mapindex2mapid(bg->cemetery.map)) == sd->bl.m )
+			map_foreachinmap(bg_reveal_pos,m,BL_PC,sd,2,0xFFFFFF);
+	}
 	return;
 }
 
@@ -479,7 +716,7 @@ void bg_send_dot_remove(struct map_session_data *sd)
  * @return True on success or false otherwise
  */
 bool bg_team_join(int bg_id, struct map_session_data *sd, bool is_queue)
-{
+{	
 	if (!sd || sd->bg_id)
 		return false;
 
@@ -491,10 +728,19 @@ bool bg_team_join(int bg_id, struct map_session_data *sd, bool is_queue)
 
 		s_battleground_member_data member = {};
 
+		pc_update_last_action(sd,0,IDLE_WALK); // Start count from here...
 		sd->bg_id = bg_id;
+		sd->state.bg_afk = 0;
 		member.sd = sd;
 		member.x = sd->bl.x;
 		member.y = sd->bl.y;
+
+		// First Join = Team Leader
+		if(bgteam->leader_char_id == 0 )
+		{
+			bgteam->leader_char_id = sd->status.char_id;
+			sd->bmaster_flag = bgteam;
+		}
 		if (is_queue) { // Save the location from where the person entered the battleground
 			member.entry_point.map = sd->mapindex;
 			member.entry_point.x = sd->bl.x;
@@ -504,13 +750,28 @@ bool bg_team_join(int bg_id, struct map_session_data *sd, bool is_queue)
 
 		guild_send_dot_remove(sd);
 
+		clif_bg_belonginfo(sd);
+		clif_name_area(&sd->bl);
+
 		for (const auto &pl_sd : bgteam->members) {
+
+			// Simulate Guild Information
+			clif_guild_basicinfo(pl_sd.sd);
+			clif_bg_emblem(pl_sd.sd, bgteam->g);
+			clif_bg_memberlist(pl_sd.sd);
+
 			if (pl_sd.sd != sd)
 				clif_hpmeter_single(sd->fd, pl_sd.sd->bl.id, pl_sd.sd->battle_status.hp, pl_sd.sd->battle_status.max_hp);
 		}
 
+		clif_guild_emblem_area(&sd->bl);
 		clif_bg_hp(sd);
 		clif_bg_xy(sd);
+		
+		// [Vykimo] Put palette to players if any		
+		if(bgteam->palette) {
+			clif_changelook(&sd->bl, LOOK_CLOTHES_COLOR, bgteam->palette);
+		}
 		return true;
 	}
 
@@ -524,8 +785,11 @@ bool bg_team_join(int bg_id, struct map_session_data *sd, bool is_queue)
  * @param deserter: Whether to apply the deserter status or not
  * @return Remaining count in Battleground team or -1 on failure
  */
-int bg_team_leave(struct map_session_data *sd, bool quit, bool deserter)
+int bg_team_leave(struct map_session_data *sd, bool quit, bool deserter, int flag)
 {
+	struct map_session_data *pl_sd;
+	struct guild *g;
+
 	if (!sd || !sd->bg_id)
 		return -1;
 
@@ -537,24 +801,6 @@ int bg_team_leave(struct map_session_data *sd, bool quit, bool deserter)
 	sd->bg_id = 0;
 
 	if (bgteam) {
-		// Warping members out only applies to the Battleground Queue System
-		if (battle_config.feature_bgqueue) {
-			auto member = bgteam->members.begin();
-
-			while (member != bgteam->members.end()) {
-				if (member->sd == sd) {
-					if (member->entry_point.map != 0 && !map_getmapflag(map_mapindex2mapid(member->entry_point.map), MF_NOSAVE))
-						pc_setpos(sd, member->entry_point.map, member->entry_point.x, member->entry_point.y, CLR_TELEPORT);
-					else
-						pc_setpos(sd, sd->status.save_point.map, sd->status.save_point.x, sd->status.save_point.y, CLR_TELEPORT); // Warp to save point if the entry map has no save flag.
-
-					bgteam->members.erase(member);
-					break;
-				} else
-					member++;
-			}
-		}
-
 		char output[CHAT_SIZE_MAX];
 
 		if (quit)
@@ -564,6 +810,62 @@ int bg_team_leave(struct map_session_data *sd, bool quit, bool deserter)
 
 		clif_bg_message(bgteam.get(), 0, "Server", output, strlen(output) + 1);
 
+		sd->state.bg_afk = 0;
+
+		// Remove Guild Skill Buffs
+		status_change_end(&sd->bl, SC_GUILDAURA,INVALID_TIMER);
+		status_change_end(&sd->bl, SC_BATTLEORDERS,INVALID_TIMER);
+		status_change_end(&sd->bl, SC_REGENERATION,INVALID_TIMER);
+		status_change_end(&sd->bl, SC_LEADERSHIP, INVALID_TIMER);
+		status_change_end(&sd->bl, SC_GLORYWOUNDS, INVALID_TIMER);
+		status_change_end(&sd->bl, SC_SOULCOLD, INVALID_TIMER);
+		status_change_end(&sd->bl, SC_HAWKEYES, INVALID_TIMER);
+
+
+		// Refresh Guild Information
+		if( sd->status.guild_id && (g = guild_search(sd->status.guild_id)) != NULL )
+		{
+			clif_guild_belonginfo(sd, g);
+			clif_guild_basicinfo(sd);
+			clif_guild_allianceinfo(sd);
+			clif_guild_memberlist(sd);
+			clif_guild_skillinfo(sd);
+			clif_guild_emblem(sd, g);
+		}
+		else {
+			clif_bg_expulsion_single(sd, sd->status.name, "User has quit the game...");
+		}
+
+		clif_guild_emblem_area(&sd->bl);
+		clif_name_self(&sd->bl);
+		clif_name_area(&sd->bl);
+
+		clif_changelook(&sd->bl, LOOK_CLOTHES_COLOR, sd->status.clothes_color); // [Vykimo] remove palette
+
+		// Warping members out
+		auto member = bgteam->members.begin();
+		while (member != bgteam->members.end()) {
+			if (member->sd == sd) {
+				if (member->entry_point.map != 0 && !map_getmapflag(map_mapindex2mapid(member->entry_point.map), MF_NOSAVE))
+					pc_setpos(sd, member->entry_point.map, member->entry_point.x, member->entry_point.y, CLR_TELEPORT);
+				else
+					pc_setpos(sd, sd->status.save_point.map, sd->status.save_point.x, sd->status.save_point.y, CLR_TELEPORT); // Warp to save point if the entry map has no save flag.
+
+				bgteam->members.erase(member);
+
+				// Erase leader
+				if (bgteam->leader_char_id == sd->status.char_id)
+					bgteam->leader_char_id = 0;
+
+				clif_guild_emblem_area(&sd->bl);
+				break;
+			}
+			else
+				member++;
+		}
+
+		unit_remove_map_pc(sd,CLR_RESPAWN); // [Vykimo] Simulating the warp effect for disconnecting
+
 		if (!bgteam->logout_event.empty() && quit)
 			npc_event(sd, bgteam->logout_event.c_str(), 0);
 
@@ -574,11 +876,47 @@ int bg_team_leave(struct map_session_data *sd, bool quit, bool deserter)
 				sc_start(nullptr, &sd->bl, SC_ENTRY_QUEUE_NOTIFY_ADMISSION_TIME_OUT, 100, 1, static_cast<t_tick>(bg->deserter_time) * 1000); // Deserter timer
 		}
 
+		sd->bmaster_flag = NULL;
+
+		if( bgteam->members.size() > 0 ) {
+			// Update other BG members
+			for (const auto& member : bgteam->members) {
+				pl_sd = member.sd;
+
+				// Set new Leader first on the list
+				if (!bgteam->leader_char_id)
+				{
+					bgteam->leader_char_id = pl_sd->status.char_id;
+					pl_sd->bmaster_flag = bgteam;
+					clif_name_area(&pl_sd->bl); // [Vykimo] Update in team leader's position
+				}
+
+				if (sd) {
+					switch (flag) {
+						case 3: clif_bg_expulsion_single(pl_sd, sd->status.name, "Kicked by AFK Status..."); break;
+						case 2: clif_bg_expulsion_single(pl_sd, sd->status.name, "Kicked by AFK Report..."); break;
+						case 1: clif_bg_expulsion_single(pl_sd, sd->status.name, "User has quit the game..."); break;
+						case 0: clif_bg_leave_single(pl_sd, sd->status.name, "Leaving Battleground..."); break;
+					}
+				}
+
+				clif_guild_basicinfo(pl_sd);
+				clif_bg_emblem(pl_sd, bgteam->g);
+				clif_bg_memberlist(pl_sd);
+			}
+		}
 		return bgteam->members.size();
 	}
 
 	return -1;
 }
+// Return Fake Guild for BG Members
+struct guild* bg_guild_get(int bg_id)
+{
+	std::shared_ptr<s_battleground_data> bg = util::umap_find(bg_team_db, bg_id);
+	if( !bg ) return NULL;
+	return bg->g;
+}
 
 /**
  * Respawn a Battleground player
@@ -614,7 +952,7 @@ bool bg_member_respawn(struct map_session_data *sd)
  * @param dev: Death NPC Event
  * @return Battleground ID
  */
-int bg_create(uint16 mapindex, s_battleground_team* team)
+int bg_create(uint16 mapindex, s_battleground_team* team, int guild_index)
 {
 	int bg_team_counter = 1;
 
@@ -626,12 +964,17 @@ int bg_create(uint16 mapindex, s_battleground_team* team)
 	std::shared_ptr<s_battleground_data> bg = util::umap_find(bg_team_db, bg_team_counter);
 
 	bg->id = bg_team_counter;
+	bg->creation_tick = 0;
+	bg->g = &bg_guild[guild_index];
 	bg->cemetery.map = mapindex;
 	bg->cemetery.x = team->warp_x;
 	bg->cemetery.y = team->warp_y;
+	bg->palette = team->palette;
 	bg->logout_event = team->quit_event.c_str();
 	bg->die_event = team->death_event.c_str();
 	bg->active_event = team->active_event.c_str();
+	for( int i = 0; i < MAX_GUILDSKILL; i++ )
+		bg->skill_block_timer[i] = INVALID_TIMER;
 
 	return bg->id;
 }
@@ -704,15 +1047,40 @@ void bg_send_message(struct map_session_data *sd, const char *mes, int len)
 int bg_send_xy_timer_sub(std::shared_ptr<s_battleground_data> bg)
 {
 	struct map_session_data *sd;
+	char output[128];
+	int m = bg->cemetery.map;	
 
 	for (auto &pl_sd : bg->members) {
 		sd = pl_sd.sd;
 
+		if (sd == nullptr) continue;
+
+		if( battle_config.bg_idle_autokick && DIFF_TICK(last_tick, sd->idletime) >= battle_config.bg_idle_autokick && bg->g )
+		{
+			sprintf(output, "- AFK [%s] Excluded -", sd->status.name);
+			clif_broadcast2(&sd->bl, output, (int)strlen(output)+1, bg->color, 0x190, 20, 0, 0, BG);
+
+			bg_team_leave(sd, true, true, 3);
+			clif_displaymessage(sd->fd, "You are excluded from the battleground because of too long inactivity.");
+			//pc_setpos(sd,sd->status.save_point.map,sd->status.save_point.x,sd->status.save_point.y,CLR_OUTSIGHT);
+			//clif_refresh(sd);
+			continue;
+		}
+
 		if (sd->bl.x != pl_sd.x || sd->bl.y != pl_sd.y) { // xy update
 			pl_sd.x = sd->bl.x;
 			pl_sd.y = sd->bl.y;
 			clif_bg_xy(sd);
 		}
+		
+		if( bg->reveal_pos && bg->reveal_flag && sd->bl.m == m ) // Reveal each 4 seconds
+			map_foreachinmap(bg_reveal_pos,m,BL_PC,sd,1,bg->color);
+		if( battle_config.bg_idle_announce && !sd->state.bg_afk && DIFF_TICK(last_tick, sd->idletime) >= battle_config.bg_idle_announce && bg->g )
+		{ // Idle announces
+			sd->state.bg_afk = 1;
+			sprintf(output, "%s : %s seems to be AFK - It can be kicked out with @reportafk", bg->g->name, sd->status.name);
+			clif_bg_message(bg.get(), 0, bg->g->name, output, strlen(output) + 1);
+		}
 	}
 
 	return 0;
@@ -846,6 +1214,9 @@ static bool bg_queue_check_status(struct map_session_data* sd, const char *name)
 {
 	nullpo_retr(false, sd);
 
+	// GMs bypass this
+	if (pc_get_group_level(sd) > 50) return true;
+
 	if (sd->sc.count) {
 		if (sd->sc.data[SC_ENTRY_QUEUE_APPLY_DELAY]) { // Exclude any player who's recently left a battleground queue
 			char buf[CHAT_SIZE_MAX];
@@ -881,6 +1252,18 @@ bool bg_queue_check_joinable(std::shared_ptr<s_battleground_type> bg, struct map
 {
 	nullpo_retr(false, sd);
 
+	if (!bg_flag) {
+		clif_messagecolor(&sd->bl, color_table[COLOR_RED], msg_txt(sd, 453), false, SELF);
+		clif_bg_queue_apply_result(BG_UNACTIVATED, name, sd);
+		return false;
+	}
+
+	if (battleground_countlogin(sd, false) > 0) {
+		clif_messagecolor(&sd->bl, color_table[COLOR_RED], msg_txt(sd, 454), false, SELF);
+		clif_bg_queue_apply_result(BG_DUPLICATE_UNIQUE_ID, name, sd);
+		return false;
+	}
+
 	for (const auto &job : bg->job_restrictions) { // Check class requirement
 		if (sd->status.class_ == job) {
 			clif_bg_queue_apply_result(BG_APPLY_PLAYER_CLASS, name, sd);
@@ -959,6 +1342,10 @@ void bg_queue_join_solo(const char *name, struct map_session_data *sd)
 		return;
 	}
 
+	if (battle_config.bg_mode_selection == 1 && bg_current_mode > 0) {
+		name = battleground_db.find(bg_current_mode)->name.c_str();
+	}
+
 	std::shared_ptr<s_battleground_type> bg = bg_search_name(name);
 
 	if (!bg) {
@@ -986,6 +1373,10 @@ void bg_queue_join_party(const char *name, struct map_session_data *sd)
 		return;
 	}
 
+	if (battle_config.bg_mode_selection == 1 && bg_current_mode > 0) {
+		name = battleground_db.find(bg_current_mode)->name.c_str();
+	}
+
 	struct party_data *p = party_search(sd->status.party_id);
 
 	if (!p) {
@@ -1064,6 +1455,10 @@ void bg_queue_join_guild(const char *name, struct map_session_data *sd)
 		return; // Not the guild leader
 	}
 
+	if (battle_config.bg_mode_selection == 1 && bg_current_mode > 0) {
+		name = battleground_db.find(bg_current_mode)->name.c_str();
+	}
+
 	std::shared_ptr<s_battleground_type> bg = bg_search_name(name);
 
 	if (bg) {
@@ -1114,6 +1509,10 @@ void bg_queue_join_multi(const char *name, struct map_session_data *sd, std::vec
 		return;
 	}
 
+	if (battle_config.bg_mode_selection == 1 && bg_current_mode > 0) {
+		name = battleground_db.find(bg_current_mode)->name.c_str();
+	}
+
 	std::shared_ptr<s_battleground_type> bg = bg_search_name(name);
 
 	if (!bg) {
@@ -1134,14 +1533,24 @@ void bg_queue_join_multi(const char *name, struct map_session_data *sd, std::vec
 			break;
 		}
 
+		bool isTeamBbiggerTeamA = false;
+		if (queue->map != nullptr) {
+			int bg_id_team_1 = static_cast<int>(mapreg_readreg(add_str(queue->map->team1.bg_id_var.c_str())));
+			std::shared_ptr<s_battleground_data> bgteam_1 = util::umap_find(bg_team_db, bg_id_team_1);
+
+			int bg_id_team_2 = static_cast<int>(mapreg_readreg(add_str(queue->map->team2.bg_id_var.c_str())));
+			std::shared_ptr<s_battleground_data> bgteam_2 = util::umap_find(bg_team_db, bg_id_team_2);
+
+			isTeamBbiggerTeamA = bgteam_1->members.size() < bgteam_2->members.size();
+		}
 		bool r = rnd() % 2 != 0;
 		std::vector<map_session_data *> *team = r ? &queue->teamb_members : &queue->teama_members;
 
 		if (queue->state == QUEUE_STATE_ACTIVE) {
 			// If one team has lesser members try to balance (on an active BG)
-			if (r && queue->teama_members.size() < queue->teamb_members.size())
+			if (r && (queue->teama_members.size() < queue->teamb_members.size() || isTeamBbiggerTeamA))
 				team = &queue->teama_members;
-			else if (!r && queue->teamb_members.size() < queue->teama_members.size())
+			else if (!r && (queue->teama_members.size() > queue->teamb_members.size() || !isTeamBbiggerTeamA))
 				team = &queue->teamb_members;
 		} else {
 			// If the designated team is full, put the player into the other team
@@ -1156,7 +1565,7 @@ void bg_queue_join_multi(const char *name, struct map_session_data *sd, std::vec
 
 			if (!sd2 || sd2->bg_queue_id > 0)
 				continue;
-
+						
 			if (!bg_queue_check_joinable(bg, sd2, name))
 				continue;
 
@@ -1164,6 +1573,12 @@ void bg_queue_join_multi(const char *name, struct map_session_data *sd, std::vec
 			team->push_back(sd2);
 			clif_bg_queue_apply_result(BG_APPLY_ACCEPT, name, sd2);
 			clif_bg_queue_apply_notify(name, sd2);
+
+			// Announce
+			char output[CHAT_SIZE_MAX];
+			memset(output, '\0', sizeof(output));
+			sprintf(output, msg_txt(sd, 455), name, sd2->status.name);
+			clif_broadcast2(NULL, output, (int)strlen(output) + 1, strtol("0x00FFFF", (char**)NULL, 0), 0x190, 12, 0, 0, BG_LISTEN);
 		}
 
 		if (queue->state == QUEUE_STATE_ACTIVE) { // Battleground is already active
@@ -1249,7 +1664,7 @@ static bool bg_queue_leave_sub(struct map_session_data *sd, std::vector<map_sess
 			members.erase(list_it);
 
 			if (apply_sc)
-				sc_start(nullptr, &sd->bl, SC_ENTRY_QUEUE_APPLY_DELAY, 100, 1, 60000);
+				sc_start(nullptr, &sd->bl, SC_ENTRY_QUEUE_APPLY_DELAY, 100, 1, 30000);
 			sd->bg_queue_id = 0;
 			pc_delete_bg_queue_timer(sd);
 			return true;
@@ -1509,8 +1924,8 @@ void bg_queue_start_battleground(std::shared_ptr<s_battleground_queue> queue)
 		return;
 
 	uint16 map_idx = queue->map->mapindex;
-	int bg_team_1 = bg_create(map_idx, &queue->map->team1);
-	int bg_team_2 = bg_create(map_idx, &queue->map->team2);
+	int bg_team_1 = bg_create(map_idx, &queue->map->team1, 0);
+	int bg_team_2 = bg_create(map_idx, &queue->map->team2, 1);
 
 	for (const auto &sd : queue->teama_members) {
 		clif_bg_queue_entry_init(sd);
@@ -1551,7 +1966,291 @@ static void bg_queue_create(int bg_id, int req_players)
 
 	bg_queues.push_back(queue);
 }
+/*
+static int bg_team_db_reset(DBKey key, DBData *data, va_list ap)
+{
+	struct battleground_data *bg = (struct battleground_data *)db_data2ptr(data);
+	bg_team_clean(bg->bg_id,false);
+	return 0;
+}
+static int queue_db_final(DBKey key, DBData *data, va_list ap)
+{
+	struct queue_data *qd = (struct queue_data *)db_data2ptr(data);
+	queue_members_clean(qd); // Unlink all queue members
+	return 0;
+}
+*/
+void bg_guild_build_data(void)
+{
+	int i, j, k, skill;
+	memset(&bg_guild, 0, sizeof(bg_guild));
+	for( i = 1; i <= 2; i++ )
+	{ // Emblem Data - Guild ID's
+		FILE* fp = NULL;
+		char path[256];
+
+		j = i - 1;
+		bg_guild[j].emblem_id = 1; // Emblem Index
+		bg_guild[j].guild_id = SHRT_MAX - j;
+		bg_guild[j].guild_lv = 1;
+		bg_guild[j].max_member = MAX_BG_MEMBERS;
+		bg_guild[j].average_lv = 0;
+		bg_guild[j].exp = 0;
+		bg_guild[j].next_exp = 0;
+		bg_guild[j].skill_point = 0;
+
+		// Skills
+		if( j < 2 )
+		{ // Clan Skills
+			for( k = 0; k < MAX_GUILDSKILL; k++ )
+			{
+				skill = k + GD_SKILLBASE;
+				bg_guild[j].skill[k].id = skill;
+				switch( skill )
+				{
+				case GD_GLORYGUILD:
+					bg_guild[j].skill[k].lv = 0;
+					break;
+				case GD_APPROVAL:
+				case GD_KAFRACONTRACT:
+				case GD_GUARDRESEARCH:
+				case GD_BATTLEORDER:
+				case GD_RESTORE:
+				case GD_EMERGENCYCALL:
+				case GD_DEVELOPMENT:
+					bg_guild[j].skill[k].lv = 1;
+					break;
+				case GD_GUARDUP:
+				case GD_REGENERATION:
+					bg_guild[j].skill[k].lv = 3;
+					break;
+				case GD_LEADERSHIP:
+				case GD_GLORYWOUNDS:
+				case GD_SOULCOLD:
+				case GD_HAWKEYES:
+					bg_guild[j].skill[k].lv = 5;
+					break;
+				case GD_EXTENSION:
+					bg_guild[j].skill[k].lv = 10;
+					break;
+				}
+			}
+		}
+		else
+		{ // Other Data
+			snprintf(bg_guild[j].name, NAME_LENGTH, "Team %d", i - 2); // Team 1, Team 2 ... Team 10
+			strncpy(bg_guild[j].master, bg_guild[j].name, NAME_LENGTH);
+			snprintf(bg_guild[j].position[0].name, NAME_LENGTH, "%s Leader", bg_guild[j].name);
+			strncpy(bg_guild[j].position[1].name, bg_guild[j].name, NAME_LENGTH);
+		}
+
+		sprintf(path, "%s/emblems/bg_%d.ebm", db_path, i);
+		if( (fp = fopen(path, "rb")) != NULL )
+		{
+			fseek(fp, 0, SEEK_END);
+			bg_guild[j].emblem_len = ftell(fp);
+			fseek(fp, 0, SEEK_SET);
+			fread(&bg_guild[j].emblem_data, 1, bg_guild[j].emblem_len, fp);
+			fclose(fp);
+			ShowStatus("Done reading '" CL_WHITE "%s" CL_RESET "' emblem data file.\n", path);
+		}
+	}
+
+	// Guild Data - Guillaume
+	strncpy(bg_guild[0].name, "Blue Team", NAME_LENGTH);
+	strncpy(bg_guild[0].master, "General Guillaume", NAME_LENGTH);
+	strncpy(bg_guild[0].position[0].name, "Blue Team Chief", NAME_LENGTH);
+	strncpy(bg_guild[0].position[1].name, "Blue Team", NAME_LENGTH);
+
+	// Guild Data - Croix
+	strncpy(bg_guild[1].name, "Red Team", NAME_LENGTH);
+	strncpy(bg_guild[1].master, "Prince Croix", NAME_LENGTH);
+	strncpy(bg_guild[1].position[0].name, "Red Team Chief", NAME_LENGTH);
+	strncpy(bg_guild[1].position[1].name, "Red Team", NAME_LENGTH);
+}
+
+void bg_team_getitem(int bg_id, int nameid, int amount)
+{
+	struct map_session_data *sd;
+	struct item_data *id;
+	struct item it;
+	int get_amount, flag, rank = 0;
+	std::shared_ptr<s_battleground_data> bg = util::umap_find(bg_team_db, bg_id);
+
+	if( amount < 1 || !bg || (id = itemdb_exists(nameid)) == NULL )
+		return;
+	if( nameid != 7828 && nameid != 7829 && nameid != 7773 )
+		return;
+	if( battle_config.bg_reward_rates != 100 )
+		amount = amount * battle_config.bg_reward_rates / 100;
+
+	memset(&it, 0, sizeof(it));
+	it.nameid = nameid;
+	it.identify = 1;
+
+	for (const auto& member : bg->members) {
+		if ( (sd = member.sd) == nullptr)
+			continue;
+
+		get_amount = amount;
+		if( rank ) get_amount += get_amount / 100;
+
+		if( (flag = pc_additem(sd,&it,get_amount, LOG_TYPE_SCRIPT)) )
+			clif_additem(sd,0,0,flag);
+	}
+}
+
+void bg_team_get_kafrapoints(int bg_id, int amount)
+{
+	struct map_session_data *sd;
+	int get_amount, rank = 0;
+	std::shared_ptr<s_battleground_data> bg = util::umap_find(bg_team_db, bg_id);
+
+	if( !bg )
+		return;
+
+	if( battle_config.bg_reward_rates != 100 )
+		amount = amount * battle_config.bg_reward_rates / 100;
+
+	for (const auto& member : bg->members) {
+		if ((sd = member.sd) == nullptr)
+			continue;
+
+		get_amount = amount;
+		if( rank ) get_amount += get_amount / 100;
+		pc_getcash(sd,0,get_amount,LOG_TYPE_NPC);
+	}
+}
+
+void bg_team_rewards_all(const char* bg_map, int team_id1, int team_id2, int nameid, int amount, int bg_result)
+{
+	std::shared_ptr<s_battleground_type> bgdata = bg_search_mapname(bg_map);
+
+	if (!bgdata)
+		return;
+
+	if (bg_result == 1) {
+		bg_team_rewards(team_id1, nameid, bgdata->reward_winner + amount, 0, 0, bgdata->variable.c_str(), 1, bgdata->id);
+		bg_team_rewards(team_id2, nameid, bgdata->reward_looser + amount, 0, 0, bgdata->variable.c_str(), 1, bgdata->id);
+	}
+	else if (bg_result == 2) {
+		bg_team_rewards(team_id1, nameid, bgdata->reward_looser + amount, 0, 0, bgdata->variable.c_str(), 1, bgdata->id);
+		bg_team_rewards(team_id2, nameid, bgdata->reward_winner + amount, 0, 0, bgdata->variable.c_str(), 1, bgdata->id);
+	}
+	else {
+		bg_team_rewards(team_id1, nameid, bgdata->reward_draw + amount, 0, 0, bgdata->variable.c_str(), 1, bgdata->id);
+		bg_team_rewards(team_id2, nameid, bgdata->reward_draw + amount, 0, 0, bgdata->variable.c_str(), 1, bgdata->id);
+	}
+
+}
+/* ==============================================================
+   bg_arena (0 EoS | 1 Boss | 2 TI | 3 CTF | 4 TD | 5 SC | 6 CON | 7 RUSH | 8 DOM)
+   bg_result (0 Draw | 1 Team1 win | 2 Team2 win)
+   ============================================================== */
+void bg_team_rewards(int bg_id, int nameid, int amount, int kafrapoints, int quest_id, const char *var, int add_value, int bg_arena)
+{
+	struct map_session_data *sd;
+	struct item_data *id;
+	struct item it;
+	int flag, get_amount, rank = 0;
+
+	std::shared_ptr<s_battleground_data> bg = util::umap_find(bg_team_db, bg_id);
+	std::shared_ptr<s_battleground_type> bgdata = battleground_db.find(bg_arena);
+
+	if( amount < 1 || !bg || !bgdata || (id = itemdb_exists(nameid)) == NULL )
+		return;
+
+	if( battle_config.bg_reward_rates != 100 )
+	{ // BG Reward Rates
+		amount = amount * battle_config.bg_reward_rates / 100;
+		kafrapoints = kafrapoints * battle_config.bg_reward_rates / 100;
+	}
+
+	memset(&it,0,sizeof(it));
+	if( nameid == 7804 || nameid == 7828 || nameid == 7829 || nameid == 7773 )
+	{
+		it.nameid = nameid;
+		it.identify = 1;
+	}
+	else nameid = 0;
+
+	for (const auto& pl_sd : bg->members) {
+		sd = pl_sd.sd;
+
+		if (sd) {
+
+			if (quest_id) quest_add(sd, quest_id);
+			if (add_value) {
+				pc_setglobalreg(sd, add_str(var), pc_readglobalreg(sd, add_str(var)) + add_value);
+
+				char output[CHAT_SIZE_MAX];
+				memset(output, '\0', sizeof(output));
+				int final_value = (int)pc_readglobalreg(sd, reference_uid(add_str(var), 0));
+				sprintf(output, msg_txt(sd, 452), bgdata->name);
+				std::string final_str = output + std::to_string(final_value);
+				clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], final_str.c_str(), false, SELF);
+			}
+			if (kafrapoints > 0)
+			{
+				get_amount = kafrapoints;
+				if (rank) get_amount += get_amount / 100;
+				pc_getcash(sd, 0, get_amount, LOG_TYPE_NPC);
+			}
+
+			if (nameid && amount > 0)
+			{
+				get_amount = amount;
+				if (rank) get_amount += get_amount / 100;
+
+				if ((flag = pc_additem(sd, &it, get_amount, LOG_TYPE_SCRIPT)))
+				{
+					clif_additem(sd, 0, 0, flag);
+				}
+			}
+		}
+	}
+}
 
+int battleground_countlogin(struct map_session_data *sd, bool check_bat_room)
+{
+	int c = 0, m = map_mapname2mapid("bat_room");
+	struct map_session_data* pl_sd;
+	struct s_mapiterator* iter;
+	nullpo_ret(sd);
+
+	iter = mapit_getallusers();
+	for( pl_sd = (TBL_PC*)mapit_first(iter); mapit_exists(iter); pl_sd = (TBL_PC*)mapit_next(iter) )
+	{
+		if( !(pl_sd->bg_queue_id || map_getmapflag(pl_sd->bl.m, MF_BATTLEGROUND) || (check_bat_room && pl_sd->bl.m == m)) )
+			continue;
+		/*if( session[sd->fd]->gepard_info.unique_id == session[pl_sd->fd]->gepard_info.unique_id )
+			c++;*/
+	}
+	mapit_free(iter);
+	return c;
+}
+int bg_checkskill(std::shared_ptr<s_battleground_data> bg, int id)
+{
+	int idx = id - GD_SKILLBASE;
+	if( idx < 0 || idx >= MAX_GUILDSKILL || !bg->g )
+		return 0;
+	return bg->g->skill[idx].lv;
+}
+
+void bg_reload(void)
+{ // @reloadscript
+	/*
+	bg_team_db->destroy(bg_team_db,bg_team_db_reset);
+	queue_db->destroy(queue_db, queue_db_final);
+
+	bg_team_db = idb_alloc(DB_OPT_RELEASE_DATA);
+	queue_db = idb_alloc(DB_OPT_RELEASE_DATA);
+
+	bg_team_counter = 0;
+	queue_counter = 0;
+	*/
+ }
+ 
 /**
  * Initialize the Battleground data
  */
@@ -1569,6 +2268,8 @@ void do_init_battleground(void)
 	add_timer_func_list(bg_on_ready_expire, "bg_on_ready_expire");
 	add_timer_func_list(bg_on_ready_start, "bg_on_ready_start");
 	add_timer_interval(gettick() + battle_config.bg_update_interval, bg_send_xy_timer, 0, 0, battle_config.bg_update_interval);
+	bg_guild_build_data();
+	ShowMessage(CL_WHITE"[BattleGround]: " CL_RESET "BG Extended by (c) Vykimo, www.vykimo.com\n");
 }
 
 /**
@@ -1576,4 +2277,7 @@ void do_init_battleground(void)
  */
 void do_final_battleground(void)
 {
+ 	//bg_team_db->destroy(bg_team_db, NULL);
 }
+
+
diff --git a/src/map/battleground.hpp b/src/map/battleground.hpp
index 5b23b36db..36074fc40 100644
--- a/src/map/battleground.hpp
+++ b/src/map/battleground.hpp
@@ -14,6 +14,8 @@
 
 #define MAX_BG_MEMBERS 30
 
+extern struct guild bg_guild[];
+
 struct s_battleground_member_data {
 	unsigned short x, y;
 	struct map_session_data *sd;
@@ -28,10 +30,25 @@ struct s_battleground_data {
 	std::string logout_event; ///< NPC Event to call on log out events
 	std::string die_event; ///< NPC Event to call on death events
 	std::string active_event; ///< NPC Event to call on players joining an active battleground
+	
+	// [Vykimo]
+	int palette; ///< Team Palette
+	time_t creation_tick; // Creation of this Team
+	// Team Leader and BG Skills features
+	int leader_char_id;
+	int skill_block_timer[MAX_GUILDSKILL];
+	unsigned int color;
+	// Fake Guild Link
+	struct guild *g;
+	bool reveal_pos, reveal_flag;
+	// Score Board
+	int team_score;
+	std::map<map_session_data*, map_session_data*> voteleader;
 };
 
 struct s_battleground_team {
 	int16 warp_x, warp_y; ///< Team respawn coordinates
+	int16 palette; ///< Team Palette [Vykimo]
 	std::string quit_event, ///< Team NPC Event to call on log out events
 		death_event, ///< Team NPC Event to call on death events
 		active_event, ///< Team NPC Event to call on players joining an active battleground
@@ -43,6 +60,7 @@ struct s_battleground_map {
 	uint16 mapindex; ///< Index of the map
 	s_battleground_team team1, team2; ///< Team data
 	std::string bgcallscript; ///< Script to be called when players join the battleground
+	std::string bgendcallscript; ///< Script to be called when premature end of the current battleground
 	bool isReserved; ///< Reserve BG maps that are used so that the system won't create multiple BG instances on the same map
 };
 
@@ -73,6 +91,11 @@ struct s_battleground_queue {
 struct s_battleground_type {
 	int id; ///< Battlegrounds database ID
 	std::string name; ///< Name of the battleground type
+	std::string variable; ///< Variable name for reward
+	unsigned int color; ///< Color for announce [Vykimo]
+	int reward_winner; ///< Reward for Winner
+	int reward_looser; ///< Reward for Looser
+	int reward_draw; ///< Reward for Draw
 	int required_players; ///< Amount of players required on each side to start
 	int max_players; ///< Maximum amount of players on each side
 	int min_lvl; ///< Minimum level to participate in this battleground type
@@ -99,6 +122,8 @@ enum e_bg_queue_apply_ack : uint16 {
 	BG_APPLY_RECONNECT, ///< Reconnect then apply
 	BG_APPLY_PARTYGUILD_LEADER, ///< Only party/guild leader can apply
 	BG_APPLY_PLAYER_CLASS, ///< Your class can't apply
+	BG_DUPLICATE_UNIQUE_ID, ///< Your unique id is already in the queue
+	BG_UNACTIVATED ///< BG is off
 };
 
 /// Enum of script command bg_info types
@@ -110,6 +135,10 @@ enum e_bg_info : uint16 {
 	BG_INFO_MAX_LEVEL,
 	BG_INFO_MAPS,
 	BG_INFO_DESERTER_TIME,
+	BG_INFO_NAME,
+	BG_INFO_VARIABLE,
+	BG_INFO_COLOR,
+	BG_TOTAL_ARENA,
 };
 
 class BattlegroundDatabase : public TypesafeYamlDatabase<uint32, s_battleground_type> {
@@ -126,8 +155,10 @@ extern BattlegroundDatabase battleground_db;
 extern std::unordered_map<int, std::shared_ptr<s_battleground_data>> bg_team_db;
 extern std::vector<std::shared_ptr<s_battleground_queue>> bg_queues;
 
-std::shared_ptr<s_battleground_type> bg_search_name(const char *name);
+std::shared_ptr<s_battleground_type> bg_search_name(const char* name);
+std::shared_ptr<s_battleground_type> bg_search_mapname(const char* name);
 std::shared_ptr<s_battleground_queue> bg_search_queue(int queue_id);
+struct guild* bg_guild_get(int bg_id);
 void bg_send_dot_remove(struct map_session_data *sd);
 int bg_team_get_id(struct block_list *bl);
 struct map_session_data *bg_getavailablesd(s_battleground_data *bg);
@@ -136,10 +167,10 @@ bool bg_queue_reservation(const char *name, bool state, bool ended);
 #define bg_queue_reserve(name, end) (bg_queue_reservation(name, true, end))
 #define bg_queue_unbook(name) (bg_queue_reservation(name, false, false))
 
-int bg_create(uint16 mapindex, s_battleground_team* team);
+int bg_create(uint16 mapindex, s_battleground_team* team, int guild_index);
 bool bg_team_join(int bg_id, struct map_session_data *sd, bool is_queue);
 bool bg_team_delete(int bg_id);
-int bg_team_leave(struct map_session_data *sd, bool quit, bool deserter);
+int bg_team_leave(struct map_session_data *sd, bool quit, bool deserter, int flag);
 bool bg_team_warp(int bg_id, unsigned short mapindex, short x, short y);
 bool bg_player_is_in_bg_map(struct map_session_data *sd);
 bool bg_queue_check_joinable(std::shared_ptr<s_battleground_type> bg, struct map_session_data *sd, const char *name);
@@ -155,6 +186,25 @@ void bg_queue_start_battleground(std::shared_ptr<s_battleground_queue> queue);
 bool bg_member_respawn(struct map_session_data *sd);
 void bg_send_message(struct map_session_data *sd, const char *mes, int len);
 
+int battleground_countlogin(struct map_session_data *sd, bool check_bat_room);
+
+int bg_get_mode();
+void bg_set_mode(int mode);
+
+void bg_team_getitem(int bg_id, int nameid, int amount);
+void bg_team_get_kafrapoints(int bg_id, int amount);
+void bg_team_rewards(int bg_id, int nameid, int amount, int kafrapoints, int quest_id, const char *var, int add_value, int bg_arena);
+void bg_team_rewards_all(const char* bg_map, int team_id1, int team_id2, int nameid, int amount, int bg_result);
+
+int bg_team_clean(int bg_id, bool remove);
+int bg_checkskill(std::shared_ptr<s_battleground_data> bg, int id);
+int bg_move_team_queue(const char * from_bg_name, const char * target_bg_name);
+
+void (bg_start) (void);
+void (bg_end) (void);
+
+void bg_reload(void);
+
 void do_init_battleground(void);
 void do_final_battleground(void);
 
diff --git a/src/map/buyingstore.cpp b/src/map/buyingstore.cpp
index ecfa881f0..10d787d5d 100644
--- a/src/map/buyingstore.cpp
+++ b/src/map/buyingstore.cpp
@@ -12,6 +12,7 @@
 #include "../common/socket.hpp"  // RBUF*
 #include "../common/strlib.hpp"  // safestrncpy
 #include "../common/timer.hpp"  // gettick
+#include "../common/utils.hpp"  // gettick
 
 #include "atcommand.hpp"  // msg_txt
 #include "battle.hpp"  // battle_config.*
@@ -382,7 +383,7 @@ void buyingstore_trade( struct map_session_data* sd, uint32 account_id, unsigned
 				return;
 			}
 		}
-
+		int char_id;
 		int index = item->index - 2; // TODO: clif::server_index
 
 		// invalid input
@@ -397,6 +398,13 @@ void buyingstore_trade( struct map_session_data* sd, uint32 account_id, unsigned
 			return;
 		}
 
+		if( sd->inventory.u.items_inventory[index].card[0] == CARD0_CREATE && (char_id = MakeDWord(sd->inventory.u.items_inventory[index].card[2],sd->inventory.u.items_inventory[index].card[3])) > 0 && (char_id == battle_config.bg_reserved_char_id || char_id == battle_config.woe_reserved_char_id) )
+		{ // Items where creator's ID is important
+			clif_buyingstore_trade_failed_seller(sd, BUYINGSTORE_TRADE_SELLER_FAILED, item->itemId);
+			clif_displaymessage(sd->fd, "Cannot Trade event reserved Items (Battleground, WoE).");
+			return;
+		}
+
 		int listidx;
 
 		ARR_FIND( 0, pl_sd->buyingstore.slots, listidx, pl_sd->buyingstore.items[listidx].nameid == item->itemId );
diff --git a/src/map/clif.cpp b/src/map/clif.cpp
index fde43c8ca..3c953bfc9 100644
--- a/src/map/clif.cpp
+++ b/src/map/clif.cpp
@@ -472,17 +472,20 @@ int clif_send(const void* buf, int len, struct block_list* bl, enum send_target
 	int x0 = 0, x1 = 0, y0 = 0, y1 = 0, fd;
 	struct s_mapiterator* iter;
 
-	if( type != ALL_CLIENT )
+	if( type != ALL_CLIENT && type != BG_LISTEN )
 		nullpo_ret(bl);
 
 	sd = BL_CAST(BL_PC, bl);
 
 	switch(type) {
 
+	case BG_LISTEN:
 	case ALL_CLIENT: //All player clients.
 		iter = mapit_getallusers();
 		while( ( tsd = (map_session_data*)mapit_next( iter ) ) != nullptr ){
 			if( session_isActive( fd = tsd->fd ) ){
+				if( type == BG_LISTEN && !(tsd->state.bg_listen || tsd->bg_queue_id) )
+					continue;
 				WFIFOHEAD( fd, len );
 				memcpy( WFIFOP( fd, 0 ), buf, len );
 				WFIFOSET( fd, len );
@@ -678,6 +681,7 @@ int clif_send(const void* buf, int len, struct block_list* bl, enum send_target
 	case BG_SAMEMAP_WOS:
 	case BG:
 	case BG_WOS:
+		if (type != BG) break;
 		if( sd && sd->bg_id > 0 && (bg = util::umap_find(bg_team_db, sd->bg_id)))
 		{
 			for (const auto &member : bg->members) {
@@ -1066,7 +1070,7 @@ static void clif_set_unit_idle( struct block_list* bl, bool walking, send_target
 	struct map_session_data* sd = BL_CAST( BL_PC, bl );
 	struct status_change* sc = status_get_sc( bl );
 	struct view_data* vd = status_get_viewdata( bl );
-	int g_id = status_get_guild_id( bl );
+	int g_id = clif_visual_guild_id( bl );
 
 #if PACKETVER < 20091103
 	if( !pcdb_checkid( vd->class_ ) ){
@@ -1087,7 +1091,7 @@ static void clif_set_unit_idle( struct block_list* bl, bool walking, send_target
 		p.accessory = vd->head_bottom;
 		if( bl->type == BL_NPC && vd->class_ == JT_GUILD_FLAG ){
 			// The hell, why flags work like this?
-			p.shield = status_get_emblem_id( bl );
+			p.shield = clif_visual_emblem_id( bl );
 			p.accessory2 = GetWord( g_id, 1 );
 			p.accessory3 = GetWord( g_id, 0 );
 		}else{
@@ -1099,7 +1103,7 @@ static void clif_set_unit_idle( struct block_list* bl, bool walking, send_target
 		p.bodypalette = vd->cloth_color;
 		p.headDir = ( sd )? sd->head_dir : 0;
 		p.GUID = g_id;
-		p.GEmblemVer = status_get_emblem_id( bl );
+		p.GEmblemVer = clif_visual_emblem_id( bl );
 		p.honor = ( sd ) ? sd->status.manner : 0;
 		p.virtue = ( sc ) ? sc->opt3 : 0;
 		p.isPKModeON = ( sd && sd->status.karma ) ? 1 : 0;
@@ -1156,7 +1160,7 @@ static void clif_set_unit_idle( struct block_list* bl, bool walking, send_target
 #endif
 	if( bl->type == BL_NPC && vd->class_ == JT_GUILD_FLAG ){
 		// The hell, why flags work like this?
-		p.accessory = status_get_emblem_id( bl );
+		p.accessory = clif_visual_emblem_id( bl );
 		p.accessory2 = GetWord( g_id, 1 );
 		p.accessory3 = GetWord( g_id, 0 );
 	}else{
@@ -1171,7 +1175,7 @@ static void clif_set_unit_idle( struct block_list* bl, bool walking, send_target
 	p.robe = vd->robe;
 #endif
 	p.GUID = g_id;
-	p.GEmblemVer = status_get_emblem_id( bl );
+	p.GEmblemVer = clif_visual_emblem_id( bl );
 	p.honor = (sd) ? sd->status.manner : 0;
 	p.virtue = (sc) ? sc->opt3 : 0;
 	p.isPKModeON = (sd && sd->status.karma) ? 1 : 0;
@@ -1231,7 +1235,7 @@ static void clif_spawn_unit( struct block_list *bl, enum send_target target ){
 	struct map_session_data* sd = BL_CAST( BL_PC, bl );
 	struct status_change* sc = status_get_sc( bl );
 	struct view_data* vd = status_get_viewdata( bl );
-	int g_id = status_get_guild_id( bl );
+	int g_id = clif_visual_guild_id( bl );
 
 #if PACKETVER < 20091103
 	if( !pcdb_checkid( vd->class_ ) ){
@@ -1252,7 +1256,7 @@ static void clif_spawn_unit( struct block_list *bl, enum send_target target ){
 		p.job = vd->class_;
 		if( bl->type == BL_NPC && vd->class_ == JT_GUILD_FLAG ){
 			// The hell, why flags work like this?
-			p.shield = status_get_emblem_id( bl );
+			p.shield = clif_visual_emblem_id( bl );
 			p.accessory2 = GetWord( g_id, 1 );
 			p.accessory3 = GetWord( g_id, 0 );
 		}else{
@@ -1298,7 +1302,7 @@ static void clif_spawn_unit( struct block_list *bl, enum send_target target ){
 #endif
 	if( bl->type == BL_NPC && vd->class_ == JT_GUILD_FLAG ){
 		// The hell, why flags work like this?
-		p.accessory = status_get_emblem_id( bl );
+		p.accessory = clif_visual_emblem_id( bl );
 		p.accessory2 = GetWord( g_id, 1 );
 		p.accessory3 = GetWord( g_id, 0 );
 	}else{
@@ -1313,7 +1317,7 @@ static void clif_spawn_unit( struct block_list *bl, enum send_target target ){
 	p.robe = vd->robe;
 #endif
 	p.GUID = g_id;
-	p.GEmblemVer = status_get_emblem_id( bl );
+	p.GEmblemVer = clif_visual_emblem_id( bl );
 	p.honor = (sd) ? sd->status.manner : 0;
 	p.virtue = (sc) ? sc->opt3 : 0;
 	p.isPKModeON = (sd && sd->status.karma) ? 1 : 0;
@@ -1383,7 +1387,7 @@ static void clif_set_unit_walking( struct block_list *bl, struct map_session_dat
 	struct status_change* sc = status_get_sc( bl );
 	struct view_data* vd = status_get_viewdata( bl );
 	struct packet_unit_walking p;
-	int g_id = status_get_guild_id(bl);
+	int g_id = clif_visual_guild_id(bl);
 
 	sd = BL_CAST(BL_PC, bl);
 
@@ -1421,7 +1425,7 @@ static void clif_set_unit_walking( struct block_list *bl, struct map_session_dat
 	p.robe = vd->robe;
 #endif
 	p.GUID = g_id;
-	p.GEmblemVer = status_get_emblem_id(bl);
+	p.GEmblemVer = clif_visual_emblem_id(bl);
 	p.honor = (sd) ? sd->status.manner : 0;
 	p.virtue = (sc) ? sc->opt3 : 0;
 	p.isPKModeON = (sd && sd->status.karma) ? 1 : 0;
@@ -2153,7 +2157,7 @@ void clif_buylist( struct map_session_data *sd, struct npc_data *nd ){
 /// 00c7 <packet len>.W { <index>.W <price>.L <overcharge price>.L }*
 void clif_selllist(struct map_session_data *sd)
 {
-	int fd,i,c=0,val;
+	int fd,i,c=0,val,char_id;
 	struct npc_data *nd;
 
 	nullpo_retv(sd);
@@ -2170,6 +2174,15 @@ void clif_selllist(struct map_session_data *sd)
 			if( !pc_can_sell_item(sd, &sd->inventory.u.items_inventory[i], nd->subtype))
 				continue;
 
+			if( sd->inventory.u.items_inventory[i].card[0] == CARD0_CREATE )
+			{ // Do not allow sell BG - Ancient Items
+				char_id = MakeDWord(sd->inventory.u.items_inventory[i].card[2],sd->inventory.u.items_inventory[i].card[3]);
+				if( battle_config.bg_reserved_char_id && char_id == battle_config.bg_reserved_char_id )
+					continue;
+				if( battle_config.woe_reserved_char_id && char_id == battle_config.woe_reserved_char_id )
+					continue;
+			}
+
 			if (battle_config.rental_item_novalue && sd->inventory.u.items_inventory[i].expire_time)
 				val = 0;
 			else {
@@ -4738,6 +4751,8 @@ static void clif_getareachar_pc(struct map_session_data* sd,struct map_session_d
 	)
 	clif_hpmeter_single(sd->fd, dstsd->bl.id, dstsd->battle_status.hp, dstsd->battle_status.max_hp);
 
+	if( (sd->bg_id && sd->bg_id == dstsd->bg_id))
+		clif_bg_hp_single(sd->fd,dstsd);
 	// display link (sd - dstsd) to sd
 	ARR_FIND( 0, MAX_DEVOTION, i, sd->devotion[i] == dstsd->bl.id );
 	if( i < MAX_DEVOTION )
@@ -7939,8 +7954,8 @@ void clif_party_hp(struct map_session_data *sd)
 	clif_send(buf,packet_len(cmd),&sd->bl,PARTY_AREA_WOS);
 }
 
-/// Notifies the party members of a character's death or revival.
-/// 0AB2 <GID>.L <dead>.B
+/// Updates the job and level of a party member
+/// 0abd <account id>.L <job>.W <level>.W
 void clif_party_dead( struct map_session_data *sd ){
 #if PACKETVER >= 20170502
 	unsigned char buf[7];
@@ -8482,16 +8497,21 @@ void clif_guild_created(struct map_session_data *sd,int flag)
 /// mode:
 ///     &0x01 = allow invite
 ///     &0x10 = allow expel
-void clif_guild_belonginfo(struct map_session_data *sd)
+void clif_guild_belonginfo(struct map_session_data *sd, struct guild *g)
 {
 	int ps,fd;
-	struct guild* g;
 
 	nullpo_retv(sd);
-	nullpo_retv(g = sd->guild);
+
+	if( sd->bg_id )
+	{
+		clif_bg_belonginfo(sd);
+		return;
+	}
+	nullpo_retv(g);
 
 	fd=sd->fd;
-	ps=guild_getposition(sd);
+	ps=guild_getposition(g,sd);
 	WFIFOHEAD(fd,packet_len(0x16c));
 	WFIFOW(fd,0)=0x16c;
 	WFIFOL(fd,2)=g->guild_id;
@@ -8608,6 +8628,7 @@ void clif_guild_masterormember(struct map_session_data *sd)
 void clif_guild_basicinfo(struct map_session_data *sd) {
 	int fd;
 	struct guild *g;
+	std::shared_ptr<s_battleground_data> bg;
 #if PACKETVER < 20160622
 	int cmd = 0x1b6;
 	int offset = NAME_LENGTH;
@@ -8619,14 +8640,19 @@ void clif_guild_basicinfo(struct map_session_data *sd) {
 	nullpo_retv(sd);
 	fd = sd->fd;
 
-	if( (g = sd->guild) == NULL )
+	if (sd->bg_id && (g = bg_guild_get(sd->bg_id)) != NULL) {
+		bg = util::umap_find(bg_team_db, sd->bg_id);
+	} else
+		g = sd->guild;
+
+	if( g == NULL )
 		return;
 
 	WFIFOHEAD(fd,packet_len(cmd));
 	WFIFOW(fd, 0)=cmd;
 	WFIFOL(fd, 2)=g->guild_id;
 	WFIFOL(fd, 6)=g->guild_lv;
-	WFIFOL(fd,10)=g->connect_member;
+	WFIFOL(fd,10)=bg?bg->members.size():g->connect_member;
 	WFIFOL(fd,14)=g->max_member;
 	WFIFOL(fd,18)=g->average_lv;
 	WFIFOL(fd,22)=(uint32)cap_value(g->exp, 0, MAX_GUILD_EXP);
@@ -8642,7 +8668,10 @@ void clif_guild_basicinfo(struct map_session_data *sd) {
 	safestrncpy(WFIFOCP(fd,70+offset),msg_txt(sd,300+guild_checkcastles(g)),16); // "'N' castles"
 	WFIFOL(fd,70+offset+16) = 0;  // zeny
 #if PACKETVER >= 20160622
-	WFIFOL(fd,70+offset+20) = g->member[0].char_id;  // leader
+	if(bg != NULL) {
+			WFIFOL(fd,70+offset+20) = bg->leader_char_id ? bg->leader_char_id : 0;  // leader
+	} else
+		WFIFOL(fd,70+offset+20) = g->member[0].char_id;  // guild master
 #endif
 
 	WFIFOSET(fd,packet_len(cmd));
@@ -8657,7 +8686,9 @@ void clif_guild_allianceinfo(struct map_session_data *sd)
 	struct guild *g;
 
 	nullpo_retv(sd);
-	if( (g = sd->guild) == NULL )
+	if( !(sd->bg_id && (g = bg_guild_get(sd->bg_id)) != NULL) )
+		g = sd->guild;
+	if( g == NULL )
 		return;
 
 	fd = sd->fd;
@@ -8702,6 +8733,11 @@ void clif_guild_memberlist(struct map_session_data *sd)
 
 	if( !session_isActive(fd = sd->fd) )
 		return;
+	if (sd->bg_id)
+	{
+		clif_bg_memberlist(sd);
+		return;
+	}
 	if( (g = sd->guild) == NULL )
 		return;
 
@@ -8742,7 +8778,9 @@ void clif_guild_positionnamelist(struct map_session_data *sd)
 	struct guild *g;
 
 	nullpo_retv(sd);
-	if( (g = sd->guild) == NULL )
+	if( !(sd->bg_id && (g = bg_guild_get(sd->bg_id)) != NULL) )
+		g = sd->guild;
+	if( g == NULL )
 		return;
 
 	fd = sd->fd;
@@ -8875,8 +8913,8 @@ void clif_guild_emblem_area(struct block_list* bl)
 	PACKET_ZC_CHANGE_GUILD p{};
 
 	p.packetType = HEADER_ZC_CHANGE_GUILD;
-	p.guild_id = status_get_guild_id(bl);
-	p.emblem_id = status_get_emblem_id(bl);
+	p.guild_id = clif_visual_guild_id(bl);
+	p.emblem_id = clif_visual_emblem_id(bl);
 
 #if PACKETVER < 20190724
 	p.aid = bl->id;
@@ -8897,7 +8935,10 @@ void clif_guild_skillinfo(struct map_session_data* sd)
 	int i,c;
 
 	nullpo_retv(sd);
-	if( (g = sd->guild) == NULL )
+	if( !(sd->bg_id && (g = bg_guild_get(sd->bg_id)) != NULL) )
+		g = sd->guild;
+
+	if( g == NULL )
 		return;
 
 	fd = sd->fd;
@@ -8957,17 +8998,25 @@ void clif_guild_invite(struct map_session_data *sd,struct guild *g)
 	int fd;
 
 	nullpo_retv(sd);
-	nullpo_retv(g);
 
-	fd=sd->fd;
-	WFIFOHEAD(fd,packet_len(0x16a));
-	WFIFOW(fd,0)=0x16a;
-	WFIFOL(fd,2)=g->guild_id;
-	safestrncpy(WFIFOCP(fd,6),g->name,NAME_LENGTH);
+	fd = sd->fd;
+	WFIFOHEAD(fd, packet_len(0x16a));
+	WFIFOW(fd, 0) = 0x16a;
+
+	if (sd->bg_id) {
+		g = bg_guild_get(sd->bg_id);
+		WFIFOL(fd, 2) = g->guild_id;
+		safestrncpy(WFIFOCP(fd, 6), g->name, NAME_LENGTH);
+	}
+	else {
+		nullpo_retv(g);
+
+		WFIFOL(fd, 2) = g->guild_id;
+		safestrncpy(WFIFOCP(fd, 6), g->name, NAME_LENGTH);
+	}
 	WFIFOSET(fd,packet_len(0x16a));
 }
 
-
 /// Reply to invite request (ZC_ACK_REQ_JOIN_GUILD).
 /// 0169 <answer>.B
 /// answer:
@@ -9746,10 +9795,10 @@ void clif_name( struct block_list* src, struct block_list *bl, send_target targe
 	nullpo_retv( src );
 	nullpo_retv( bl );
 
+	std::shared_ptr<s_battleground_data> bg;
 	switch( bl->type ){
 		case BL_PC: {
 			PACKET_ZC_ACK_REQNAMEALL packet = { 0 };
-
 			packet.packet_id = HEADER_ZC_ACK_REQNAMEALL;
 			packet.gid = bl->id;
 
@@ -9775,18 +9824,31 @@ void clif_name( struct block_list* src, struct block_list *bl, send_target targe
 			}
 
 			// do not display party unless the player is also in a guild
-			if( p && ( sd->guild || battle_config.display_party_name ) ){
+			if( p && ( sd->guild || sd->bg_id || battle_config.display_party_name ) ){
 				safestrncpy( packet.party_name, p->party.name, NAME_LENGTH );
 			}
 
-			if( sd->guild ){
+			if( sd->guild || sd->bg_id){
 				int position;
 
+				struct guild *g;
+
+				if( sd->bg_id ) {
+					g = bg_guild_get(sd->bg_id);
+					if (!g) return;
+					position = sd->bmaster_flag ? 0 : 1;
+					safestrncpy(packet.guild_name, g->name, NAME_LENGTH);
+					safestrncpy(packet.position_name, g->position[position].name, NAME_LENGTH);
+				}
+				else {
+					g = sd->guild;
+
 				// Will get the position of the guild the player is in
-				position = guild_getposition( sd );
+					position = guild_getposition( g, sd );
 
 				safestrncpy( packet.guild_name, sd->guild->name, NAME_LENGTH );
 				safestrncpy( packet.position_name, sd->guild->position[position].name, NAME_LENGTH );
+				}
 			}else if( sd->clan ){
 				safestrncpy( packet.position_name, sd->clan->name, NAME_LENGTH );
 			}
@@ -9840,8 +9902,8 @@ void clif_name( struct block_list* src, struct block_list *bl, send_target targe
 		}
 			break;
 		case BL_MOB: {
+			struct guild *g;
 			mob_data *md = (mob_data *)bl;
-
 			if( md->guardian_data && md->guardian_data->guild_id ){
 				PACKET_ZC_ACK_REQNAMEALL packet = { 0 };
 
@@ -9850,9 +9912,20 @@ void clif_name( struct block_list* src, struct block_list *bl, send_target targe
 				safestrncpy( packet.name, md->name, NAME_LENGTH );
 				safestrncpy( packet.guild_name, md->guardian_data->guild_name, NAME_LENGTH );
 				safestrncpy( packet.position_name, md->guardian_data->castle->castle_name, NAME_LENGTH );
+				clif_send(&packet, sizeof(packet), src, target);
+			}
+			else if (md->bg_id && (bg = (util::umap_find(bg_team_db, md->bg_id))) && (g = bg->g) != NULL)
+			{
+				PACKET_ZC_ACK_REQNAMEALL packet = { 0 };
 
+				packet.packet_id = HEADER_ZC_ACK_REQNAMEALL;
+				packet.gid = bl->id;
+				safestrncpy(packet.name, md->name, NAME_LENGTH);
+				safestrncpy(packet.guild_name, g->name, NAME_LENGTH);
+				safestrncpy(packet.position_name, g->position[0].name, NAME_LENGTH);
 				clif_send(&packet, sizeof(packet), src, target);
-			}else if( battle_config.show_mob_info ){
+			}
+			else if( battle_config.show_mob_info ){
 				PACKET_ZC_ACK_REQNAMEALL packet = { 0 };
 
 				packet.packet_id = HEADER_ZC_ACK_REQNAMEALL;
@@ -10385,6 +10458,8 @@ static bool clif_process_message(struct map_session_data* sd, bool whisperFormat
 
 	//achievement_update_objective(sd, AG_CHATTING, 1, 1); // !TODO: Confirm how this achievement is triggered
 
+	pc_update_last_action(sd, 0, IDLE_CHAT);
+	
 	return true;
 }
 
@@ -10641,7 +10716,14 @@ void clif_parse_LoadEndAck(int fd,struct map_session_data *sd)
 
 	if( sd->bg_id ) clif_bg_hp(sd); // BattleGround System
 
-	if(!pc_isinvisible(sd) && mapdata->flag[MF_PVP]) {
+	if( sd->state.changemap && mapdata->flag[MF_BATTLEGROUND] )
+	{
+		clif_map_type(sd, MAPTYPE_BATTLEFIELD); // Battleground Mode
+		if( mapdata->flag[MF_BATTLEGROUND] >= 2 )
+			clif_bg_updatescore_single(sd); // Score board only need update on change map
+	}
+
+	if(mapdata->flag[MF_PVP] && !pc_isinvisible(sd)) {
 		if(!battle_config.pk_mode) { // remove pvp stuff for pk_mode [Valaris]
 			if (!mapdata->flag[MF_PVP_NOCALCRANK])
 				sd->pvp_timer = add_timer(gettick()+200, pc_calc_pvprank_timer, sd->bl.id, 0);
@@ -10768,6 +10850,7 @@ void clif_parse_LoadEndAck(int fd,struct map_session_data *sd)
 			//Login Event
 			npc_script_event(sd, NPCE_LOGIN);
 		}
+
 	} else {
 		//For some reason the client "loses" these on warp/map-change.
 		clif_updatestatus(sd,SP_STR);
@@ -10933,7 +11016,7 @@ void clif_parse_LoadEndAck(int fd,struct map_session_data *sd)
 	}
 
 	// Trigger skill effects if you appear standing on them
-	if(!battle_config.pc_invincible_time)
+	if(!battle_config.pc_invincible_time || sd->sc.data[SC_FULLINVINCIBLE])
 		skill_unit_move(&sd->bl,gettick(),1);
 
 	pc_show_questinfo_reinit(sd);
@@ -11177,6 +11260,9 @@ void clif_parse_WalkToXY(int fd, struct map_session_data *sd)
 
 	pc_delinvincibletimer(sd);
 
+	if( !pc_update_last_action(sd,2,IDLE_WALK) )
+		return;
+
 	//Set last idle time... [Skotlex]
 	if (battle_config.idletime_option&IDLE_WALK)
 		sd->idletime = last_tick;
@@ -11486,6 +11572,8 @@ void clif_parse_ActionRequest_sub(struct map_session_data *sd, int action_type,
 			}
 		}
 
+		if( !pc_update_last_action(sd,2,IDLE_ATTACK) )
+			return;
 		pc_delinvincibletimer(sd);
 		if (battle_config.idletime_option&IDLE_ATTACK)
 			sd->idletime = last_tick;
@@ -11548,6 +11636,8 @@ void clif_parse_ActionRequest_sub(struct map_session_data *sd, int action_type,
 		}
 
 		if (pc_setstand(sd, false)) {
+			if( !pc_update_last_action(sd,1,IDLE_SIT) )
+				break;
 			if (battle_config.idletime_option&IDLE_SIT)
 				sd->idletime = last_tick;
 			if (battle_config.hom_idle_no_share && sd->hd && battle_config.idletime_hom_option&IDLE_SIT)
@@ -11842,6 +11932,9 @@ void clif_parse_UseItem(int fd, struct map_session_data *sd)
 		return;
 	}
 
+	if( !pc_update_last_action(sd,1,IDLE_USEITEM) )
+		return;
+
 	//Whether the item is used or not is irrelevant, the char ain't idle. [Skotlex]
 	if (battle_config.idletime_option&IDLE_USEITEM)
 		sd->idletime = last_tick;
@@ -12326,6 +12419,7 @@ void clif_parse_PutItemToCart(int fd,struct map_session_data *sd)
 	if (!pc_iscarton(sd))
 		return;
 	pc_putitemtocart(sd,RFIFOW(fd,info->pos[0])-2,RFIFOL(fd,info->pos[1]));
+	pc_update_last_action(sd,0,IDLE_WALK);
 }
 
 
@@ -12337,6 +12431,7 @@ void clif_parse_GetItemFromCart(int fd,struct map_session_data *sd)
 	if (!pc_iscarton(sd))
 		return;
 	pc_getitemfromcart(sd,RFIFOW(fd,info->pos[0])-2,RFIFOL(fd,info->pos[1]));
+	pc_update_last_action(sd,0,IDLE_WALK);
 }
 
 
@@ -12597,6 +12692,8 @@ void clif_parse_skill_toid( struct map_session_data* sd, uint16 skill_id, uint16
 		return;
 	}
 
+	if( !pc_update_last_action(sd,1 + (inf&INF_SELF_SKILL ? 0 : 2),IDLE_USESKILLTOID) )
+		return;
 	// Whether skill fails or not is irrelevant, the char ain't idle. [Skotlex]
 	// This is done here, because homunculi and mercenaries can be triggered by AI and not by the player itself
 	if (battle_config.idletime_option&IDLE_USESKILLTOID)
@@ -12671,10 +12768,18 @@ void clif_parse_skill_toid( struct map_session_data* sd, uint16 skill_id, uint16
 	sd->skillitem = sd->skillitemlv = 0;
 
 	if( SKILL_CHK_GUILD(skill_id) ) {
-		if( sd->state.gmaster_flag || skill_id == GD_CHARGESHOUT_BEATING )
-			skill_lv = guild_checkskill(sd->guild, skill_id);
-		else
-			skill_lv = 0;
+		if( !map_getmapflag(sd->bl.m, MF_BATTLEGROUND) ) {
+			if( sd->state.gmaster_flag || skill_id == GD_CHARGESHOUT_BEATING )
+				skill_lv = guild_checkskill(sd->guild, skill_id);
+			else
+				skill_lv = 0;
+		} else {
+			std::shared_ptr<s_battleground_data> bg;
+			if( (bg = sd->bmaster_flag) != NULL )
+				skill_lv = bg_checkskill(bg, skill_id);
+			else
+				skill_lv = 0;
+		}
 	} else {
 		if( skill_id != ALL_EQSWITCH ){
 			skill_lv = min(pc_checkskill(sd, skill_id),skill_lv); //never trust client
@@ -12730,6 +12835,8 @@ static void clif_parse_UseSkillToPosSub(int fd, struct map_session_data *sd, uin
 		return;
 	}
 
+	if( !pc_update_last_action(sd,3,IDLE_USESKILLTOPOS) )
+		return;
 	//Whether skill fails or not is irrelevant, the char ain't idle. [Skotlex]
 	if (battle_config.idletime_option&IDLE_USESKILLTOPOS)
 		sd->idletime = last_tick;
@@ -13240,6 +13347,7 @@ void clif_parse_MoveToKafra(int fd, struct map_session_data *sd)
 		storage_guild_storageadd(sd, item_index, item_amount);
 	else if (sd->state.storage_flag == 3)
 		storage_storageadd(sd, &sd->premiumStorage, item_index, item_amount);
+	pc_update_last_action(sd,0,IDLE_WALK);
 }
 
 
@@ -13261,6 +13369,7 @@ void clif_parse_MoveFromKafra(int fd,struct map_session_data *sd)
 		storage_guild_storageget(sd, item_index, item_amount);
 	else if(sd->state.storage_flag == 3)
 		storage_storageget(sd, &sd->premiumStorage, item_index, item_amount);
+	pc_update_last_action(sd,0,IDLE_WALK);
 }
 
 
@@ -13290,6 +13399,7 @@ void clif_parse_MoveToKafraFromCart(int fd, struct map_session_data *sd){
 		storage_guild_storageaddfromcart(sd, idx, amount);
 	else if (sd->state.storage_flag == 3)
 		storage_storageaddfromcart(sd, &sd->premiumStorage, idx, amount);
+	pc_update_last_action(sd,0,IDLE_WALK);
 }
 
 
@@ -13312,6 +13422,7 @@ void clif_parse_MoveFromKafraToCart(int fd, struct map_session_data *sd){
 		storage_guild_storagegettocart(sd, idx, amount);
 	else if (sd->state.storage_flag == 3)
 		storage_storagegettocart(sd, &sd->premiumStorage, idx, amount);
+	pc_update_last_action(sd,0,IDLE_WALK);
 }
 
 
@@ -13326,6 +13437,7 @@ void clif_parse_CloseKafra(int fd, struct map_session_data *sd)
 		storage_guild_storageclose(sd);
 	else if( sd->state.storage_flag == 3 )
 		storage_premiumStorage_close(sd);
+	pc_update_last_action(sd,0,IDLE_WALK);
 }
 
 
@@ -13971,10 +14083,16 @@ void clif_parse_GuildChangeMemberPosition(int fd, struct map_session_data *sd)
 void clif_parse_GuildRequestEmblem(int fd,struct map_session_data *sd)
 {
 	struct guild* g;
+	int i;
 	int guild_id = RFIFOL(fd,packet_db[RFIFOW(fd,0)].pos[0]);
 
 	if( (g = guild_search(guild_id)) != NULL )
 		clif_guild_emblem(sd,g);
+	else if( guild_id > INT16_MAX - 13 && guild_id <= INT16_MAX )
+	{
+		i = (int)(INT16_MAX - guild_id);
+		clif_bg_emblem(sd, &bg_guild[i]);
+	}
 }
 
 
@@ -17923,6 +18041,28 @@ void clif_bg_hp(struct map_session_data *sd) {
 	clif_send(buf, packet_len(cmd), &sd->bl, BG_AREA_WOS);
 }
 
+void clif_bg_hp_single(int fd, struct map_session_data* ssd)
+{
+	const int cmd = 0x2e0;
+	nullpo_retv(ssd);
+
+	WFIFOHEAD(fd,packet_len(cmd));
+	WFIFOW(fd,0) = cmd;
+	WFIFOL(fd,2) = ssd->bl.id;
+	memcpy(WFIFOP(fd,6),ssd->status.name, NAME_LENGTH);
+	if( ssd->battle_status.max_hp > INT16_MAX )
+	{
+		WFIFOW(fd,30) = ssd->battle_status.hp/(ssd->battle_status.max_hp/100);
+		WFIFOW(fd,32) = 100;
+	}
+	else
+	{
+		WFIFOW(fd,30) = ssd->battle_status.hp;
+		WFIFOW(fd,32) = ssd->battle_status.max_hp;
+	}
+
+	WFIFOSET(fd,packet_len(cmd));
+}
 
 /// Updates the position of a camp member on the minimap (ZC_BATTLEFIELD_NOTIFY_POSITION).
 /// 02df <account id>.L <name>.24B <class>.W <x>.W <y>.W
@@ -17940,6 +18080,150 @@ void clif_bg_xy(struct map_session_data *sd)
 
 	clif_send(buf, packet_len(0x2df), &sd->bl, BG_SAMEMAP_WOS);
 }
+void clif_bg_belonginfo(struct map_session_data *sd)
+{
+	int fd;
+	struct guild *g;
+	nullpo_retv(sd);
+ 	if( !(sd->bg_id && (g = bg_guild_get(sd->bg_id)) != NULL) )
+		return;
+ 	fd = sd->fd;
+	WFIFOHEAD(fd,packet_len(0x16c));
+	memset(WFIFOP(fd,0),0,packet_len(0x16c));
+	WFIFOW(fd,0) = 0x16c;
+	WFIFOL(fd,2) = g->guild_id;
+	WFIFOL(fd,6) = g->emblem_id;
+	WFIFOL(fd,10) = 0;
+	WFIFOB(fd,14) = 0;
+	WFIFOL(fd,15) = 0;
+	memcpy(WFIFOP(fd,19), g->name, NAME_LENGTH);
+	WFIFOSET(fd,packet_len(0x16c));
+}
+
+int clif_visual_guild_id(struct block_list *bl)
+{
+	std::shared_ptr<s_battleground_data> bg;
+	int bg_id;
+	nullpo_ret(bl);
+
+	if( (bg_id = bg_team_get_id(bl)) > 0 && (bg = util::umap_find(bg_team_db, bg_team_get_id(bl))) && bg->g )
+		return bg->g->guild_id;
+	else
+		return status_get_guild_id(bl);
+}
+
+int clif_visual_emblem_id(struct block_list *bl)
+{
+	int bg_id;
+	nullpo_ret(bl);
+	std::shared_ptr<s_battleground_data> bg;
+
+	if( (bg_id = bg_team_get_id(bl)) > 0 && (bg = util::umap_find(bg_team_db, bg_team_get_id(bl))) && bg->g )
+		return bg->g->emblem_id;
+	else
+		return status_get_emblem_id(bl);
+}
+
+void clif_bg_emblem(struct map_session_data *sd, struct guild *g)
+{
+	int fd;
+
+	nullpo_retv(sd);
+	nullpo_retv(g);
+
+	if( g->emblem_len <= 0 )
+		return;
+
+	fd = sd->fd;
+	WFIFOHEAD(fd,g->emblem_len+12);
+	WFIFOW(fd,0)=0x152;
+	WFIFOW(fd,2)=g->emblem_len+12;
+	WFIFOL(fd,4)=g->guild_id;
+	WFIFOL(fd,8)=g->emblem_id;
+	memcpy(WFIFOP(fd,12),g->emblem_data,g->emblem_len);
+	WFIFOSET(fd,WFIFOW(fd,2));
+}
+
+void clif_bg_memberlist(struct map_session_data *sd)
+{
+	int fd, c = 0;
+	struct map_session_data *psd;
+	nullpo_retv(sd);
+	std::shared_ptr<s_battleground_data> bg;
+
+	if( (fd = sd->fd) == 0 )
+		return;
+	if( !(sd->bg_id && (bg = util::umap_find(bg_team_db, sd->bg_id))))
+		return;
+
+	WFIFOHEAD(fd,bg->members.size() * 104 + 4);
+	WFIFOW(fd,0) = 0x154;
+	for (const auto& member : bg->members) {
+		if ((psd = member.sd) == nullptr)
+			continue;
+		WFIFOL(fd,c*104+ 4) = psd->status.account_id;
+		WFIFOL(fd,c*104+ 8) = psd->status.char_id;
+		WFIFOW(fd,c*104+12) = psd->status.hair;
+		WFIFOW(fd,c*104+14) = psd->status.hair_color;
+		WFIFOW(fd,c*104+16) = psd->status.sex;
+		WFIFOW(fd,c*104+18) = psd->status.class_;
+		WFIFOW(fd,c*104+20) = psd->status.base_level;
+		WFIFOL(fd,c*104+22) = 0;
+		WFIFOL(fd,c*104+26) = 1; // Online
+		WFIFOL(fd,c*104+30) = psd->bmaster_flag ? 0 : 1; // Position
+		if( psd->state.bg_afk )
+			memcpy(WFIFOP(fd,c*104+34),"AFK",50);
+		else
+			memset(WFIFOP(fd,c*104+34),0,50);
+		memcpy(WFIFOP(fd,c*104+84),psd->status.name,NAME_LENGTH);
+		c++;
+	}
+	WFIFOW(fd, 2)=c*104+4;
+	WFIFOSET(fd,WFIFOW(fd,2));
+}
+
+void clif_bg_leave(struct map_session_data *sd, const char *name, const char *mes)
+{
+	unsigned char buf[128];
+	nullpo_retv(sd);
+
+	WBUFW(buf,0)=0x15a;
+	memcpy(WBUFP(buf, 2),name,NAME_LENGTH);
+	memcpy(WBUFP(buf,26),mes,40);
+	clif_send(buf,packet_len(0x15a),&sd->bl,BG);
+}
+
+void clif_bg_leave_single(struct map_session_data *sd, const char *name, const char *mes)
+{
+	int fd;
+	nullpo_retv(sd);
+
+	fd = sd->fd;
+	WFIFOHEAD(fd,66);
+	WFIFOW(fd,0) = 0x15a;
+	memcpy(WFIFOP(fd,2), name, NAME_LENGTH);
+	memcpy(WFIFOP(fd,26), mes, 40);
+	WFIFOSET(fd,66);
+}
+void clif_bg_expulsion_single(struct map_session_data *sd, const char *name, const char *mes)
+{
+	unsigned char buf[128];
+#if PACKETVER < 20100803
+	const unsigned short cmd = 0x15c;
+#else
+	const unsigned short cmd = 0x839;
+#endif
+
+	nullpo_retv(sd);
+
+	WBUFW(buf,0) = cmd;
+	safestrncpy((char*)WBUFP(buf,2), name, NAME_LENGTH);
+	safestrncpy((char*)WBUFP(buf,26), mes, 40);
+#if PACKETVER < 20100803
+	memset(WBUFP(buf,66), 0, NAME_LENGTH); // account name (not used for security reasons)
+#endif
+	clif_send(buf, packet_len(cmd), &sd->bl, SELF);
+}
 
 void clif_bg_xy_remove(struct map_session_data *sd)
 {
diff --git a/src/map/clif.hpp b/src/map/clif.hpp
index 5b430d6db..7ed31a633 100644
--- a/src/map/clif.hpp
+++ b/src/map/clif.hpp
@@ -224,6 +224,7 @@ enum send_target : uint8_t {
 	BG_SAMEMAP_WOS,
 	BG_AREA,
 	BG_AREA_WOS,
+	BG_LISTEN,			// All players listening BG announcements
 
 	CLAN,				// Clan System
 };
@@ -798,7 +799,7 @@ void clif_party_dead( struct map_session_data *sd );
 
 // guild
 void clif_guild_created(struct map_session_data *sd,int flag);
-void clif_guild_belonginfo(struct map_session_data *sd);
+void clif_guild_belonginfo(struct map_session_data *sd, struct guild *g);
 void clif_guild_masterormember(struct map_session_data *sd);
 void clif_guild_basicinfo(struct map_session_data *sd);
 void clif_guild_allianceinfo(struct map_session_data *sd);
@@ -827,8 +828,17 @@ void clif_guild_xy_remove(struct map_session_data *sd);
 
 // Battleground
 void clif_bg_hp(struct map_session_data *sd);
+void clif_bg_hp_single(int fd, struct map_session_data* ssd);
 void clif_bg_xy(struct map_session_data *sd);
 void clif_bg_xy_remove(struct map_session_data *sd);
+void clif_bg_belonginfo(struct map_session_data *sd);
+int clif_visual_guild_id(struct block_list *bl);
+int clif_visual_emblem_id(struct block_list *bl);
+void clif_bg_emblem(struct map_session_data *sd, struct guild *g);
+void clif_bg_memberlist(struct map_session_data *sd);
+void clif_bg_leave(struct map_session_data *sd, const char *name, const char *mes);
+void clif_bg_leave_single(struct map_session_data *sd, const char *name, const char *mes);
+void clif_bg_expulsion_single(struct map_session_data *sd, const char *name, const char *mes);
 void clif_bg_message(struct s_battleground_data *bg, int src_id, const char *name, const char *mes, int len);
 void clif_bg_updatescore(int16 m);
 void clif_bg_updatescore_single(struct map_session_data *sd);
@@ -837,6 +847,7 @@ void clif_sendbgemblem_single(int fd, struct map_session_data *sd);
 
 // Battleground Queue
 void clif_bg_queue_apply_result(e_bg_queue_apply_ack result, const char *name, struct map_session_data *sd);
+void clif_bg_queue_cancel_result(bool success, const char* name, struct map_session_data* sd);
 void clif_bg_queue_apply_notify(const char *name, struct map_session_data *sd);
 void clif_bg_queue_entry_init(struct map_session_data *sd);
 void clif_bg_queue_lobby_notify(const char *name, struct map_session_data *sd);
diff --git a/src/map/guild.cpp b/src/map/guild.cpp
index 06b3fac20..6fa4ce649 100644
--- a/src/map/guild.cpp
+++ b/src/map/guild.cpp
@@ -390,11 +390,11 @@ int guild_getindex(struct guild *g,uint32 account_id,uint32 char_id) {
 }
 
 /// lookup: player sd -> member position
-int guild_getposition(struct map_session_data* sd) {
+int guild_getposition(struct guild* g, struct map_session_data* sd) {
 	int i;
-	struct guild *g;
 
-	nullpo_retr( -1, g = sd->guild );
+	if( g == NULL && (g=sd->guild) == NULL )
+		return -1;
 
 	ARR_FIND( 0, g->max_member, i, g->member[i].account_id == sd->status.account_id && g->member[i].char_id == sd->status.char_id );
 	return( i < g->max_member ) ? g->member[i].position : -1;
@@ -704,7 +704,7 @@ int guild_recv_info(struct guild *sg) {
 			clif_guild_skillinfo(sd); //Submit information skills
 
 		if (guild_new) { // Send information and affiliation if unsent
-			clif_guild_belonginfo(sd);
+			clif_guild_belonginfo(sd,g);
 			clif_guild_notice(sd);
 			sd->guild_emblem_id = g->emblem_id;
 		}
@@ -740,7 +740,7 @@ int guild_invite(struct map_session_data *sd, struct map_session_data *tsd) {
 	if(tsd==NULL || g==NULL)
 		return 0;
 
-	if( (i=guild_getposition(sd))<0 || !(g->position[i].mode&GUILD_PERM_INVITE) )
+	if( (i=guild_getposition(g,sd))<0 || !(g->position[i].mode&GUILD_PERM_INVITE) )
 		return 0; //Invite permission.
 
 	if(!battle_config.invite_request_check) {
@@ -896,7 +896,7 @@ int guild_member_added(int guild_id,uint32 account_id,uint32 char_id,int flag) {
 	sd->guild_emblem_id = g->emblem_id;
 	sd->guild = g;
 	//Packets which were sent in the previous 'guild_sent' implementation.
-	clif_guild_belonginfo(sd);
+	clif_guild_belonginfo(sd,g);
 	clif_guild_notice(sd);
 
 	//TODO: send new emblem info to others
@@ -954,7 +954,7 @@ int guild_expulsion(struct map_session_data* sd, int guild_id, uint32 account_id
 	if(sd->status.guild_id!=guild_id)
 		return 0;
 
-	if( (ps=guild_getposition(sd))<0 || !(g->position[ps].mode&GUILD_PERM_EXPEL) )
+	if( (ps=guild_getposition(g,sd))<0 || !(g->position[ps].mode&GUILD_PERM_EXPEL) )
 		return 0;	//Expulsion permission
 
 	//Can't leave inside guild castles.
@@ -1120,7 +1120,7 @@ int guild_send_memberinfoshort(struct map_session_data *sd,int online) { // clea
 	}
 
 	if(sd->state.connect_new) {	//Note that this works because it is invoked in parse_LoadEndAck before connect_new is cleared.
-		clif_guild_belonginfo(sd);
+		clif_guild_belonginfo(sd,g);
 		sd->guild_emblem_id = g->emblem_id;
 	}
 	return 0;
@@ -1361,7 +1361,7 @@ int guild_emblem_changed(int len,int guild_id,int emblem_id,const char *data) {
 	for(i=0;i<g->max_member;i++){
 		if((sd=g->member[i].sd)!=NULL){
 			sd->guild_emblem_id=emblem_id;
-			clif_guild_belonginfo(sd);
+			clif_guild_belonginfo(sd,g);
 			clif_guild_emblem(sd,g);
 			clif_guild_emblem_area(&sd->bl);
 		}
@@ -1429,7 +1429,7 @@ t_exp guild_payexp(struct map_session_data *sd,t_exp exp) {
 
 	if (sd->status.guild_id == 0 ||
 		(g = sd->guild) == NULL ||
-		(per = guild_getposition(sd)) < 0 ||
+		(per = guild_getposition(g,sd)) < 0 ||
 		(per = g->position[per].exp_mode) < 1)
 		return 0;
 
@@ -2013,7 +2013,7 @@ int guild_gm_changed(int guild_id, uint32 account_id, uint32 char_id, time_t tim
 		if( g->member[i].sd && g->member[i].sd->fd ) {
 			clif_guild_basicinfo(g->member[i].sd);
 			clif_guild_memberlist(g->member[i].sd);
-			clif_guild_belonginfo(g->member[i].sd); // Update clientside guildmaster flag
+			clif_guild_belonginfo(g->member[i].sd,g); // Update clientside guildmaster flag
 		}
 	}
 
diff --git a/src/map/guild.hpp b/src/map/guild.hpp
index 2cdf14d0f..d0637d905 100644
--- a/src/map/guild.hpp
+++ b/src/map/guild.hpp
@@ -40,7 +40,7 @@ struct guild *guild_searchname(char *str);
 
 struct map_session_data *guild_getavailablesd(struct guild *g);
 int guild_getindex(struct guild *g,uint32 account_id,uint32 char_id);
-int guild_getposition(struct map_session_data *sd);
+int guild_getposition(struct guild *g, struct map_session_data *sd);
 t_exp guild_payexp(struct map_session_data *sd,t_exp exp);
 t_exp guild_getexp(struct map_session_data *sd,t_exp exp); // [Celest]
 
diff --git a/src/map/map.cpp b/src/map/map.cpp
index 94e0553de..dbc11b544 100644
--- a/src/map/map.cpp
+++ b/src/map/map.cpp
@@ -133,6 +133,7 @@ int map_port=0;
 int autosave_interval = DEFAULT_AUTOSAVE_INTERVAL;
 int minsave_interval = 100;
 int16 save_settings = CHARSAVE_ALL;
+bool bg_flag = false;
 bool agit_flag = false;
 bool agit2_flag = false;
 bool agit3_flag = false;
@@ -1958,6 +1959,18 @@ void map_reqnickdb(struct map_session_data * sd, int charid)
 
 	nullpo_retv(sd);
 
+	if( battle_config.bg_reserved_char_id && battle_config.bg_reserved_char_id == charid )
+	{
+		clif_solved_charname(sd->fd, charid, "Battleground");
+		return;
+	}
+
+	if( battle_config.woe_reserved_char_id && battle_config.woe_reserved_char_id == charid )
+	{
+		clif_solved_charname(sd->fd, charid, "WoE");
+		return;
+	}
+
 	tsd = map_charid2sd(charid);
 	if( tsd )
 	{
@@ -2067,7 +2080,7 @@ int map_quit(struct map_session_data *sd) {
 		npc_event_dequeue(sd);
 
 	if (sd->bg_id)
-		bg_team_leave(sd, true, true);
+		bg_team_leave(sd, true, true, 1);
 
 	if (sd->bg_queue_id > 0)
 		bg_queue_leave(sd, false);
diff --git a/src/map/map.hpp b/src/map/map.hpp
index cea14f50a..464633c17 100644
--- a/src/map/map.hpp
+++ b/src/map/map.hpp
@@ -560,7 +560,7 @@ enum e_mapflag : int16 {
 	MF_FOG,
 	MF_SAKURA,
 	MF_LEAVES,
-	//MF_RAIN,	//20 - No longer available, keeping here just in case it's back someday. [Ind]
+// used by map_setcell()
 	// 21 free
 	MF_NOGO = 22,
 	MF_CLOUDS,
@@ -612,6 +612,9 @@ enum e_mapflag : int16 {
 	MF_SKILL_DURATION,
 	MF_NOCASHSHOP,
 	MF_NORODEX,
+	MF_NOEMERGENCYCALL,
+	MF_ALLOW_BG_ITEMS,
+	MF_ALLOW_WOE_ITEMS,
 	MF_MAX
 };
 
@@ -801,6 +804,7 @@ extern int enable_spy; //Determines if @spy commands are active.
 extern uint32 start_status_points;
 
 // Agit Flags
+extern bool bg_flag;
 extern bool agit_flag;
 extern bool agit2_flag;
 extern bool agit3_flag;
@@ -913,6 +917,26 @@ inline bool mapdata_flag_gvg2_no_te(struct map_data *mapdata) {
 	return false;
 }
 
+inline bool mapdata_gvg_items(struct map_data *mapdata) {
+	if (mapdata == nullptr)
+		return false;
+
+	if (mapdata->flag[MF_GVG] || ((agit_flag || agit2_flag || agit3_flag) && mapdata->flag[MF_GVG_CASTLE]) || mapdata->flag[MF_ALLOW_WOE_ITEMS])
+		return true;
+
+	return false;
+}
+
+inline bool mapdata_bg_items(struct map_data *mapdata) {
+	if (mapdata == nullptr)
+		return false;
+
+	if (mapdata->flag[MF_BATTLEGROUND] || mapdata->flag[MF_ALLOW_BG_ITEMS])
+		return true;
+
+	return false;
+}
+
 /// Backwards compatibility
 inline bool map_flag_vs(int16 m) {
 	if (m < 0)
@@ -977,6 +1001,24 @@ inline bool map_flag_gvg2_no_te(int16 m) {
 	return mapdata_flag_gvg2_no_te(mapdata);
 }
 
+inline bool map_gvg_items(int16 m) {
+	if (m < 0)
+		return false;
+
+	struct map_data *mapdata = &map[m];
+
+	return mapdata_gvg_items(mapdata);
+}
+
+inline bool map_bg_items(int16 m) {
+	if (m < 0)
+		return false;
+
+	struct map_data *mapdata = &map[m];
+
+	return mapdata_bg_items(mapdata);
+}
+
 extern char motd_txt[];
 extern char charhelp_txt[];
 extern char channel_conf[];
diff --git a/src/map/mob.cpp b/src/map/mob.cpp
index 752367bb8..787a8d807 100644
--- a/src/map/mob.cpp
+++ b/src/map/mob.cpp
@@ -920,7 +920,7 @@ int mob_spawn_guardian(const char* mapname, int16 x, int16 y, const char* mobnam
 /*==========================================
  * Summoning BattleGround [Zephyrus]
  *------------------------------------------*/
-int mob_spawn_bg(const char* mapname, int16 x, int16 y, const char* mobname, int mob_id, const char* event, unsigned int bg_id)
+int mob_spawn_bg(const char* mapname, int16 x, int16 y, const char* mobname, int mob_id, const char* event, unsigned int bg_id, unsigned int size)
 {
 	struct mob_data *md = nullptr;
 	struct spawn_data data;
@@ -959,6 +959,10 @@ int mob_spawn_bg(const char* mapname, int16 x, int16 y, const char* mobname, int
 	mob_spawn(md);
 	md->bg_id = bg_id; // BG Team ID
 
+	md->special_state.ai = AI_ATTACK;
+	md->special_state.size = size;
+	sc_start4(NULL,&md->bl, SC_MODECHANGE, 100, 1, 0, MD_AGGRESSIVE, 0, 60000);
+
 	return md->bl.id;
 }
 
diff --git a/src/map/mob.hpp b/src/map/mob.hpp
index 671f29bcb..e407ea182 100644
--- a/src/map/mob.hpp
+++ b/src/map/mob.hpp
@@ -454,7 +454,7 @@ int mob_once_spawn_area(struct map_session_data* sd, int16 m,
 bool mob_ksprotected (struct block_list *src, struct block_list *target);
 
 int mob_spawn_guardian(const char* mapname, int16 x, int16 y, const char* mobname, int mob_id, const char* event, int guardian, bool has_index);	// Spawning Guardians [Valaris]
-int mob_spawn_bg(const char* mapname, int16 x, int16 y, const char* mobname, int mob_id, const char* event, unsigned int bg_id);
+int mob_spawn_bg(const char* mapname, int16 x, int16 y, const char* mobname, int mob_id, const char* event, unsigned int bg_id, unsigned int size);
 int mob_guardian_guildchange(struct mob_data *md); //Change Guardian's ownership. [Skotlex]
 
 int mob_randomwalk(struct mob_data *md,t_tick tick);
diff --git a/src/map/npc.cpp b/src/map/npc.cpp
index 1d6482b18..38779a98b 100644
--- a/src/map/npc.cpp
+++ b/src/map/npc.cpp
@@ -2238,6 +2238,15 @@ uint8 npc_selllist(struct map_session_data* sd, int n, unsigned short *item_list
 			return 1;
 		}
 
+		if( sd->inventory.u.items_inventory[idx].card[0] == CARD0_CREATE )
+		{
+			int char_id = MakeDWord(sd->inventory.u.items_inventory[idx].card[2],sd->inventory.u.items_inventory[idx].card[3]);
+			if( battle_config.bg_reserved_char_id && char_id == battle_config.bg_reserved_char_id )
+				return 1;
+			if( battle_config.woe_reserved_char_id && char_id == battle_config.woe_reserved_char_id )
+				return 1;
+		}
+		
 		if( nd->master_nd )
 		{// Script-controlled shops decide by themselves, what can be sold and at what price.
 			continue;
@@ -3857,9 +3866,9 @@ void npc_unsetcells(struct npc_data* nd)
 		return;
 
 	struct map_data *mapdata = map_getmapdata(m);
-
 	//Locate max range on which we can locate npc cells
 	//FIXME: does this really do what it's supposed to do? [ultramage]
+	//FIXME: does this really do what it's supposed to do? [ultramage]
 	for(x0 = x-xs; x0 > 0 && map_getcell(m, x0, y, CELL_CHKNPC); x0--);
 	for(x1 = x+xs; x1 < mapdata->xs-1 && map_getcell(m, x1, y, CELL_CHKNPC); x1++);
 	for(y0 = y-ys; y0 > 0 && map_getcell(m, x, y0, CELL_CHKNPC); y0--);
@@ -4319,7 +4328,7 @@ static const char* npc_parse_mapflag(char* w1, char* w2, char* w3, char* w4, con
 
 				if (sscanf(w4, "%11d", &args.flag_val) == 1)
 					map_setmapflag_sub(m, MF_RESTRICTED, true, &args);
-				else // Could not be read, no value defined; don't remove as other restrictions may be set on the map
+			else //No level specified, block everyone.
 					ShowWarning("npc_parse_mapflag: Zone value not set for the restricted mapflag! Skipped flag from %s (file '%s', line '%d').\n", map_mapid2mapname(m), filepath, strline(buffer,start-buffer));
 			} else
 				map_setmapflag(m, MF_RESTRICTED, false);
@@ -4335,7 +4344,7 @@ static const char* npc_parse_mapflag(char* w1, char* w2, char* w3, char* w4, con
 				map_setmapflag_sub(m, mapflag, state, &args);
 			}
 			break;
-
+                                //we don't remove has other restricted may be set on the map
 		case MF_SKILL_DAMAGE: {
 			char skill_name[SKILL_NAME_LENGTH];
 			char caster_constant[NAME_LENGTH];
diff --git a/src/map/party.cpp b/src/map/party.cpp
index f9e70b131..38a377d1a 100644
--- a/src/map/party.cpp
+++ b/src/map/party.cpp
@@ -13,11 +13,13 @@
 #include "../common/socket.hpp" // last_tick
 #include "../common/strlib.hpp"
 #include "../common/timer.hpp"
+#include "../common/utilities.hpp"
 #include "../common/utils.hpp"
 
 #include "achievement.hpp"
 #include "atcommand.hpp"	//msg_txt()
 #include "battle.hpp"
+#include "battleground.hpp"
 #include "clif.hpp"
 #include "instance.hpp"
 #include "intif.hpp"
@@ -28,6 +30,8 @@
 #include "pc_groups.hpp"
 #include "trade.hpp"
 
+using namespace rathena;
+
 static DBMap* party_db; // int party_id -> struct party_data* (releases data)
 static DBMap* party_booking_db; // uint32 char_id -> struct party_booking_ad_info* (releases data) // Party Booking [Spiria]
 static unsigned long party_booking_nextid = 1;
@@ -1248,42 +1252,69 @@ int party_sub_count_class(struct block_list *bl, va_list ap)
 
 	return 1;
 }
+bool party_foreachsamemap_loop(struct map_session_data* sd, struct map_session_data* psd, int range, int x0, int x1, int y0, int y1) {
+	if (!psd || !sd)
+		return false;
+
+	if (psd->bl.m != sd->bl.m || !psd->bl.prev)
+		return false;
+
+	if (range &&
+		(psd->bl.x<x0 || psd->bl.y<y0 ||
+		 psd->bl.x>x1 || psd->bl.y>y1))
+		return false;
 
+	return true;
+}
 /// Executes 'func' for each party member on the same map and in range (0:whole map)
 int party_foreachsamemap(int (*func)(struct block_list*,va_list),struct map_session_data *sd,int range,...)
 {
 	struct party_data *p;
+	std::shared_ptr<s_battleground_data> bg;
+	struct map_session_data* psd;
 	int i;
 	int x0,y0,x1,y1;
-	struct block_list *list[MAX_PARTY];
 	int blockcount=0;
 	int total = 0; //Return value.
 
 	nullpo_ret(sd);
 
-	if((p = party_search(sd->status.party_id)) == NULL)
-		return 0;
+	bool bg_mode = (map_getmapflag(sd->bl.m, MF_BATTLEGROUND)>0);
+	struct block_list **list = (struct block_list**)aCalloc(1, bg_mode ? MAX_BG_MEMBERS : MAX_PARTY);
+	
+	if(bg_mode) {
+		if(!(bg = util::umap_find(bg_team_db, bg_team_get_id(&sd->bl))))
+			return 0;
+	} else {
+		if((p = party_search(sd->status.party_id)) == NULL)
+			return 0;
+	}
 
 	x0 = sd->bl.x-range;
 	y0 = sd->bl.y-range;
 	x1 = sd->bl.x+range;
 	y1 = sd->bl.y+range;
 
-	for(i = 0; i < MAX_PARTY; i++) {
-		struct map_session_data *psd = p->data[i].sd;
 
-		if(!psd)
-			continue;
+	if (bg_mode) {
+		for (auto& pl_sd : bg->members) {
+			psd = pl_sd.sd;
 
-		if(psd->bl.m!=sd->bl.m || !psd->bl.prev)
-			continue;
+			if (psd == nullptr || !party_foreachsamemap_loop(sd, psd, range, x0, x1, y0, y1))
+				continue;
 
-		if(range &&
-			(psd->bl.x<x0 || psd->bl.y<y0 ||
-			 psd->bl.x>x1 || psd->bl.y>y1 ) )
-			continue;
+			list[blockcount++] = &psd->bl;
+		}
+	}
+	else {
+		for (i = 0; i < MAX_PARTY; i++) {
+			psd = p->data[i].sd;
 
-		list[blockcount++]=&psd->bl;
+			if (!party_foreachsamemap_loop(sd, psd, range, x0, x1, y0, y1))
+				continue;
+
+			list[blockcount++] = &psd->bl;
+		}
 	}
 
 	map_freeblock_lock();
diff --git a/src/map/pc.cpp b/src/map/pc.cpp
index 80a9dac46..0b6319528 100755
--- a/src/map/pc.cpp
+++ b/src/map/pc.cpp
@@ -495,6 +495,36 @@ void pc_delete_bg_queue_timer(map_session_data *sd) {
 		sd->tid_queue_active = INVALID_TIMER;
 	}
 }
+/***********************************************************
+* Update Idle PC Timer
+* Type
+* 0 = Send By Server
+* 1 = KeyBoard Action
+* 2 = Mouse Click
+* 3 = Both Hands
+***********************************************************/
+int pc_update_last_action(struct map_session_data *sd, int type, enum idletime_option idle_option)
+{
+	nullpo_ret(sd);
+
+	t_tick tick = gettick();
+
+	if( !(battle_config.idletime_option&idle_option) )
+		return 1;
+
+	sd->idletime = last_tick;
+
+	std::shared_ptr<s_battleground_data> bg;
+	if( sd->bg_id && sd->state.bg_afk && (bg = util::umap_find(bg_team_db, sd->bg_id)) && bg->g )
+	{ // Battleground AFK announce
+		char output[128];
+		sprintf(output, "%s : %s is no longer away...", bg->g->name, sd->status.name);
+		clif_bg_message(bg.get(), sd->bg_id, bg->g->name, output, strlen(output) + 1);
+		sd->state.bg_afk = 0;
+	}
+
+	return 1;
+}
 
 static TIMER_FUNC(pc_invincible_timer){
 	struct map_session_data *sd;
@@ -1845,6 +1875,7 @@ void pc_reg_received(struct map_session_data *sd)
 
 	// Cooking Exp
 	sd->cook_mastery = static_cast<short>(pc_readglobalreg(sd, add_str(COOKMASTERY_VAR)));
+	sd->bg_team = static_cast<short>(pc_readglobalreg(sd,add_str("Bat_Team")));
 
 	if( (sd->class_&MAPID_BASEMASK) == MAPID_TAEKWON )
 	{ // Better check for class rather than skill to prevent "skill resets" from unsetting this
@@ -1903,6 +1934,7 @@ void pc_reg_received(struct map_session_data *sd)
 		return;
 	sd->state.active = 1;
 	sd->state.pc_loaded = false; // Ensure inventory data and status data is loaded before we calculate player stats
+	sd->state.bg_listen = 1;
 
 	intif_storage_request(sd,TABLE_STORAGE, 0, STOR_MODE_ALL); // Request storage data
 	intif_storage_request(sd,TABLE_CART, 0, STOR_MODE_ALL); // Request cart data
@@ -5159,10 +5191,41 @@ int pc_getcash(struct map_session_data *sd, int cash, int points, e_log_pick_typ
  **/
 short pc_search_inventory(struct map_session_data *sd, t_itemid nameid) {
 	short i;
+	int char_id;
 	nullpo_retr(-1, sd);
 
-	ARR_FIND( 0, MAX_INVENTORY, i, sd->inventory.u.items_inventory[i].nameid == nameid && (sd->inventory.u.items_inventory[i].amount > 0 || nameid == 0) );
-	return ( i < MAX_INVENTORY ) ? i : -1;
+	if( nameid )
+	{
+		if( map_bg_items(sd->bl.m) && battle_config.bg_reserved_char_id )
+		{ // Battleground Items
+			ARR_FIND( 0, MAX_INVENTORY, i, sd->inventory.u.items_inventory[i].nameid == nameid && sd->inventory.u.items_inventory[i].amount > 0 && sd->inventory.u.items_inventory[i].card[0] == CARD0_CREATE && MakeDWord(sd->inventory.u.items_inventory[i].card[2],sd->inventory.u.items_inventory[i].card[3]) == battle_config.bg_reserved_char_id );
+			if( i < MAX_INVENTORY ) return i;
+}
+		else if( map_gvg_items(sd->bl.m) && battle_config.woe_reserved_char_id )
+		{ // WoE Items
+			ARR_FIND( 0, MAX_INVENTORY, i, sd->inventory.u.items_inventory[i].nameid == nameid && sd->inventory.u.items_inventory[i].amount > 0 && sd->inventory.u.items_inventory[i].card[0] == CARD0_CREATE && MakeDWord(sd->inventory.u.items_inventory[i].card[2],sd->inventory.u.items_inventory[i].card[3]) == battle_config.woe_reserved_char_id );
+			if( i < MAX_INVENTORY ) return i;
+		}
+	}
+
+	for( i = 0; i < MAX_INVENTORY; i++ )
+	{
+		if( sd->inventory.u.items_inventory[i].nameid != nameid )
+			continue;
+		if( nameid && sd->inventory.u.items_inventory[i].amount < 1 )
+			continue;
+		if( nameid && sd->inventory.u.items_inventory[i].card[0] == CARD0_CREATE && (char_id = MakeDWord(sd->inventory.u.items_inventory[i].card[2],sd->inventory.u.items_inventory[i].card[3])) > 0 )
+		{
+			if( !map_bg_items(sd->bl.m) && battle_config.bg_reserved_char_id && battle_config.bg_reserved_char_id == char_id )
+				continue;
+			if( !map_gvg_items(sd->bl.m) && battle_config.woe_reserved_char_id && battle_config.woe_reserved_char_id == char_id )
+				continue;
+		}
+
+		return i;
+	}
+
+	return -1;
 }
 
 /** Attempt to add a new item to player inventory
@@ -5614,7 +5677,7 @@ bool pc_isUseitem(struct map_session_data *sd,int n)
 int pc_useitem(struct map_session_data *sd,int n)
 {
 	t_tick tick = gettick();
-	int amount;
+	int amount,char_id;
 	t_itemid nameid;
 	struct script_code *script;
 	struct item item;
@@ -5644,12 +5707,24 @@ int pc_useitem(struct map_session_data *sd,int n)
 	if (item.nameid == 0 || item.amount <= 0)
 		return 0;
 
+	if( sd->state.only_walk )
+		return 0;
+
 	if( !pc_isUseitem(sd,n) )
 		return 0;
 
 	// Store information for later use before it is lost (via pc_delitem) [Paradox924X]
 	nameid = id->nameid;
 
+	if( item.card[0] == CARD0_CREATE )
+	{ // Do not allow use BG - Ancient Items on invalid maps
+		char_id = MakeDWord(item.card[2],item.card[3]);
+		if( battle_config.bg_reserved_char_id && char_id == battle_config.bg_reserved_char_id && !map_bg_items(sd->bl.m) )
+			return 0;
+		if( battle_config.woe_reserved_char_id && char_id == battle_config.woe_reserved_char_id && !map_gvg_items(sd->bl.m) )
+			return 0;
+	}
+	
 	if (nameid != ITEMID_NAUTHIZ && sd->sc.opt1 > 0 && sd->sc.opt1 != OPT1_STONEWAIT && sd->sc.opt1 != OPT1_BURNING)
 		return 0;
 
@@ -5700,8 +5775,12 @@ int pc_useitem(struct map_session_data *sd,int n)
 		else
 			clif_useitemack(sd, n, 0, false);
 	}
-	if (item.card[0]==CARD0_CREATE && pc_famerank(MakeDWord(item.card[2],item.card[3]), MAPID_ALCHEMIST))
+	if( item.card[0] == CARD0_CREATE && char_id && (char_id == battle_config.bg_reserved_char_id || char_id == battle_config.woe_reserved_char_id || pc_famerank(MakeDWord(item.card[2],item.card[3]), MAPID_ALCHEMIST)) )
+	{
 	    potion_flag = 2; // Famous player's potions have 50% more efficiency
+		 if (sd->sc.data[SC_SPIRIT] && sd->sc.data[SC_SPIRIT]->val2 == SL_ROGUE)
+			 potion_flag = 3; //Even more effective potions.
+	}
 
 	//Update item use time.
 	sd->canuseitem_tick = tick + battle_config.item_use_interval;
@@ -6104,6 +6183,8 @@ enum e_setpos pc_setpos(struct map_session_data* sd, unsigned short mapindex, in
 	sd->state.mail_writing = false;
 	sd->state.refineui_open = false;
 
+	sd->ud.state.blockedskill = 0;
+
 	if( sd->state.changemap ) { // Misc map-changing settings
 		int curr_map_instance_id = map_getmapdata(sd->bl.m)->instance_id, new_map_instance_id = (mapdata ? mapdata->instance_id : 0);
 
@@ -6118,9 +6199,10 @@ enum e_setpos pc_setpos(struct map_session_data* sd, unsigned short mapindex, in
 		}
 
 		if (sd->bg_id && mapdata && !mapdata->flag[MF_BATTLEGROUND]) // Moving to a map that isn't a Battlegrounds
-			bg_team_leave(sd, false, true);
+			bg_team_leave(sd, false, true, 1);
 
 		sd->state.pmap = sd->bl.m;
+		sd->state.only_walk = 0;
 		if (sc && sc->count) { // Cancel some map related stuff.
 			if (sc->data[SC_JAILED])
 				return SETPOS_MAPINDEX; //You may not get out!
@@ -6151,6 +6233,8 @@ enum e_setpos pc_setpos(struct map_session_data* sd, unsigned short mapindex, in
 		party_send_dot_remove(sd); //minimap dot fix [Kevin]
 		guild_send_dot_remove(sd);
 		bg_send_dot_remove(sd);
+		if( battle_config.bg_queue_onlytowns && sd->bg_queue_id && map_getmapflag(sd->bl.m, MF_TOWN) && !map_getmapflag(m, MF_TOWN) )
+			bg_queue_leave(sd);
 		if (sd->regen.state.gc)
 			sd->regen.state.gc = 0;
 		// make sure vending is allowed here
@@ -6190,7 +6274,7 @@ enum e_setpos pc_setpos(struct map_session_data* sd, unsigned short mapindex, in
 		}
 
 		if (sd->bg_id) // Switching map servers, remove from bg
-			bg_team_leave(sd, false, true);
+			bg_team_leave(sd, false, true, 1);
 
 		if (sd->state.vending) // Stop vending
 			vending_closevending(sd);
@@ -6300,6 +6384,10 @@ enum e_setpos pc_setpos(struct map_session_data* sd, unsigned short mapindex, in
 	else 
 		sd->count_rewarp = 0;
 	
+	union u_mapflag_args args = {};
+	if(map_getmapflag_sub(m, MF_BATTLEGROUND, &args) && battle_config.bg_invincible_time > 0)
+		sc_start(NULL, &sd->bl, SC_FULLINVINCIBLE, 10000, 1, battle_config.bg_invincible_time);
+	
 	return SETPOS_OK;
 }
 
@@ -9916,6 +10004,9 @@ bool pc_candrop(struct map_session_data *sd, struct item *item)
 bool pc_can_attack( struct map_session_data *sd, int target_id ) {
 	nullpo_retr(false, sd);
 
+	if( sd->state.only_walk )
+		return false;
+	
 	if( pc_is90overweight(sd) || pc_isridingwug(sd) )
 		return false;
 
diff --git a/src/map/pc.hpp b/src/map/pc.hpp
index 189fc6d47..f51863f47 100644
--- a/src/map/pc.hpp
+++ b/src/map/pc.hpp
@@ -338,6 +338,10 @@ struct map_session_data {
 		uint8 isBoundTrading; // Player is currently add bound item to trade list [Cydh]
 		bool ignoretimeout; // Prevent the SECURE_NPCTIMEOUT function from closing current script.
 		unsigned int workinprogress : 2; // See clif.hpp::e_workinprogress
+		unsigned int view_mob_info : 1;
+		unsigned int bg_listen : 1;
+		unsigned int bg_afk : 1; // Moved here to reduce searchs
+		unsigned int only_walk : 1; // [Zephyrus] Block Skills and Item usage to a player
 		bool pc_loaded; // Ensure inventory data and status data is loaded before we calculate player stats
 		bool keepshop; // Whether shop data should be removed when the player disconnects
 		bool mail_writing; // Whether the player is currently writing a mail in RODEX or not
@@ -703,6 +707,8 @@ struct map_session_data {
 	// Battlegrounds queue system [MasterOfMuppets]
 	int bg_id, bg_queue_id;
 	int tid_queue_active; ///< Timer ID associated with players joining an active BG
+	std::shared_ptr<s_battleground_data> bmaster_flag;
+	unsigned short bg_team;
 
 #ifdef SECURE_NPCTIMEOUT
 	/**
@@ -1431,6 +1437,8 @@ extern int night_timer_tid;
 TIMER_FUNC(map_day_timer); // by [yor]
 TIMER_FUNC(map_night_timer); // by [yor]
 
+int pc_update_last_action(struct map_session_data *sd, int type, enum idletime_option idle_option);
+
 // Rental System
 void pc_inventory_rentals(struct map_session_data *sd);
 void pc_inventory_rental_clear(struct map_session_data *sd);
diff --git a/src/map/script.cpp b/src/map/script.cpp
index a84cd4c6c..9ab4094a6 100644
--- a/src/map/script.cpp
+++ b/src/map/script.cpp
@@ -8239,6 +8239,13 @@ static bool buildin_delitem_search(struct map_session_data* sd, struct item* it,
 					if (j != MAX_ITEM_RDM_OPT)
 						continue;
 				}
+			} else if( itm->card[0] == CARD0_CREATE )
+			{
+				int char_id = MakeDWord(itm->card[2],itm->card[3]);
+				if( battle_config.bg_reserved_char_id && char_id == battle_config.bg_reserved_char_id && !map_bg_items(sd->bl.m) )
+					continue;
+				if( battle_config.woe_reserved_char_id && char_id == battle_config.woe_reserved_char_id && !map_gvg_items(sd->bl.m) )
+					continue;
 			}
 
 			// count / delete item
@@ -10470,7 +10477,12 @@ BUILDIN_FUNC(guild_has_permission){
 		return SCRIPT_CMD_SUCCESS;
 	}
 
-	int position = guild_getposition(sd);
+	struct guild* g;
+	int position;
+	if ((g = sd->guild) != NULL)
+		position = guild_getposition(g, sd);
+	else
+		position = 0;
 	
 	if( position < 0 || ( sd->guild->position[position].mode&permission ) != permission ){
 		script_pushint( st, false );
@@ -13993,10 +14005,12 @@ BUILDIN_FUNC(delwall)
 	const char *name = script_getstr(st,2);
 
 	if( !map_iwall_remove(name) ){
-		ShowError( "buildin_delwall: wall \"%s\" does not exist.\n", name );
+		script_pushint(st,0);
+		//ShowError( "buildin_delwall: wall \"%s\" does not exist.\n", name );
 		return SCRIPT_CMD_FAILURE;
 	}
 
+	script_pushint(st,1);
 	return SCRIPT_CMD_SUCCESS;
 }
 
@@ -15678,6 +15692,13 @@ BUILDIN_FUNC(getmapxy)
 		type = script_getnum(st, 5);
 
 	switch (type) {
+		case BL_MOB:	//Get Mob Position
+		   if (script_hasdata(st,6)) {
+			if (script_isstring(st,6))
+				break;
+			bl = map_id2bl(script_getnum(st,6));
+		   }
+		   break;
 		case BL_PC:	//Get Character Position
 			if ((script_isstring(st, 6) && script_nick2sd(6, sd)) || script_mapid2sd(6, sd))
 				bl = &sd->bl;
@@ -19102,8 +19123,9 @@ BUILDIN_FUNC(unitwalk)
 	if (!strcmp(cmd,"unitwalk")) {
 		int x = script_getnum(st,3);
 		int y = script_getnum(st,4);
+		int easy = script_hasdata(st, 6)?script_getnum(st,6):0;
 
-		if (script_pushint(st, unit_can_reach_pos(bl,x,y,0)))
+		if (script_pushint(st, unit_can_reach_pos(bl,x,y,easy)))
 			add_timer(gettick()+50, unit_delay_walktoxy_timer, bl->id, (x<<16)|(y&0xFFFF)); // Need timer to avoid mismatches
 	} else {
 		struct block_list* tbl = map_id2bl(script_getnum(st,3));
@@ -20298,8 +20320,8 @@ BUILDIN_FUNC(waitingroom2bg)
 	unsigned char i,c=0;
 	struct s_battleground_team team;
 
-	if( script_hasdata(st,7) )
-		nd = npc_name2id(script_getstr(st,7));
+	if( script_hasdata(st,9) )
+		nd = npc_name2id(script_getstr(st,9));
 	else
 		nd = (struct npc_data *)map_id2bl(st->oid);
 
@@ -20318,18 +20340,23 @@ BUILDIN_FUNC(waitingroom2bg)
 
 	team.warp_x = script_getnum(st,3);
 	team.warp_y = script_getnum(st,4);
-	if (script_hasdata(st,5)) {
-		team.quit_event = script_getstr(st,5); // Logout Event
+	int index = script_getnum(st, 5);
+	if (script_hasdata(st,6)) {
+		team.quit_event = script_getstr(st,6); // Logout Event
 		check_event(st, team.quit_event.c_str());
 	} else
 		team.quit_event = "";
-	if (script_hasdata(st,6)) {
-		team.death_event = script_getstr(st,6); // Die Event
+	if (script_hasdata(st,7)) {
+		team.death_event = script_getstr(st,7); // Die Event
 		check_event(st, team.death_event.c_str());
 	} else
 		team.death_event = "";
+	if (script_hasdata(st, 8))
+		team.palette = script_getnum(st, 8); // Palette
+	else
+		team.palette = 0;
 
-	if( (bg_id = bg_create(mapindex, &team)) == 0 )
+	if( (bg_id = bg_create(mapindex, &team, index)) == 0 )
 	{ // Creation failed
 		script_pushint(st,0);
 		return SCRIPT_CMD_SUCCESS;
@@ -20401,7 +20428,7 @@ BUILDIN_FUNC(waitingroom2bg_single)
 
 
 /// Creates an instance of battleground battle group.
-/// *bg_create("<map name>",<x>,<y>{,"<On Quit Event>","<On Death Event>"});
+/// *bg_create("<map name>",<x>,<y>,<index>{,"<On Quit Event>","<On Death Event>"},<palette>);
 /// @author [secretdataz]
 BUILDIN_FUNC(bg_create) {
 	const char *map_name;
@@ -20417,18 +20444,23 @@ BUILDIN_FUNC(bg_create) {
 
 	team.warp_x = script_getnum(st,3);
 	team.warp_y = script_getnum(st,4);
-	if (script_hasdata(st,5)) {
-		team.quit_event = script_getstr(st,5); // Logout Event
+	int index = script_getnum(st, 5);
+	if (script_hasdata(st,6)) {
+		team.quit_event = script_getstr(st,6); // Logout Event
 		check_event(st, team.quit_event.c_str());
 	} else
 		team.quit_event = "";
-	if (script_hasdata(st,6)) {
-		team.death_event = script_getstr(st,6); // Die Event
+	if (script_hasdata(st,7)) {
+		team.death_event = script_getstr(st,7); // Die Event
 		check_event(st, team.death_event.c_str());
 	} else
 		team.death_event = "";
+	if (script_hasdata(st, 8))
+		team.palette = script_getnum(st, 8); // Palette
+	else
+		team.palette = 0;
 
-	script_pushint(st, bg_create(mapindex, &team));
+	script_pushint(st, bg_create(mapindex, &team, index));
 	return SCRIPT_CMD_SUCCESS;
 }
 
@@ -20501,17 +20533,21 @@ BUILDIN_FUNC(bg_warp)
 
 	bg_id = script_getnum(st,2);
 	map_name = script_getstr(st,3);
-	if( (mapindex = mapindex_name2id(map_name)) == 0 )
-		return SCRIPT_CMD_SUCCESS; // Invalid Map
 	x = script_getnum(st,4);
 	y = script_getnum(st,5);
+	if(strcmp(map_name,"Respawn")==0 || strcmp(map_name,"SavePoint")==0 || strcmp(map_name,"Save")==0)
+		mapindex = 0;
+	else
+		mapindex = mapindex_name2id(map_name);
 	bg_team_warp(bg_id, mapindex, x, y);
 	return SCRIPT_CMD_SUCCESS;
 }
 
 BUILDIN_FUNC(bg_monster)
 {
-	int class_ = 0, x = 0, y = 0, bg_id = 0;
+	int class_ = 0, x = 0, y = 0, bg_id = 0, mob_id = 0, value = 0;
+	struct block_list *bl;
+	struct mob_data *md;
 	const char *str,*mapname, *evt="";
 
 	bg_id  = script_getnum(st,2);
@@ -20521,8 +20557,30 @@ BUILDIN_FUNC(bg_monster)
 	str    = script_getstr(st,6);
 	class_ = script_getnum(st,7);
 	if( script_hasdata(st,8) ) evt = script_getstr(st,8);
+	unsigned int size	= SZ_SMALL;
+	
+	if (script_hasdata(st, 9)) {
+		size = script_getnum(st, 9);
+		if (size > SZ_BIG) {
+			ShowWarning("buildin_monster: Attempted to spawn non-existing size %d for monster class %d\n", size, class_);
+			return SCRIPT_CMD_FAILURE;
+		}
+	}
+
 	check_event(st, evt);
-	script_pushint(st, mob_spawn_bg(mapname,x,y,str,class_,evt,bg_id));
+	
+	mob_id = mob_spawn_bg(mapname,x,y,str,class_,evt,bg_id,size);
+	script_pushint(st, mob_id);
+	
+	if((bl = map_id2bl(mob_id)) && (md = map_id2md(mob_id))) {
+	
+		if((md->mob_id == MOBID_EMPERIUM || md->mob_id == MOBID_GUARDIAN_STONE1 || md->mob_id == MOBID_GUARDIAN_STONE2 ) && md->status.max_hp) {
+			value = md->status.max_hp/2;
+			md->status.hp = (unsigned int)value; 
+			status_set_hp(bl, (unsigned int)value, 0); 
+			clif_name_area(&md->bl);
+		}
+	}
 	return SCRIPT_CMD_SUCCESS;
 }
 
@@ -20557,14 +20615,15 @@ BUILDIN_FUNC(bg_leave)
 	if (!strcmp(script_getfuncname(st), "bg_desert"))
 		deserter = true;
 
-	bg_team_leave(sd, false, deserter);
+	bg_team_leave(sd, false, deserter, 1);
 	return SCRIPT_CMD_SUCCESS;
 }
 
+
 BUILDIN_FUNC(bg_destroy)
 {
 	int bg_id = script_getnum(st,2);
-	bg_team_delete(bg_id);
+	bg_team_clean(bg_id, true);
 	return SCRIPT_CMD_SUCCESS;
 }
 
@@ -20586,8 +20645,11 @@ BUILDIN_FUNC(bg_getareausers)
 	y1 = script_getnum(st,7);
 
 	for (const auto &member : bg->members) {
+		if (member.sd == nullptr) continue;
 		if( member.sd->bl.m != m || member.sd->bl.x < x0 || member.sd->bl.y < y0 || member.sd->bl.x > x1 || member.sd->bl.y > y1 )
 			continue;
+		mapreg_setreg(reference_uid(add_str("$@cuserscell"), c), member.sd->status.char_id);
+		mapreg_setreg(reference_uid(add_str("$@auserscell"), c), member.sd->status.account_id);
 		c++;
 	}
 
@@ -20615,8 +20677,8 @@ BUILDIN_FUNC(bg_updatescore)
 
 BUILDIN_FUNC(bg_get_data)
 {
-	int bg_id = script_getnum(st,2), type = script_getnum(st,3), i = 0;
-	std::shared_ptr<s_battleground_data> bg = util::umap_find(bg_team_db, bg_id);
+	int team_id = script_getnum(st,2), type = script_getnum(st,3), i = 0;
+	std::shared_ptr<s_battleground_data> bg = util::umap_find(bg_team_db, team_id);
 
 	if (bg) {
 		switch (type) {
@@ -20624,11 +20686,31 @@ BUILDIN_FUNC(bg_get_data)
 			script_pushint(st, bg->members.size());
 			break;
 		case 1:
-			for (const auto &member : bg->members)
-				mapreg_setreg(reference_uid(add_str("$@arenamembers"), i++), member.sd->bl.id);
-			mapreg_setreg(add_str("$@arenamemberscount"), i);
+			for (const auto &member : bg->members) {
+				if (member.sd == nullptr) continue;
+				mapreg_setregstr(reference_uid(add_str("$@bgmembers$"),i), member.sd->status.name);
+				mapreg_setreg(reference_uid(add_str("$@arenamembers"), i), member.sd->bl.id);
+				i++;
+			}
 			script_pushint(st, i);
 			break;
+		case 2:
+			script_pushconststr(st,bg->g ? bg->g->name : "null");
+			break;
+		case 3:
+			script_pushconststr(st,bg->g ? bg->g->master : "null");
+			break;
+		case 4:
+			{
+				std::shared_ptr<s_battleground_type> bgdata = battleground_db.find(bg_get_mode());
+				for (auto& map : bgdata->maps) {
+					if (map.isReserved) {
+						script_pushconststr(st, mapindex_id2name(map.mapindex));
+						break;
+					}
+				}
+			}
+			break;
 		default:
 			ShowError("script:bg_get_data: unknown data identifier %d\n", type);
 			break;
@@ -20672,7 +20754,22 @@ BUILDIN_FUNC(bg_unbook)
  */
 BUILDIN_FUNC(bg_info)
 {
-	std::shared_ptr<s_battleground_type> bg = bg_search_name(script_getstr(st, 2));
+	std::shared_ptr<s_battleground_type> bg;
+	unsigned short bg_id;
+
+	if (script_isstring(st, 2)) {// "<map name>"
+		const char* name = script_getstr(st, 2);
+
+		bg = bg_search_name(name);
+	if (!bg) {
+			bg = bg_search_mapname(name);
+		}
+	}
+	else {// <bg id>
+		bg_id = script_getnum(st, 2);
+
+		bg = battleground_db.find(bg_id);
+	}
 
 	if (!bg) {
 		ShowError("bg_info: Invalid Battleground name %s.\n", script_getstr(st, 2));
@@ -20682,9 +20779,15 @@ BUILDIN_FUNC(bg_info)
 	int type = script_getnum(st, 3);
 
 	switch (type) {
+		case BG_TOTAL_ARENA:
+			script_pushint(st, battleground_db.size());
+			break;
 		case BG_INFO_ID:
 			script_pushint(st, bg->id);
 			break;
+		case BG_INFO_NAME:
+			script_pushconststr(st, bg->name.c_str());
+			break;
 		case BG_INFO_REQUIRED_PLAYERS:
 			script_pushint(st, bg->required_players);
 			break;
@@ -20694,6 +20797,9 @@ BUILDIN_FUNC(bg_info)
 		case BG_INFO_MIN_LEVEL:
 			script_pushint(st, bg->min_lvl);
 			break;
+		case BG_INFO_COLOR:
+			script_pushint(st, bg->color);
+			break;
 		case BG_INFO_MAX_LEVEL:
 			script_pushint(st, bg->max_lvl);
 			break;
@@ -20706,8 +20812,8 @@ BUILDIN_FUNC(bg_info)
 			script_pushint(st, i);
 			break;
 		}
-		case BG_INFO_DESERTER_TIME:
-			script_pushint(st, bg->deserter_time);
+		case BG_INFO_VARIABLE:
+			script_pushconststr(st, bg->variable.c_str());
 			break;
 		default:
 			ShowError("bg_info: Unknown battleground info type %d given.\n", type);
@@ -25820,7 +25926,7 @@ struct script_function buildin_func[] = {
 	BUILDIN_DEF(getunittitle,"i"),
 	BUILDIN_DEF(getunitdata,"i*"),
 	BUILDIN_DEF(setunitdata,"iii"),
-	BUILDIN_DEF(unitwalk,"iii?"),
+	BUILDIN_DEF(unitwalk,"iii??"),
 	BUILDIN_DEF2(unitwalk,"unitwalkto","ii?"),
 	BUILDIN_DEF(unitkill,"i"),
 	BUILDIN_DEF(unitwarp,"isii"),
@@ -25880,11 +25986,11 @@ struct script_function buildin_func[] = {
 	BUILDIN_DEF(agitend2,""),
 	BUILDIN_DEF(agitcheck2,""),
 	// BattleGround
-	BUILDIN_DEF(waitingroom2bg,"sii???"),
+	BUILDIN_DEF(waitingroom2bg,"siii????"),
 	BUILDIN_DEF(waitingroom2bg_single,"i????"),
 	BUILDIN_DEF(bg_team_setxy,"iii"),
 	BUILDIN_DEF(bg_warp,"isii"),
-	BUILDIN_DEF(bg_monster,"isiisi?"),
+	BUILDIN_DEF(bg_monster,"isiisi??"),
 	BUILDIN_DEF(bg_monster_set_team,"ii"),
 	BUILDIN_DEF(bg_leave,"?"),
 	BUILDIN_DEF2(bg_leave,"bg_desert","?"),
@@ -25894,10 +26000,10 @@ struct script_function buildin_func[] = {
 	BUILDIN_DEF(bg_getareausers,"isiiii"),
 	BUILDIN_DEF(bg_updatescore,"sii"),
 	BUILDIN_DEF(bg_join,"i????"),
-	BUILDIN_DEF(bg_create,"sii??"),
+	BUILDIN_DEF(bg_create,"siii???"),
 	BUILDIN_DEF(bg_reserve,"s?"),
 	BUILDIN_DEF(bg_unbook,"s"),
-	BUILDIN_DEF(bg_info,"si"),
+	BUILDIN_DEF(bg_info, "vi"),
 
 	// Instancing
 	BUILDIN_DEF(instance_create,"s??"),
diff --git a/src/map/script_constants.hpp b/src/map/script_constants.hpp
index b29ad8543..bc3e4058f 100644
--- a/src/map/script_constants.hpp
+++ b/src/map/script_constants.hpp
@@ -428,6 +428,9 @@
 	export_constant(MF_LEAVES);
 	// Intentionally disabled mf_rain because Ind removed it source side
 	//export_constant(MF_RAIN);
+	export_constant(MF_ALLOW_BG_ITEMS);
+	export_constant(MF_ALLOW_WOE_ITEMS);
+	export_constant(MF_NOEMERGENCYCALL);
 	export_constant(MF_NOGO);
 	export_constant(MF_CLOUDS);
 	export_constant(MF_CLOUDS2);
@@ -1533,6 +1536,7 @@
 	export_constant(SC_GEFFEN_MAGIC1);
 	export_constant(SC_GEFFEN_MAGIC2);
 	export_constant(SC_GEFFEN_MAGIC3);
+	export_constant(SC_FULLINVINCIBLE);
 	export_constant(SC_MAXPAIN);
 	export_constant(SC_ARMOR_ELEMENT_EARTH);
 	export_constant(SC_ARMOR_ELEMENT_FIRE);
@@ -8144,6 +8148,10 @@
 	export_constant(BG_INFO_MAX_LEVEL);
 	export_constant(BG_INFO_MAPS);
 	export_constant(BG_INFO_DESERTER_TIME);
+	export_constant(BG_INFO_NAME);
+	export_constant(BG_INFO_VARIABLE);
+	export_constant(BG_INFO_COLOR);
+	export_constant(BG_TOTAL_ARENA);
 
 	/* item job classes */
 	export_constant(ITEMJ_NORMAL);
diff --git a/src/map/skill.cpp b/src/map/skill.cpp
index ffb46a91c..619e61439 100755
--- a/src/map/skill.cpp
+++ b/src/map/skill.cpp
@@ -911,11 +911,16 @@ bool skill_isNotOk(uint16 skill_id, struct map_session_data *sd)
 			break;
 		case GD_EMERGENCYCALL:
 		case GD_ITEMEMERGENCYCALL:
-			if (
+			if( mapdata->flag[MF_NOEMERGENCYCALL])
+			{
+				clif_skill_fail(sd,skill_id,USESKILL_FAIL_LEVEL,0);
+				return true;
+			}
+			if ( !(mapdata->flag[MF_BATTLEGROUND]) && (
 				!(battle_config.emergency_call&((is_agit_start())?2:1)) ||
 				!(battle_config.emergency_call&(mapdata_flag_gvg2(mapdata)?8:4)) ||
 				(battle_config.emergency_call&16 && mapdata->flag[MF_NOWARPTO] && !(mapdata->flag[MF_GVG_CASTLE] || mapdata->flag[MF_GVG_TE_CASTLE]))
-			)	{
+			))	{
 				clif_skill_fail(sd,skill_id,USESKILL_FAIL_LEVEL,0);
 				return true;
 			}
@@ -6572,7 +6577,7 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
 
 	case PR_REDEMPTIO:
 		if (sd && !(flag&1)) {
-			if (sd->status.party_id == 0) {
+			if ((sd->status.party_id == 0 && !map_getmapflag(sd->bl.m, MF_BATTLEGROUND))) {
 				clif_skill_fail(sd,skill_id,USESKILL_FAIL_LEVEL,0);
 				break;
 			}
@@ -7344,7 +7349,7 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
 	case SP_SOULUNITY: {
 			int8 count = min(5 + skill_lv, MAX_UNITED_SOULS);
 
-			if (sd == nullptr || sd->status.party_id == 0 || (flag & 1)) {
+			if (sd == nullptr || (sd->status.party_id == 0 && !map_getmapflag(sd->bl.m, MF_BATTLEGROUND)) || (flag & 1)) {
 				if (!dstsd || !sd) { // Only put player's souls in unity.
 					if (sd)
 						clif_skill_fail(sd, skill_id, USESKILL_FAIL, 0);
@@ -7639,7 +7644,7 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
 #endif
 	case PR_MAGNIFICAT:
 	case PR_GLORIA:
-		if (sd == NULL || sd->status.party_id == 0 || (flag & 1)) {
+		if (sd == NULL || (sd->status.party_id == 0 && !map_getmapflag(sd->bl.m, MF_BATTLEGROUND)) || flag&1) {
 
 			// Animations don't play when outside visible range
 			if (check_distance_bl(src, bl, AREA_SIZE))
@@ -7659,7 +7664,7 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
 	case CASH_ASSUMPTIO:
 	case WM_FRIGG_SONG:
 	case NV_HELPANGEL:
-		if( sd == NULL || sd->status.party_id == 0 || (flag & 1) )
+		if( sd == NULL || (sd->status.party_id == 0 && !map_getmapflag(sd->bl.m, MF_BATTLEGROUND)) || (flag & 1) )
 			clif_skill_nodamage(bl, bl, skill_id, skill_lv, sc_start(src,bl,type,100,skill_lv,skill_get_time(skill_id,skill_lv)));
 		else if( sd )
 			party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag|BCT_PARTY|1, skill_castend_nodamage_id);
@@ -7679,7 +7684,7 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
 	case BS_ADRENALINE2:
 	case BS_WEAPONPERFECT:
 	case BS_OVERTHRUST:
-		if (sd == NULL || sd->status.party_id == 0 || (flag & 1)) {
+		if (sd == NULL || (sd->status.party_id == 0 && !map_getmapflag(sd->bl.m, MF_BATTLEGROUND)) || (flag & 1)) {
 			int weapontype = skill_get_weapontype(skill_id);
 			if (!weapontype || !dstsd || pc_check_weapontype(dstsd, weapontype)) {
 				clif_skill_nodamage(bl, bl, skill_id, skill_lv,
@@ -9370,13 +9375,17 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
 	case GD_RESTORE:
 	case GD_EMERGENCY_MOVE:
 		if(flag&1) {
-			if (status_get_guild_id(src) == status_get_guild_id(bl)) {				
-				if( skill_id == GD_RESTORE )
-					clif_skill_nodamage(src,bl,AL_HEAL,status_percent_heal(bl,90,90),1);
-				else
-					sc_start(src,bl,type,100,skill_lv,skill_get_time(skill_id, skill_lv));
+			if ( (map_getmapflag(src->m, MF_BATTLEGROUND) && bg_team_get_id(src) == bg_team_get_id(bl))
+			|| (!map_getmapflag(src->m, MF_BATTLEGROUND) && clif_visual_guild_id(src) == clif_visual_guild_id(bl))) {
+				if (clif_visual_guild_id(src) == clif_visual_guild_id(bl)) {
+					if( skill_id == GD_RESTORE )
+						clif_skill_nodamage(src,bl,AL_HEAL,status_percent_heal(bl,90,90),1);
+					else
+						sc_start(src,bl,type,100,skill_lv,skill_get_time(skill_id, skill_lv));
+				}
 			}
-		} else if (status_get_guild_id(src)) {
+		} else if ((map_getmapflag(src->m, MF_BATTLEGROUND) && bg_team_get_id(src)) 
+			|| (!map_getmapflag(src->m, MF_BATTLEGROUND) && clif_visual_guild_id(src))) {
 			clif_skill_nodamage(src,bl,skill_id,skill_lv,1);
 			map_foreachinallrange(skill_area_sub, src,
 				skill_get_splash(skill_id, skill_lv), BL_PC,
@@ -9397,32 +9406,62 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
 			int8 dy[9] = { 0, 0, 1,-1, 1,-1,-1, 1, 0};
 			uint8 j = 0, calls = 0, called = 0;
 			struct guild *g;
+			std::shared_ptr<s_battleground_data> bg;
+			
+			if( map_getmapflag(src->m, MF_BATTLEGROUND) )
+			{
+				if(sd && (bg = sd->bmaster_flag) != NULL ) {
+					
+					clif_skill_nodamage(src,bl,skill_id,skill_lv,1);
+					for (const auto& member : bg->members) {
+						if (j > 8)
+							j = 0;
+
+						if ((dstsd = member.sd) != nullptr && sd != dstsd && !dstsd->state.autotrade && !pc_isdead(dstsd)) {
+							
+							if (!map_getmapflag(dstsd->bl.m, MF_BATTLEGROUND))
+								continue;
+							
+							if (!pc_job_can_entermap((enum e_job)dstsd->status.class_, src->m, dstsd->group_level))
+								continue;
+							
+							if(map_getcell(src->m,src->x+dx[j],src->y+dy[j],CELL_CHKNOREACH))
+								dx[j] = dy[j] = 0;
+							
+							if (!pc_setpos(dstsd, map_id2index(src->m), src->x+dx[j], src->y+dy[j], CLR_RESPAWN))
+								called++;
+						}
+					}
+				} else break;
+
+			} else {
 			// i don't know if it actually summons in a circle, but oh well. ;P
-			g = sd?sd->guild:guild_search(status_get_guild_id(src));
-			if (!g)
-				break;
+				g = sd?sd->guild:guild_search(clif_visual_guild_id(src));
+				if (!g)
+					break;
 
-			if (skill_id == GD_ITEMEMERGENCYCALL)
-				switch (skill_lv) {
-					case 1:	calls = 7; break;
-					case 2:	calls = 12; break;
-					case 3:	calls = 20; break;
-					default: calls = 0;	break;
-				}
+				if (skill_id == GD_ITEMEMERGENCYCALL)
+					switch (skill_lv) {
+						case 1:	calls = 7; break;
+						case 2:	calls = 12; break;
+						case 3:	calls = 20; break;
+						default: calls = 0;	break;
+					}
 
-			clif_skill_nodamage(src,bl,skill_id,skill_lv,1);
-			for (i = 0; i < g->max_member && (!calls || (calls && called < calls)); i++, j++) {
-				if (j > 8)
-					j = 0;
-				if ((dstsd = g->member[i].sd) != NULL && sd != dstsd && !dstsd->state.autotrade && !pc_isdead(dstsd)) {
-					if (map_getmapflag(dstsd->bl.m, MF_NOWARP) && !map_flag_gvg2(dstsd->bl.m))
-						continue;
-					if (!pc_job_can_entermap((enum e_job)dstsd->status.class_, src->m, dstsd->group_level))
-						continue;
-					if(map_getcell(src->m,src->x+dx[j],src->y+dy[j],CELL_CHKNOREACH))
-						dx[j] = dy[j] = 0;
-					if (!pc_setpos(dstsd, map_id2index(src->m), src->x+dx[j], src->y+dy[j], CLR_RESPAWN))
-						called++;
+				clif_skill_nodamage(src,bl,skill_id,skill_lv,1);
+				for (i = 0; i < g->max_member && (!calls || (calls && called < calls)); i++, j++) {
+					if (j > 8)
+						j = 0;
+					if ((dstsd = g->member[i].sd) != NULL && sd != dstsd && !dstsd->state.autotrade && !pc_isdead(dstsd)) {
+						if (map_getmapflag(dstsd->bl.m, MF_NOWARP) && !map_flag_gvg2(dstsd->bl.m))
+							continue;
+						if (!pc_job_can_entermap((enum e_job)dstsd->status.class_, src->m, dstsd->group_level))
+							continue;
+						if(map_getcell(src->m,src->x+dx[j],src->y+dy[j],CELL_CHKNOREACH))
+							dx[j] = dy[j] = 0;
+						if (!pc_setpos(dstsd, map_id2index(src->m), src->x+dx[j], src->y+dy[j], CLR_RESPAWN))
+							called++;
+					}
 				}
 			}
 			if (sd)
@@ -9667,7 +9706,7 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
 		break;
 	case ALL_PARTYFLEE:
 		if( sd  && !(flag&1) ) {
-			if( !sd->status.party_id ) {
+			if( !sd->status.party_id && !map_getmapflag(sd->bl.m, MF_BATTLEGROUND) ) {
 				clif_skill_fail(sd,skill_id,USESKILL_FAIL_LEVEL,0);
 				break;
 			}
@@ -9857,20 +9896,32 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
 		break;
 
 	case AB_PRAEFATIO:
+	{
+		struct map_data *mapdata = map_getmapdata(sd->bl.m);
+		if (!sd || (sd->status.party_id == 0 && !mapdata->flag[MF_BATTLEGROUND]) || flag & 1)
+			clif_skill_nodamage(bl, bl, skill_id, skill_lv, sc_start4(src, bl, type, 100, skill_lv, 0, 0, (sd && (sd->status.party_id || mapdata->flag[MF_BATTLEGROUND]) ? party_foreachsamemap(party_sub_count, sd, 0) : 1), skill_get_time(skill_id, skill_lv)));
+
+		break;
+	}
 	case AB_RENOVATIO:
-		if( !sd || sd->status.party_id == 0 || flag&1 ) {
+	{
+		struct map_data* mapdata = map_getmapdata(sd->bl.m);
+		if (!sd || (sd->status.party_id == 0 && !mapdata->flag[MF_BATTLEGROUND]) || flag & 1) {
 			if (skill_id == AB_PRAEFATIO)
-				clif_skill_nodamage(bl, bl, skill_id, skill_lv, sc_start4(src, bl, type, 100, skill_lv, 0, 0, (sd && sd->status.party_id ? party_foreachsamemap(party_sub_count, sd, 0) : 1 ), skill_get_time(skill_id, skill_lv)));
+				clif_skill_nodamage(bl, bl, skill_id, skill_lv, sc_start4(src, bl, type, 100, skill_lv, 0, 0, (sd && sd->status.party_id ? party_foreachsamemap(party_sub_count, sd, 0) : 1), skill_get_time(skill_id, skill_lv)));
 			else
 				clif_skill_nodamage(bl, bl, skill_id, skill_lv, sc_start(src, bl, type, 100, skill_lv, skill_get_time(skill_id, skill_lv)));
-		} else if( sd )
-			party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag|BCT_PARTY|1, skill_castend_nodamage_id);
+		}
+		else if (sd)
+			party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag | BCT_PARTY | 1, skill_castend_nodamage_id);
+
 		break;
+	}
 
 	case AB_CHEAL:
-		if( !sd || sd->status.party_id == 0 || flag&1 ) {
+		if( !sd || (sd->status.party_id == 0 && !map_getmapflag(sd->bl.m, MF_BATTLEGROUND)) || flag&1 ) {
 			if( sd && tstatus && !battle_check_undead(tstatus->race, tstatus->def_ele) && !tsc->data[SC_BERSERK] ) {
-				int partycount = (sd->status.party_id ? party_foreachsamemap(party_sub_count, sd, 0) : 0);
+				int partycount = (sd->status.party_id || map_getmapflag(sd->bl.m, MF_BATTLEGROUND) ? party_foreachsamemap(party_sub_count, sd, 0) : 0);
 
 				i = skill_calc_heal(src, bl, AL_HEAL, pc_checkskill(sd, AL_HEAL), true);
 
@@ -9899,7 +9950,7 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
 		break;
 
 	case AB_LAUDAAGNUS:
-		if( flag&1 || !sd || !sd->status.party_id ) {
+		if( flag&1 || !sd || (!sd->status.party_id && !map_getmapflag(sd->bl.m, MF_BATTLEGROUND))) {
 			if( tsc && (tsc->data[SC_FREEZE] || tsc->data[SC_STONE] || tsc->data[SC_BLIND] ||
 				tsc->data[SC_BURNING] || tsc->data[SC_FREEZING] || tsc->data[SC_CRYSTALIZE])) {
 				// Success Chance: (60 + 10 * Skill Level) %
@@ -9919,7 +9970,7 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
 		break;
 
 	case AB_LAUDARAMUS:
-		if( flag&1 || !sd || !sd->status.party_id ) {
+		if( flag&1 || !sd || (!sd->status.party_id && !map_getmapflag(sd->bl.m, MF_BATTLEGROUND))) {
 			if( tsc && (tsc->data[SC_SLEEP] || tsc->data[SC_STUN] || tsc->data[SC_MANDRAGORA] || tsc->data[SC_SILENCE] || tsc->data[SC_DEEPSLEEP]) ){
 				// Success Chance: (60 + 10 * Skill Level) %
 				if( rnd()%100 > 60+10*skill_lv )  break;
@@ -10567,7 +10618,7 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
 	case WA_SYMPHONY_OF_LOVER:
 	case MI_RUSH_WINDMILL:
 	case MI_ECHOSONG:
-		if( !sd || !sd->status.party_id || (flag & 1) ) {
+		if( !sd || (!sd->status.party_id && !map_getmapflag(sd->bl.m, MF_BATTLEGROUND)) || (flag & 1) ) {
 			clif_skill_nodamage(src,bl,skill_id,skill_lv,1);
 			sc_start2(src,bl,type,100,skill_lv,((sd) ? pc_checkskill(sd,WM_LESSON) : skill_get_max(WM_LESSON)),skill_get_time(skill_id,skill_lv));
 		} else if( sd ) {
@@ -11350,7 +11401,7 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
 		break;
 
 	case SO_ELEMENTAL_SHIELD:
-		if (!sd || sd->status.party_id == 0 || flag&1) {
+		if (!sd || (sd->status.party_id == 0 && !map_getmapflag(sd->bl.m, MF_BATTLEGROUND)) || flag&1) {
 			if (sd && sd->status.party_id == 0) {
 				clif_skill_nodamage(src,bl,skill_id,skill_lv,1);
 				if (sd->ed && skill_get_state(skill_id) == ST_ELEMENTALSPIRIT2)
@@ -11417,7 +11468,7 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
 	case SU_HISS:
 	case SU_PURRING:
 	case SU_MEOWMEOW:
-		if (sd == NULL || sd->status.party_id == 0 || flag&1) {
+		if (sd == NULL || (sd->status.party_id == 0 && !map_getmapflag(sd->bl.m, MF_BATTLEGROUND)) || flag&1) {
 			int duration = skill_get_time(skill_id, skill_lv);
 
 			if (skill_id == SU_BUNCHOFSHRIMP && pc_checkskill(sd, SU_SPIRITOFSEA))
@@ -11429,7 +11480,7 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
 		break;
 
 	case SU_SHRIMPARTY:
-		if (sd == NULL || sd->status.party_id == 0 || flag&1) {
+		if (sd == NULL || (sd->status.party_id == 0 && !map_getmapflag(sd->bl.m, MF_BATTLEGROUND)) || flag&1) {
 			sc_start(src, bl, type, 100, skill_lv, skill_get_time(skill_id, skill_lv));
 			if (sd && (i = pc_checkskill(sd, SU_FRESHSHRIMP)) > 0) {
 				clif_skill_nodamage(bl, bl, SU_FRESHSHRIMP, i, 1);
@@ -11494,7 +11545,7 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
 			// Do the teleport part
 			for (i = 0; i < MAX_PARTY; ++i) {
 				map_session_data *pl_sd = p->data[i].sd;
-
+				
 				if (pl_sd == nullptr || pl_sd == sd || pl_sd->status.party_id != p->party.party_id || pc_isdead(pl_sd) ||
 					sd->bl.m != pl_sd->bl.m)
 					continue;
@@ -15839,15 +15890,23 @@ bool skill_check_condition_castbegin(struct map_session_data* sd, uint16 skill_i
 		case GD_CHARGESHOUT_FLAG:
 		case GD_CHARGESHOUT_BEATING:
 		case GD_EMERGENCY_MOVE:
-			if (!map_flag_gvg2(sd->bl.m)) {
+			if( !map_flag_gvg2(sd->bl.m) && !map_getmapflag(sd->bl.m, MF_BATTLEGROUND) ) {
 				clif_skill_fail(sd,skill_id,USESKILL_FAIL_LEVEL,0);
 				return false;
 			}
 		case GD_EMERGENCYCALL:
 		case GD_ITEMEMERGENCYCALL:
 			// other checks were already done in skill_isNotOk()
-			if (!sd->status.guild_id || (sd->state.gmaster_flag == 0 && skill_id != GD_CHARGESHOUT_BEATING))
-				return false;
+			if( map_getmapflag(sd->bl.m, MF_BATTLEGROUND) )
+			{
+				if( !(sd->bg_id && sd->bmaster_flag) )
+					return false; // Not Team Leader on Battleground
+			}
+			else
+			{
+				if (!sd->status.guild_id || (sd->state.gmaster_flag == 0 && skill_id != GD_CHARGESHOUT_BEATING))
+					return false; // Not Guild Leader
+			}
 			break;
 
 		case GS_GLITTERING:
@@ -16574,6 +16633,18 @@ bool skill_check_condition_castend(struct map_session_data* sd, uint16 skill_id,
 			clif_messagecolor(&sd->bl,color_table[COLOR_RED],e_msg,false,SELF);
 			return false;
 		}
+		else if (sd->inventory.u.items_inventory[i].card[0] == CARD0_CREATE) {
+			int char_id = MakeDWord(sd->inventory.u.items_inventory[i].card[2], sd->inventory.u.items_inventory[i].card[3]);
+			if (!map_bg_items(sd->bl.m) && battle_config.bg_reserved_char_id && char_id == battle_config.bg_reserved_char_id) {
+				clif_arrow_fail(sd, 0);
+				return false;
+			}
+			if (!map_gvg_items(sd->bl.m) && battle_config.woe_reserved_char_id && char_id == battle_config.woe_reserved_char_id) {
+				clif_arrow_fail(sd, 0);
+				return false;
+			}
+		}
+
 		if (!(require.ammo&1<<sd->inventory_data[i]->subtype)) { //Ammo type check. Send the "wrong weapon type" message
 			//which is the closest we have to wrong ammo type. [Skotlex]
 			clif_arrow_fail(sd,0); //Haplo suggested we just send the equip-arrows message instead. [Skotlex]
@@ -18876,7 +18947,7 @@ std::shared_ptr<s_skill_unit_group> skill_initunitgroup(struct block_list* src,
 
 	group->src_id     = src->id;
 	group->party_id   = status_get_party_id(src);
-	group->guild_id   = status_get_guild_id(src);
+	group->guild_id   = clif_visual_guild_id(src);
 	group->bg_id      = bg_team_get_id(src);
 	group->group_id   = skill_get_new_group_id();
 	group->link_group_id = 0;
diff --git a/src/map/status.cpp b/src/map/status.cpp
index 85c600086..e3b61e49a 100644
--- a/src/map/status.cpp
+++ b/src/map/status.cpp
@@ -1468,6 +1468,7 @@ void initChangeTables(void)
 	StatusIconChangeTable[SC_CHASEWALK2] = EFST_CHASEWALK2;
 	StatusIconChangeTable[SC_MIRACLE] = EFST_SOULLINK;
 	StatusIconChangeTable[SC_INTRAVISION] = EFST_CLAIRVOYANCE;
+	StatusIconChangeTable[SC_FULLINVINCIBLE] = EFST_FULLINVINCIBLE;
 	StatusIconChangeTable[SC_STRFOOD] = EFST_FOOD_STR;
 	StatusIconChangeTable[SC_AGIFOOD] = EFST_FOOD_AGI;
 	StatusIconChangeTable[SC_VITFOOD] = EFST_FOOD_VIT;
@@ -2896,6 +2897,8 @@ bool status_check_skilluse(struct block_list *src, struct block_list *target, ui
 		* Attacks in invincible are capped to 1 damage and handled in battle.cpp.
 		* Allow spell break and eske for sealed shrine GDB when in INVINCIBLE state.
 		**/
+		if (tsc->data[SC_FULLINVINCIBLE])
+			return false;
 		if( tsc->data[SC_INVINCIBLE] && !tsc->data[SC_INVINCIBLEOFF] && skill_id && !(skill_id&(SA_SPELLBREAKER|SL_SKE)) )
 			return false;
 		if(!skill_id && tsc->data[SC_TRICKDEAD])
@@ -3526,9 +3529,7 @@ int status_calc_mob_(struct mob_data* md, enum e_status_calc_opt opt)
 		struct map_data *mapdata = map_getmapdata(md->bl.m);
 		std::shared_ptr<guild_castle> gc = castle_db.mapname2gc(mapdata->name);
 
-		if (gc == nullptr)
-			ShowError("status_calc_mob: No castle set at map %s\n", mapdata->name);
-		else if(gc->castle_id < 24 || md->mob_id == MOBID_EMPERIUM) {
+		if(gc && (gc->castle_id < 24 || md->mob_id == MOBID_EMPERIUM)) {
 #ifdef RENEWAL
 			status->max_hp += 50 * (gc->defense / 5);
 #else
@@ -14215,6 +14216,12 @@ int status_change_end_(struct block_list* bl, enum sc_type type, int tid, const
 		if (vd && !vd->cloth_color && sce->val4)
 			clif_changelook(bl,LOOK_CLOTHES_COLOR,sce->val4);
 		calc_flag = static_cast<scb_flag>(calc_flag&~SCB_DYE);
+
+		// [Vykimo] Put palette to players if any
+		std::shared_ptr<s_battleground_data> bg;
+		if (sd && sd->bg_id && (bg = util::umap_find(bg_team_db, sd->bg_id)) && bg->palette) {
+			clif_changelook(&sd->bl, LOOK_CLOTHES_COLOR, bg->palette);
+		}
 	}
 
 	/*if (calc_flag&SCB_BODY)// Might be needed in the future. [Rytech]
@@ -14245,6 +14252,19 @@ int status_change_end_(struct block_list* bl, enum sc_type type, int tid, const
 			clif_changelook(bl,LOOK_SHIELD,sd->vd.shield);
 			clif_changelook(bl,LOOK_CLOTHES_COLOR,cap_value(sd->status.clothes_color,0,battle_config.max_cloth_color));
 			clif_changelook(bl,LOOK_BODY2,cap_value(sd->status.body,0,battle_config.max_body_style));
+
+			// [Vykimo] Put palette to players if any
+			std::shared_ptr<s_battleground_data> bg;
+			if (sd && sd->bg_id && (bg = util::umap_find(bg_team_db, sd->bg_id)) && bg->palette) {
+				clif_changelook(&sd->bl, LOOK_CLOTHES_COLOR, bg->palette);
+			}
+		}
+		else if (opt_flag & 2) {
+			// [Vykimo] Put palette to players if any
+			std::shared_ptr<s_battleground_data> bg;
+			if (sd && sd->bg_id && (bg = util::umap_find(bg_team_db, sd->bg_id)) && bg->palette) {
+				clif_changelook(&sd->bl, LOOK_CLOTHES_COLOR, bg->palette);
+			}
 		}
 	}
 	if (calc_flag) {
diff --git a/src/map/status.hpp b/src/map/status.hpp
index 2319bf75d..35c14677a 100644
--- a/src/map/status.hpp
+++ b/src/map/status.hpp
@@ -1027,6 +1027,8 @@ enum sc_type : int16 {
 	SC_BURNT,
 	SC_CHILL,
 
+	SC_FULLINVINCIBLE,
+
 #ifdef RENEWAL
 	SC_EXTREMITYFIST2, //! NOTE: This SC should be right before SC_MAX, so it doesn't disturb if RENEWAL is disabled
 #endif
@@ -2167,6 +2169,8 @@ enum efst_types : short{
 
 	EFST_PRESSURE = 1180,
 
+
+	EFST_FULLINVINCIBLE = 1181,
 	EFST_CLIMAX_EARTH = 1182,
 	EFST_CLIMAX_BLOOM,
 	EFST_CLIMAX_CRYIMP,
diff --git a/src/map/storage.cpp b/src/map/storage.cpp
index 7ad997efe..a528c13e1 100644
--- a/src/map/storage.cpp
+++ b/src/map/storage.cpp
@@ -157,15 +157,14 @@ int storage_storageopen(struct map_session_data *sd)
  * @param b : item 2
  * @return 1:same, 0:are different
  */
-int compare_item(struct item *a, struct item *b)
+int compare_item(struct item *a, struct item *b, short flag)
 {
 	if( a->nameid == b->nameid &&
 		a->identify == b->identify &&
 		a->refine == b->refine &&
 		a->attribute == b->attribute &&
-		a->expire_time == b->expire_time &&
-		a->bound == b->bound &&
-		a->unique_id == b->unique_id
+		(flag&1 || (a->expire_time == b->expire_time && a->bound == b->bound 
+					&& a->unique_id == b->unique_id))
 		)
 	{
 		int i;
@@ -264,7 +263,7 @@ static int storage_additem(struct map_session_data* sd, struct s_storage *stor,
 
 	if( itemdb_isstackable2(data) ) { // Stackable
 		for( i = 0; i < stor->max_amount; i++ ) {
-			if( compare_item(&stor->u.items_storage[i], it) ) { // existing items found, stack them
+			if( compare_item(&stor->u.items_storage[i], it, 0) ) { // existing items found, stack them
 				if( amount > MAX_AMOUNT - stor->u.items_storage[i].amount || ( data->stack.storage && amount > data->stack.amount - stor->u.items_storage[i].amount ) )
 					return 2;
 
@@ -295,6 +294,25 @@ static int storage_additem(struct map_session_data* sd, struct s_storage *stor,
 
 	return 0;
 }
+/*==========================================
+ * Add an item to the storage
+ *------------------------------------------*/
+int storage_additem2(struct map_session_data *sd, struct item* item_data, int amount)
+{
+	nullpo_ret(sd);
+	nullpo_ret(item_data);
+
+	if( sd->storage.amount > sd->storage.max_amount )
+		return 0;
+	if( item_data->nameid <= 0 || amount <= 0 )
+		return 0;
+	if( amount > MAX_AMOUNT )
+		return 0;
+	if( storage_additem(sd,&sd->storage,item_data,amount) == 0 )
+		return 1;
+
+	return 0;
+}
 
 /**
  * Make a player delete an item from his storage
@@ -572,8 +590,11 @@ char storage_guild_storageopen(struct map_session_data* sd)
 
 #if PACKETVER >= 20140205
 	int pos;
+	struct guild *g;
+
+	nullpo_retr(-1, g = sd->guild);
 
-	if ((pos = guild_getposition(sd)) < 0 || !(sd->guild->position[pos].mode&GUILD_PERM_STORAGE))
+	if ((pos = guild_getposition(g,sd)) < 0 || !(sd->guild->position[pos].mode&GUILD_PERM_STORAGE))
 		return GSTORAGE_NO_PERMISSION; // Guild member doesn't have permission
 #endif
 
@@ -754,7 +775,7 @@ bool storage_guild_additem(struct map_session_data* sd, struct s_storage* stor,
 
 	if(itemdb_isstackable2(id)) { //Stackable
 		for(i = 0; i < stor->max_amount; i++) {
-			if(compare_item(&stor->u.items_guild[i], item_data)) {
+			if(compare_item(&stor->u.items_guild[i], item_data, 0)) {
 				if( amount > MAX_AMOUNT - stor->u.items_guild[i].amount || ( id->stack.guild_storage && amount > id->stack.amount - stor->u.items_guild[i].amount ) )
 					return false;
 
@@ -808,7 +829,7 @@ bool storage_guild_additem2(struct s_storage* stor, struct item* item, int amoun
 
 	if (itemdb_isstackable2(id)) { // Stackable
 		for (i = 0; i < stor->max_amount; i++) {
-			if (compare_item(&stor->u.items_guild[i], item)) {
+			if (compare_item(&stor->u.items_guild[i], item, 0)) {
 				// Set the amount, make it fit with max amount
 				amount = min(amount, ((id->stack.guild_storage) ? id->stack.amount : MAX_AMOUNT) - stor->u.items_guild[i].amount);
 				if (amount != item->amount)
diff --git a/src/map/storage.hpp b/src/map/storage.hpp
index a24ec8b7b..b1f2efe99 100644
--- a/src/map/storage.hpp
+++ b/src/map/storage.hpp
@@ -57,6 +57,7 @@ int storage_storageopen(struct map_session_data *sd);
 void storage_storageadd(struct map_session_data *sd, struct s_storage *stor, int index, int amount);
 void storage_storageget(struct map_session_data *sd, struct s_storage *stor, int index, int amount);
 void storage_storageaddfromcart(struct map_session_data *sd, struct s_storage *stor, int index, int amount);
+int storage_additem2(struct map_session_data *sd, struct item* item_data, int amount);
 void storage_storagegettocart(struct map_session_data *sd, struct s_storage *stor, int index, int amount);
 void storage_storagesave(struct map_session_data *sd);
 void storage_storageclose(struct map_session_data *sd);
@@ -90,6 +91,6 @@ void storage_premiumStorage_save(struct map_session_data *sd);
 void storage_premiumStorage_close(struct map_session_data *sd);
 void storage_premiumStorage_quit(struct map_session_data *sd);
 
-int compare_item(struct item *a, struct item *b);
+int compare_item(struct item *a, struct item *b, short flag);
 
 #endif /* STORAGE_HPP */
diff --git a/src/map/unit.cpp b/src/map/unit.cpp
index 6ad4e9a53..caa0408ae 100644
--- a/src/map/unit.cpp
+++ b/src/map/unit.cpp
@@ -2689,6 +2689,10 @@ static int unit_attack_timer_sub(struct block_list* src, int tid, t_tick tick)
 	if( ud->skilltimer != INVALID_TIMER && !(sd && pc_checkskill(sd,SA_FREECAST) > 0) )
 		return 0; // Can't attack while casting
 
+	if( sd && map_getmapflag(src->m, MF_BATTLEGROUND) )
+		pc_update_last_action(sd,0,IDLE_ATTACK);
+
+
 	if( !battle_config.sdelay_attack_enable && DIFF_TICK(ud->canact_tick,tick) > 0 && !(sd && pc_checkskill(sd,SA_FREECAST) > 0) ) {
 		// Attacking when under cast delay has restrictions:
 		if( tid == INVALID_TIMER ) { // Requested attack.
diff --git a/src/map/vending.cpp b/src/map/vending.cpp
index 82ebf24de..cdb677305 100755
--- a/src/map/vending.cpp
+++ b/src/map/vending.cpp
@@ -9,6 +9,7 @@
 #include "../common/nullpo.hpp"
 #include "../common/showmsg.hpp" // ShowInfo
 #include "../common/strlib.hpp"
+#include "../common/utils.hpp"
 #include "../common/timer.hpp"  // DIFF_TICK
 
 #include "achievement.hpp"
@@ -331,6 +332,7 @@ int8 vending_openvending(struct map_session_data* sd, const char* message, const
 		short index        = *(uint16*)(data + 8*j + 0);
 		short amount       = *(uint16*)(data + 8*j + 2);
 		unsigned int value = *(uint32*)(data + 8*j + 4);
+		int char_id = 0;
 
 		index -= 2; // offset adjustment (client says that the first cart position is 2)
 
@@ -341,6 +343,7 @@ int8 vending_openvending(struct map_session_data* sd, const char* message, const
 		||  sd->cart.u.items_cart[index].attribute == 1 // broken item
 		||  sd->cart.u.items_cart[index].expire_time // It should not be in the cart but just in case
 		||  (sd->cart.u.items_cart[index].bound && !pc_can_give_bounded_items(sd)) // can't trade account bound items and has no permission
+		||  ( sd->cart.u.items_cart[index].card[0] == CARD0_CREATE && (char_id = MakeDWord(sd->cart.u.items_cart[index].card[2], sd->cart.u.items_cart[index].card[3])) > 0 && (battle_config.bg_reserved_char_id && char_id == battle_config.bg_reserved_char_id))
 		||  !itemdb_cantrade(&sd->cart.u.items_cart[index], pc_get_group_level(sd), pc_get_group_level(sd)) ) // untradeable item
 			continue;
 
