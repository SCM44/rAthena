 npc/battleground-extended/1-bg_ctf.txt |  20 +-
 npc/battleground-extended/3-bg_eoe.txt |  18 +-
 npc/battleground-extended/6-bg_sc.txt  |  52 ++---
 npc/battleground-extended/7-bg_dom.txt |  23 ++-
 sql-files/battleground_ranking.sql     | 227 +++++++++++++++++++++
 src/char/char.cpp                      | 349 +++++++++++++++++++++++++++++++++
 src/char/char.hpp                      |   9 +-
 src/char/char_mapif.cpp                | 104 +++++-----
 src/char/char_mapif.hpp                |   1 +
 src/char/int_guild.cpp                 | 115 +++++++++++
 src/char/int_guild.hpp                 |   1 +
 src/char/inter.cpp                     |   2 +-
 src/common/mmo.hpp                     | 165 +++++++++++++++-
 src/common/utils.hpp                   |  18 ++
 src/custom/script.inc                  | 215 +++++++++++++++++++-
 src/custom/script_def.inc              |   3 +
 src/map/battle.cpp                     |   7 +-
 src/map/battleground.cpp               |  89 ++++++++-
 src/map/battleground.hpp               |   2 +-
 src/map/chrif.cpp                      |  37 ++--
 src/map/chrif.hpp                      |   4 +-
 src/map/clif.cpp                       |  35 ++++
 src/map/clif.hpp                       |   2 +
 src/map/guild.cpp                      | 136 ++++++++++++-
 src/map/guild.hpp                      |   1 +
 src/map/intif.cpp                      |  24 ++-
 src/map/intif.hpp                      |   2 +
 src/map/itemdb.hpp                     |   1 +
 src/map/log.cpp                        |  26 +++
 src/map/log.hpp                        |   3 +
 src/map/map.hpp                        |  19 ++
 src/map/mob.cpp                        |   4 +-
 src/map/pc.cpp                         | 312 ++++++++++++++++++++++++++++-
 src/map/pc.hpp                         |  14 +-
 src/map/script.cpp                     |   6 +-
 src/map/skill.cpp                      | 187 ++++++++++++++++--
 src/map/status.cpp                     |  39 +++-
 37 files changed, 2096 insertions(+), 176 deletions(-)

diff --git a/npc/battleground-extended/1-bg_ctf.txt b/npc/battleground-extended/1-bg_ctf.txt
index d990de79f..fb94bf781 100644
--- a/npc/battleground-extended/1-bg_ctf.txt
+++ b/npc/battleground-extended/1-bg_ctf.txt
@@ -39,7 +39,7 @@ OnTouch:
 		pcblock 1,1; // Block Skills/Items
 
 		mapannounce "bg_ctf","Alpha Crystal Taken by [ " + strcharinfo(0) + " ]",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
-		//bg_rankpoints "ctf_taken",1;
+		bg_rankpoints "ctf_taken",1;
 		disablenpc "Team1_Flag";
 		addtimer 2000, "Flavius_CTF::OnAlphaFlash";
 		stopnpctimer;
@@ -51,7 +51,7 @@ OnTouch:
 			set getvariableofnpc(.Flag_Carrier,"Team2_Flag"),0;
 			set .Flag_Carrier, 0;
 			mapannounce "bg_ctf","Omega Crystal Captured by [ " + strcharinfo(0) + " ]!!",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
-			//bg_rankpoints "ctf_captured",1;
+			bg_rankpoints "ctf_captured",1;
 			pcblock 1,0; // UnBlock Skills/Items
 			stopnpctimer;
 			donpcevent "Flavius_CTF::OnTeam1Score";
@@ -59,7 +59,7 @@ OnTouch:
 		else if( .Flag_Status == 1 )
 		{
 			mapannounce "bg_ctf","Alpha Crystal Returned by [ " + strcharinfo(0) + " ]!!",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
-			//bg_rankpoints "fame",1;
+			bg_rankpoints "fame",1;
 			disablenpc "Team1_Flag";
 			sleep 2000;
 			movenpc "Team1_Flag",196,91; // Back to Base
@@ -113,7 +113,7 @@ OnTouch:
 		pcblock 1,1; // Block Skills/Items
 
 		mapannounce "bg_ctf","Omega Crystal Taken by [ " + strcharinfo(0) + " ]",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
-		//bg_rankpoints "ctf_taken",1;
+		bg_rankpoints "ctf_taken",1;
 		disablenpc "Team2_Flag";
 		addtimer 2000, "Flavius_CTF::OnOmegaFlash";
 		stopnpctimer;
@@ -125,7 +125,7 @@ OnTouch:
 			set getvariableofnpc(.Flag_Carrier,"Team1_Flag"),0;
 			set .Flag_Carrier, 0;
 			mapannounce "bg_ctf","Alpha Crystal Captured by [ " + strcharinfo(0) + " ]!!",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
-			//bg_rankpoints "ctf_captured",1;
+			bg_rankpoints "ctf_captured",1;
 			pcblock 1,0; // UnBlock Skills/Items
 			stopnpctimer;
 			donpcevent "Flavius_CTF::OnTeam2Score";
@@ -133,7 +133,7 @@ OnTouch:
 		else if( .Flag_Status == 1 )
 		{
 			mapannounce "bg_ctf","Omega Crystal Returned by [ " + strcharinfo(0) + " ]!!",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
-			//bg_rankpoints "fame",1;
+			bg_rankpoints "fame",1;
 			disablenpc "Team2_Flag";
 			sleep 2000;
 			movenpc "Team2_Flag",63,91; // Back to Base
@@ -212,8 +212,8 @@ OnTeam1Die:
 		getmapxy .@m$, .@x, .@y, BL_PC;
 		movenpc "Team2_Flag", .@x, .@y;
 		mapannounce "bg_ctf","Omega Flag Droped by [ " + strcharinfo(0) + " ]",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
-		//bg_rankpoints "ctf_droped",1;
-		//bg_rankpoints "fame",1,@killer_bg_src;
+		bg_rankpoints "ctf_droped",1;
+		bg_rankpoints "fame",1,@killer_bg_src;
 		set getvariableofnpc(.Flag_Status,"Team2_Flag"), 1; // OnFloor
 		initnpctimer "Team2_Flag";
 		enablenpc "Team2_Flag";
@@ -233,8 +233,8 @@ OnTeam2Die:
 		getmapxy .@m$, .@x, .@y, BL_PC;
 		movenpc "Team1_Flag", .@x, .@y;
 		mapannounce "bg_ctf","Alpha Flag Droped by [ " + strcharinfo(0) + " ]",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
-		//bg_rankpoints "ctf_droped",1;
-		//bg_rankpoints "fame",1,@killer_bg_src;
+		bg_rankpoints "ctf_droped",1;
+		bg_rankpoints "fame",1,@killer_bg_src;
 		set getvariableofnpc(.Flag_Status,"Team1_Flag"), 1; // OnFloor
 		initnpctimer "Team1_Flag";
 		enablenpc "Team1_Flag";
diff --git a/npc/battleground-extended/3-bg_eoe.txt b/npc/battleground-extended/3-bg_eoe.txt
index c268cd0ea..7f2664525 100644
--- a/npc/battleground-extended/3-bg_eoe.txt
+++ b/npc/battleground-extended/3-bg_eoe.txt
@@ -31,7 +31,7 @@ OnTeam1Die:
 		getmapxy .@m$, .@x, .@y, BL_PC;
 		movenpc "Neutral_Flag", .@x, .@y;
 		mapannounce "bg_eoe",bg_get_data($@BG_Team1,2) + " have droped the Flag",1,0xFFFFFF;
-		//bg_rankpoints "fame",1,@killer_bg_src;
+		bg_rankpoints "fame",1,@killer_bg_src;
 		set getvariableofnpc(.Flag_Status,"Neutral_Flag"), 0; // OnFloor
 		set getvariableofnpc(.Flag_Carrier,"Neutral_Flag"), 0;
 		initnpctimer "Neutral_Flag";
@@ -51,7 +51,7 @@ OnTeam2Die:
 		getmapxy .@m$, .@x, .@y, BL_PC;
 		movenpc "Neutral_Flag", .@x, .@y;
 		mapannounce "bg_eoe",bg_get_data($@BG_Team2,2) + " have droped the Flag",1,0xFFFFFF;
-		//bg_rankpoints "fame",1,@killer_bg_src;
+		bg_rankpoints "fame",1,@killer_bg_src;
 		set getvariableofnpc(.Flag_Status,"Neutral_Flag"), 0; // OnFloor
 		set getvariableofnpc(.Flag_Carrier,"Neutral_Flag"), 0;
 		initnpctimer "Neutral_Flag";
@@ -283,7 +283,7 @@ OnTouch:
 
 	set .Flag_Status, 1;
 	set .Flag_Carrier, getcharid(0);
-	//bg_rankpoints "fame",1;
+	bg_rankpoints "fame",1;
 
 	sc_end SC_HIDING;
 	sc_end SC_CLOAKING;
@@ -344,7 +344,7 @@ OnTouch:
 	if( $@BG_Status != 1 || bg_current_mode() != bg_info("bg_eoe", BG_INFO_ID) || .Owner == 0 || .Owner != getcharid(4) || getvariableofnpc(.Flag_Carrier,"Neutral_Flag") != getcharid(0) )
 		end;
 
-	//bg_rankpoints "eos_flags",1;
+	bg_rankpoints "eos_flags",1;
 	set getvariableofnpc(.Flag_Carrier,"Neutral_Flag"), 0;
 	pcblock 1,0; // UnBlock Skills/Items
 	if( .Owner == $@BG_Team1 )
@@ -383,7 +383,7 @@ OnTimer1000:
 			set .Owner, $@BG_Team1; // Team 1
 			setnpcdisplay "North_Base",bg_get_data($@BG_Team1,2) + " Base",1912;
 			mapannounce "bg_eoe","North Base captured by " + bg_get_data($@BG_Team1,2),1,bg_info(bg_current_mode(), BG_INFO_COLOR);
-			//bg_rankpoints_area $@BG_Team1,"bg_eoe",143,120,151,127,"eos_bases",1;
+			bg_rankpoints_area $@BG_Team1,"bg_eoe",143,120,151,127,"eos_bases",1;
 			donpcevent "GEoSNBW::OnEnable";
 		}
 		else if( .Balance == -20 )
@@ -392,7 +392,7 @@ OnTimer1000:
 			set .Owner, $@BG_Team2; // Team 2
 			setnpcdisplay "North_Base",bg_get_data($@BG_Team2,2) + " Base",1913;
 			mapannounce "bg_eoe","North Base captured by " + bg_get_data($@BG_Team2,2),1,bg_info(bg_current_mode(), BG_INFO_COLOR);
-			//bg_rankpoints_area $@BG_Team2,"bg_eoe",143,120,151,127,"eos_bases",1;
+			bg_rankpoints_area $@BG_Team2,"bg_eoe",143,120,151,127,"eos_bases",1;
 			donpcevent "CEoSNBW::OnEnable";
 		}
 	}
@@ -454,7 +454,7 @@ OnTouch:
 	if( $@BG_Status != 1 || bg_current_mode() != bg_info("bg_eoe", BG_INFO_ID) || .Owner == 0 || .Owner != getcharid(4) || getvariableofnpc(.Flag_Carrier,"Neutral_Flag") != getcharid(0) )
 		end;
 
-	//bg_rankpoints "eos_flags",1;
+	bg_rankpoints "eos_flags",1;
 	set getvariableofnpc(.Flag_Carrier,"Neutral_Flag"), 0;
 	pcblock 1,0; // UnBlock Skills/Items
 	if( .Owner == $@BG_Team1 )
@@ -493,7 +493,7 @@ OnTimer1000:
 			set .Owner, $@BG_Team1; // Team 1
 			setnpcdisplay "South_Base",bg_get_data($@BG_Team1,2) + " Base",1912;
 			mapannounce "bg_eoe","South Base captured by " + bg_get_data($@BG_Team1,2),1,bg_info(bg_current_mode(), BG_INFO_COLOR);
-			//bg_rankpoints_area $@BG_Team1,"bg_eoe",55,52,64,60,"eos_bases",1;
+			bg_rankpoints_area $@BG_Team1,"bg_eoe",55,52,64,60,"eos_bases",1;
 			donpcevent "GEoSSBW::OnEnable";
 		}
 		else if( .Balance == -20 )
@@ -502,7 +502,7 @@ OnTimer1000:
 			set .Owner, $@BG_Team2; // Team 2
 			setnpcdisplay "South_Base",bg_get_data($@BG_Team2,2) + " Base",1913;
 			mapannounce "bg_eoe","South Base captured by " + bg_get_data($@BG_Team2,2),1,bg_info(bg_current_mode(), BG_INFO_COLOR);
-			//bg_rankpoints_area $@BG_Team2,"bg_eoe",55,52,64,60,"eos_bases",1;
+			bg_rankpoints_area $@BG_Team2,"bg_eoe",55,52,64,60,"eos_bases",1;
 			donpcevent "CEoSSBW::OnEnable";
 		}
 	}
diff --git a/npc/battleground-extended/6-bg_sc.txt b/npc/battleground-extended/6-bg_sc.txt
index b4dca6d72..817a4d6f7 100644
--- a/npc/battleground-extended/6-bg_sc.txt
+++ b/npc/battleground-extended/6-bg_sc.txt
@@ -33,8 +33,8 @@ OnTeam2Die:
 		getmapxy .@m$, .@x, .@y, BL_PC;
 		movenpc "Neutral Stone#" + .@Stone, .@x, .@y;
 		mapannounce "bg_sc","Neutral Stone Droped by [ " + strcharinfo(0) + " ]",1,0xFFFFFF;
-		//bg_rankpoints "sc_droped",1;
-		//bg_rankpoints "fame",1,@killer_bg_src;
+		bg_rankpoints "sc_droped",1;
+		bg_rankpoints "fame",1,@killer_bg_src;
 		initnpctimer "Neutral Stone#" + .@Stone;
 		deltimer "Flavius_SC::OnFlash";
 		pcblock 1,0;
@@ -259,7 +259,7 @@ OnTouch:
 		pcblock 1,1; // Block Skills/Items
 
 		mapannounce "bg_sc",bg_get_data($@BG_Team2,2) + " Stone has been stole by [ " + strcharinfo(0) + " ]",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
-		//bg_rankpoints "sc_stole",1;
+		bg_rankpoints "sc_stole",1;
 
 		addtimer 2000, "Flavius_SC::OnFlash";
 		set .Point,0;
@@ -273,7 +273,7 @@ OnTouch:
 		deltimer "Flavius_SC::OnFlash";
 
 		mapannounce "bg_sc",bg_get_data($@BG_Team2,2) + " Stone captured by [ " + strcharinfo(0) + " ]",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
-		//bg_rankpoints "sc_captured",1;
+		bg_rankpoints "sc_captured",1;
 		pcblock 1,0; // UnBlock Skills/Items
 
 		setnpcdisplay strnpcinfo(3),bg_get_data($@BG_Team2,2) + " Stone",1905;
@@ -321,7 +321,7 @@ OnTouch:
 		pcblock 1,1; // Block Skills/Items
 
 		mapannounce "bg_sc",bg_get_data($@BG_Team2,2) + " Stone has been stole by [ " + strcharinfo(0) + " ]",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
-		//bg_rankpoints "sc_stole",1;
+		bg_rankpoints "sc_stole",1;
 
 		addtimer 2000, "Flavius_SC::OnFlash";
 		set .Point,0;
@@ -335,7 +335,7 @@ OnTouch:
 		deltimer "Flavius_SC::OnFlash";
 
 		mapannounce "bg_sc",bg_get_data($@BG_Team2,2) + " Stone captured by [ " + strcharinfo(0) + " ]",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
-		//bg_rankpoints "sc_captured",1;
+		bg_rankpoints "sc_captured",1;
 		pcblock 1,0; // UnBlock Skills/Items
 
 		setnpcdisplay strnpcinfo(3),bg_get_data($@BG_Team2,2) + " Stone",1905;
@@ -383,7 +383,7 @@ OnTouch:
 		pcblock 1,1; // Block Skills/Items
 
 		mapannounce "bg_sc",bg_get_data($@BG_Team2,2) + " Stone has been stole by [ " + strcharinfo(0) + " ]",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
-		//bg_rankpoints "sc_stole",1;
+		bg_rankpoints "sc_stole",1;
 
 		addtimer 2000, "Flavius_SC::OnFlash";
 		set .Point,0;
@@ -397,7 +397,7 @@ OnTouch:
 		deltimer "Flavius_SC::OnFlash";
 
 		mapannounce "bg_sc",bg_get_data($@BG_Team2,2) + " Stone captured by [ " + strcharinfo(0) + " ]",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
-		//bg_rankpoints "sc_captured",1;
+		bg_rankpoints "sc_captured",1;
 		pcblock 1,0; // UnBlock Skills/Items
 
 		setnpcdisplay strnpcinfo(3),bg_get_data($@BG_Team2,2) + " Stone",1905;
@@ -445,7 +445,7 @@ OnTouch:
 		pcblock 1,1; // Block Skills/Items
 
 		mapannounce "bg_sc",bg_get_data($@BG_Team2,2) + " Stone has been stole by [ " + strcharinfo(0) + " ]",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
-		//bg_rankpoints "sc_stole",1;
+		bg_rankpoints "sc_stole",1;
 
 		addtimer 2000, "Flavius_SC::OnFlash";
 		set .Point,0;
@@ -459,7 +459,7 @@ OnTouch:
 		deltimer "Flavius_SC::OnFlash";
 
 		mapannounce "bg_sc",bg_get_data($@BG_Team2,2) + " Stone captured by [ " + strcharinfo(0) + " ]",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
-		//bg_rankpoints "sc_captured",1;
+		bg_rankpoints "sc_captured",1;
 		pcblock 1,0; // UnBlock Skills/Items
 
 		setnpcdisplay strnpcinfo(3),bg_get_data($@BG_Team2,2) + " Stone",1905;
@@ -507,7 +507,7 @@ OnTouch:
 		pcblock 1,1; // Block Skills/Items
 
 		mapannounce "bg_sc",bg_get_data($@BG_Team2,2) + " Stone has been stole by [ " + strcharinfo(0) + " ]",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
-		//bg_rankpoints "sc_stole",1;
+		bg_rankpoints "sc_stole",1;
 
 		addtimer 2000, "Flavius_SC::OnFlash";
 		set .Point,0;
@@ -521,7 +521,7 @@ OnTouch:
 		deltimer "Flavius_SC::OnFlash";
 
 		mapannounce "bg_sc",bg_get_data($@BG_Team2,2) + " Stone captured by [ " + strcharinfo(0) + " ]",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
-		//bg_rankpoints "sc_captured",1;
+		bg_rankpoints "sc_captured",1;
 		pcblock 1,0; // UnBlock Skills/Items
 
 		setnpcdisplay strnpcinfo(3),bg_get_data($@BG_Team2,2) + " Stone",1905;
@@ -569,7 +569,7 @@ OnTouch:
 		pcblock 1,1; // Block Skills/Items
 
 		mapannounce "bg_sc",bg_get_data($@BG_Team2,2) + " Stone has been stole by [ " + strcharinfo(0) + " ]",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
-		//bg_rankpoints "sc_stole",1;
+		bg_rankpoints "sc_stole",1;
 
 		addtimer 2000, "Flavius_SC::OnFlash";
 		set .Point,0;
@@ -583,7 +583,7 @@ OnTouch:
 		deltimer "Flavius_SC::OnFlash";
 
 		mapannounce "bg_sc",bg_get_data($@BG_Team2,2) + " Stone captured by [ " + strcharinfo(0) + " ]",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
-		//bg_rankpoints "sc_captured",1;
+		bg_rankpoints "sc_captured",1;
 		pcblock 1,0; // UnBlock Skills/Items
 
 		setnpcdisplay strnpcinfo(3),bg_get_data($@BG_Team2,2) + " Stone",1905;
@@ -634,7 +634,7 @@ OnTouch:
 		pcblock 1,1; // Block Skills/Items
 
 		mapannounce "bg_sc",bg_get_data($@BG_Team1,2) + " Stone has been stole by [ " + strcharinfo(0) + " ]",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
-		//bg_rankpoints "sc_stole",1;
+		bg_rankpoints "sc_stole",1;
 
 		addtimer 2000, "Flavius_SC::OnFlash";
 		set .Point,0;
@@ -648,7 +648,7 @@ OnTouch:
 		deltimer "Flavius_SC::OnFlash";
 
 		mapannounce "bg_sc",bg_get_data($@BG_Team1,2) + " Stone captured by [ " + strcharinfo(0) + " ]",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
-		//bg_rankpoints "sc_captured",1;
+		bg_rankpoints "sc_captured",1;
 		pcblock 1,0; // UnBlock Skills/Items
 
 		setnpcdisplay strnpcinfo(3),bg_get_data($@BG_Team1,2) + " Stone",1905;
@@ -696,7 +696,7 @@ OnTouch:
 		pcblock 1,1; // Block Skills/Items
 
 		mapannounce "bg_sc",bg_get_data($@BG_Team1,2) + " Stone has been stole by [ " + strcharinfo(0) + " ]",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
-		//bg_rankpoints "sc_stole",1;
+		bg_rankpoints "sc_stole",1;
 
 		addtimer 2000, "Flavius_SC::OnFlash";
 		set .Point,0;
@@ -710,7 +710,7 @@ OnTouch:
 		deltimer "Flavius_SC::OnFlash";
 
 		mapannounce "bg_sc",bg_get_data($@BG_Team1,2) + " Stone captured by [ " + strcharinfo(0) + " ]",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
-		//bg_rankpoints "sc_captured",1;
+		bg_rankpoints "sc_captured",1;
 		pcblock 1,0; // UnBlock Skills/Items
 
 		setnpcdisplay strnpcinfo(3),bg_get_data($@BG_Team1,2) + " Stone",1905;
@@ -758,7 +758,7 @@ OnTouch:
 		pcblock 1,1; // Block Skills/Items
 
 		mapannounce "bg_sc",bg_get_data($@BG_Team1,2) + " Stone has been stole by [ " + strcharinfo(0) + " ]",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
-		//bg_rankpoints "sc_stole",1;
+		bg_rankpoints "sc_stole",1;
 
 		addtimer 2000, "Flavius_SC::OnFlash";
 		set .Point,0;
@@ -772,7 +772,7 @@ OnTouch:
 		deltimer "Flavius_SC::OnFlash";
 
 		mapannounce "bg_sc",bg_get_data($@BG_Team1,2) + " Stone captured by [ " + strcharinfo(0) + " ]",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
-		//bg_rankpoints "sc_captured",1;
+		bg_rankpoints "sc_captured",1;
 		pcblock 1,0; // UnBlock Skills/Items
 
 		setnpcdisplay strnpcinfo(3),bg_get_data($@BG_Team1,2) + " Stone",1905;
@@ -820,7 +820,7 @@ OnTouch:
 		pcblock 1,1; // Block Skills/Items
 
 		mapannounce "bg_sc",bg_get_data($@BG_Team1,2) + " Stone has been stole by [ " + strcharinfo(0) + " ]",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
-		//bg_rankpoints "sc_stole",1;
+		bg_rankpoints "sc_stole",1;
 
 		addtimer 2000, "Flavius_SC::OnFlash";
 		set .Point,0;
@@ -834,7 +834,7 @@ OnTouch:
 		deltimer "Flavius_SC::OnFlash";
 
 		mapannounce "bg_sc",bg_get_data($@BG_Team1,2) + " Stone captured by [ " + strcharinfo(0) + " ]",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
-		//bg_rankpoints "sc_captured",1;
+		bg_rankpoints "sc_captured",1;
 		pcblock 1,0; // UnBlock Skills/Items
 
 		setnpcdisplay strnpcinfo(3),bg_get_data($@BG_Team1,2) + " Stone",1905;
@@ -882,7 +882,7 @@ OnTouch:
 		pcblock 1,1; // Block Skills/Items
 
 		mapannounce "bg_sc",bg_get_data($@BG_Team1,2) + " Stone has been stole by [ " + strcharinfo(0) + " ]",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
-		//bg_rankpoints "sc_stole",1;
+		bg_rankpoints "sc_stole",1;
 
 		addtimer 2000, "Flavius_SC::OnFlash";
 		set .Point,0;
@@ -896,7 +896,7 @@ OnTouch:
 		deltimer "Flavius_SC::OnFlash";
 
 		mapannounce "bg_sc",bg_get_data($@BG_Team1,2) + " Stone captured by [ " + strcharinfo(0) + " ]",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
-		//bg_rankpoints "sc_captured",1;
+		bg_rankpoints "sc_captured",1;
 		pcblock 1,0; // UnBlock Skills/Items
 
 		setnpcdisplay strnpcinfo(3),bg_get_data($@BG_Team1,2) + " Stone",1905;
@@ -944,7 +944,7 @@ OnTouch:
 		pcblock 1,1; // Block Skills/Items
 
 		mapannounce "bg_sc",bg_get_data($@BG_Team1,2) + " Stone has been stole by [ " + strcharinfo(0) + " ]",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
-		//bg_rankpoints "sc_stole",1;
+		bg_rankpoints "sc_stole",1;
 
 		addtimer 2000, "Flavius_SC::OnFlash";
 		set .Point,0;
@@ -958,7 +958,7 @@ OnTouch:
 		deltimer "Flavius_SC::OnFlash";
 
 		mapannounce "bg_sc",bg_get_data($@BG_Team1,2) + " Stone captured by [ " + strcharinfo(0) + " ]",1,bg_info(bg_current_mode(), BG_INFO_COLOR);
-		//bg_rankpoints "sc_captured",1;
+		bg_rankpoints "sc_captured",1;
 		pcblock 1,0; // UnBlock Skills/Items
 
 		setnpcdisplay strnpcinfo(3),bg_get_data($@BG_Team1,2) + " Stone",1905;
diff --git a/npc/battleground-extended/7-bg_dom.txt b/npc/battleground-extended/7-bg_dom.txt
index d767656bc..2214017cc 100644
--- a/npc/battleground-extended/7-bg_dom.txt
+++ b/npc/battleground-extended/7-bg_dom.txt
@@ -44,21 +44,20 @@ OnTeamDie:
 		set .@Base, getvariableofnpc(.Owner,"Dom_S_Base"); // South
 	else end; // Not Killed on Base territory
 
-	/*
 	if( .@Base == 1 )
 	{ // Team 1
 		if( getcharid(4) == $@BG_Team1 )
-			//bg_rankpoints "dom_off_kills",1,@killer_bg_src;
+			bg_rankpoints "dom_off_kills",1,@killer_bg_src;
 		else
-			//bg_rankpoints "dom_def_kills",1,@killer_bg_src;
+			bg_rankpoints "dom_def_kills",1,@killer_bg_src;
 	}
 	else if( .@Base == 2 )
 	{ // Team 2
 		if( getcharid(4) == $@BG_Team2 )
-			//bg_rankpoints "dom_off_kills",1,@killer_bg_src;
+			bg_rankpoints "dom_off_kills",1,@killer_bg_src;
 		else
-			//bg_rankpoints "dom_def_kills",1,@killer_bg_src;
-	}*/
+			bg_rankpoints "dom_def_kills",1,@killer_bg_src;
+	}
 	end;
 
 OnReady:
@@ -210,7 +209,7 @@ OnTimer1000:
 			set .Owner, 1; // Team 1
 			setnpcdisplay "Dom_N_Base",bg_get_data($@BG_Team1,2) + " Base",1912;
 			mapannounce "bg_dom","North Base captured by " + bg_get_data($@BG_Team1,2),1,bg_info(bg_current_mode(), BG_INFO_COLOR);
-			//bg_rankpoints_area $@BG_Team1,"bg_dom",126,112,149,131,"dom_bases",1;
+			bg_rankpoints_area $@BG_Team1,"bg_dom",126,112,149,131,"dom_bases",1;
 		}
 		else if( .Balance == -50 )
 		{
@@ -218,7 +217,7 @@ OnTimer1000:
 			set .Owner, 2; // Team 2
 			setnpcdisplay "Dom_N_Base",bg_get_data($@BG_Team2,2) + " Base",1913;
 			mapannounce "bg_dom","North Base captured by " + bg_get_data($@BG_Team2,2),1,bg_info(bg_current_mode(), BG_INFO_COLOR);
-			//bg_rankpoints_area $@BG_Team2,"bg_dom",126,112,149,131,"dom_bases",1;
+			bg_rankpoints_area $@BG_Team2,"bg_dom",126,112,149,131,"dom_bases",1;
 		}
 		break;
 	case 1:
@@ -303,7 +302,7 @@ OnTimer1000:
 			set .Owner, 1; // Team 1
 			setnpcdisplay "Dom_C_Base",bg_get_data($@BG_Team1,2) + " Base",1912;
 			mapannounce "bg_dom","Center Base captured by " + bg_get_data($@BG_Team1,2),1,bg_info(bg_current_mode(), BG_INFO_COLOR);
-			//bg_rankpoints_area $@BG_Team1,"bg_dom",86,82,113,101,"dom_bases",1;
+			bg_rankpoints_area $@BG_Team1,"bg_dom",86,82,113,101,"dom_bases",1;
 		}
 		else if( .Balance == -50 )
 		{
@@ -311,7 +310,7 @@ OnTimer1000:
 			set .Owner, 2; // Team 2
 			setnpcdisplay "Dom_C_Base",bg_get_data($@BG_Team2,2) + " Base",1913;
 			mapannounce "bg_dom","Center Base captured by Croix Team",1,0xFF0000;
-			//bg_rankpoints_area $@BG_Team2,"bg_dom",86,82,113,101,"dom_bases",1;
+			bg_rankpoints_area $@BG_Team2,"bg_dom",86,82,113,101,"dom_bases",1;
 		}
 		break;
 	case 1:
@@ -396,7 +395,7 @@ OnTimer1000:
 			set .Owner, 1; // Team 1
 			setnpcdisplay "Dom_S_Base",bg_get_data($@BG_Team1,2) + " Base",1912;
 			mapannounce "bg_dom","South Base captured by " + bg_get_data($@BG_Team1,2),1,bg_info(bg_current_mode(), BG_INFO_COLOR);
-			//bg_rankpoints_area $@BG_Team1,"bg_dom",50,52,69,69,"dom_bases",1;
+			bg_rankpoints_area $@BG_Team1,"bg_dom",50,52,69,69,"dom_bases",1;
 		}
 		else if( .Balance == -50 )
 		{
@@ -404,7 +403,7 @@ OnTimer1000:
 			set .Owner, 2; // Team 2
 			setnpcdisplay "Dom_S_Base",bg_get_data($@BG_Team2,2) + " Base",1913;
 			mapannounce "bg_dom","South Base captured by " + bg_get_data($@BG_Team2,2),1,bg_info(bg_current_mode(), BG_INFO_COLOR);
-			//bg_rankpoints_area $@BG_Team2,"bg_dom",50,52,69,69,"dom_bases",1;
+			bg_rankpoints_area $@BG_Team2,"bg_dom",50,52,69,69,"dom_bases",1;
 		}
 		break;
 	case 1:
diff --git a/sql-files/battleground_ranking.sql b/sql-files/battleground_ranking.sql
new file mode 100644
index 000000000..4163fddc8
--- /dev/null
+++ b/sql-files/battleground_ranking.sql
@@ -0,0 +1,227 @@
+DROP TABLE IF EXISTS `rank_bg`;
+CREATE TABLE `rank_bg` (
+  `char_id` int(11) NOT NULL,
+  `top_damage` int(11) NOT NULL default '0',
+  `damage_done` int(11) NOT NULL default '0',
+  `damage_received` int(11) NOT NULL default '0',
+  `ctf_taken` int(11) NOT NULL default '0',
+  `ctf_captured` int(11) NOT NULL default '0',
+  `ctf_droped` int(11) NOT NULL default '0',
+  `ctf_wins` int(11) NOT NULL default '0',
+  `ctf_lost` int(11) NOT NULL default '0',
+  `ctf_tie` int(11) NOT NULL default '0',
+  `tdm_kills` int(11) NOT NULL default '0',
+  `tdm_deaths` int(11) NOT NULL default '0',
+  `tdm_wins` int(11) NOT NULL default '0',
+  `tdm_lost` int(11) NOT NULL default '0',
+  `tdm_tie` int(11) NOT NULL default '0',
+  `eos_flags` int(11) NOT NULL default '0',
+  `eos_bases` int(11) NOT NULL default '0',
+  `eos_wins` int(11) NOT NULL default '0',
+  `eos_lost` int(11) NOT NULL default '0',
+  `eos_tie` int(11) NOT NULL default '0',
+  `emperium_kill` int(11) NOT NULL default '0',
+  `barricade_kill` int(11) NOT NULL default '0',
+  `gstone_kill` int(11) NOT NULL default '0',
+  `cq_wins` int(11) NOT NULL default '0',
+  `cq_lost` int(11) NOT NULL default '0',
+  `kvm_kills` int(11) NOT NULL default '0',
+  `kvm_deaths` int(11) NOT NULL default '0',
+  `kvm_wins` int(11) NOT NULL default '0',
+  `kvm_lost` int(11) NOT NULL default '0',
+  `kvm_tie` int(11) NOT NULL default '0',
+  `sc_stole` int(11) NOT NULL default '0',
+  `sc_captured` int(11) NOT NULL default '0',
+  `sc_droped` int(11) NOT NULL default '0',
+  `sc_wins` int(11) NOT NULL default '0',
+  `sc_lost` int(11) NOT NULL default '0',
+  `sc_tie` int(11) NOT NULL default '0',
+  `dom_bases` int(11) NOT NULL default '0',
+  `dom_off_kills` int(11) NOT NULL default '0',
+  `dom_def_kills` int(11) NOT NULL default '0',
+  `dom_wins` int(11) NOT NULL default '0',
+  `dom_lost` int(11) NOT NULL default '0',
+  `dom_tie` int(11) NOT NULL default '0',
+  `ru_captures` int(11) NOT NULL default '0',
+  `ru_wins` int(11) NOT NULL default '0',
+  `ru_lost` int(11) NOT NULL default '0',
+  `pb_kills` int(11) NOT NULL default '0',
+  `pb_deaths` int(11) NOT NULL default '0',
+  `pb_kill_surface` int(11) NOT NULL default '0',
+  `pb_death_surface` int(11) NOT NULL default '0',
+  `pb_scored` int(11) NOT NULL default '0',
+  `pb_score_penalty` int(11) NOT NULL default '0',
+  `pb_score_own` int(11) NOT NULL default '0',
+  `pb_penalty` int(11) NOT NULL default '0',
+  `pb_sixyard` int(11) NOT NULL default '0',
+  `pb_wins` int(11) NOT NULL default '0',
+  `pb_lost` int(11) NOT NULL default '0',
+  `pb_tie` int(11) NOT NULL default '0',
+  `td_taken` int(11) NOT NULL default '0',
+  `td_scored` int(11) NOT NULL default '0',
+  `td_kills` int(11) NOT NULL default '0',
+  `td_kill_fumbi` int(11) NOT NULL default '0',
+  `td_kill_wfumbi` int(11) NOT NULL default '0',
+  `td_deaths` int(11) NOT NULL default '0',
+  `td_death_fumbi` int(11) NOT NULL default '0',
+  `td_death_wfumbi` int(11) NOT NULL default '0',
+  `td_wins` int(11) NOT NULL default '0',
+  `td_lost` int(11) NOT NULL default '0',
+  `td_tie` int(11) NOT NULL default '0',
+  `kill_count` int(11) NOT NULL default '0',
+  `death_count` int(11) NOT NULL default '0',
+  `win` int(11) NOT NULL default '0',
+  `lost` int(11) NOT NULL default '0',
+  `tie` int(11) NOT NULL default '0',
+  `leader_win` int(11) NOT NULL default '0',
+  `leader_lost` int(11) NOT NULL default '0',
+  `leader_tie` int(11) NOT NULL default '0',
+  `deserter` int(11) NOT NULL default '0',
+  `score` int(11) NOT NULL default '0',
+  `points` int(11) NOT NULL default '0',
+  `sp_heal_potions` int(11) NOT NULL default '0',
+  `hp_heal_potions` int(11) NOT NULL default '0',
+  `yellow_gemstones` int(11) NOT NULL default '0',
+  `red_gemstones` int(11) NOT NULL default '0',
+  `blue_gemstones` int(11) NOT NULL default '0',
+  `poison_bottles` int(11) NOT NULL default '0',
+  `acid_demostration` int(11) NOT NULL default '0',
+  `acid_demostration_fail` int(11) NOT NULL default '0',
+  `support_skills_used` int(11) NOT NULL default '0',
+  `healing_done` int(11) NOT NULL default '0',
+  `wrong_support_skills_used` int(11) NOT NULL default '0',
+  `wrong_healing_done` int(11) NOT NULL default '0',
+  `sp_used` int(11) NOT NULL default '0',
+  `zeny_used` int(11) NOT NULL default '0',
+  `spiritb_used` int(11) NOT NULL default '0',
+  `ammo_used` int(11) NOT NULL default '0',
+PRIMARY KEY  (`char_id`)
+) ENGINE=InnoDB;
+
+
+DROP TABLE IF EXISTS `rank_woe`;
+CREATE TABLE `rank_woe` (
+  `char_id` int(11) NOT NULL,
+  `kill_count` int(11) NOT NULL default '0',
+  `death_count` int(11) NOT NULL default '0',
+  `score` int(11) NOT NULL default '0',
+  `top_damage` int(11) NOT NULL default '0',
+  `damage_done` int(11) NOT NULL default '0',
+  `damage_received` int(11) NOT NULL default '0',
+  `emperium_damage` int(11) NOT NULL default '0',
+  `guardian_damage` int(11) NOT NULL default '0',
+  `barricade_damage` int(11) NOT NULL default '0',
+  `gstone_damage` int(11) NOT NULL default '0',
+  `emperium_kill` int(11) NOT NULL default '0',
+  `guardian_kill` int(11) NOT NULL default '0',
+  `barricade_kill` int(11) NOT NULL default '0',
+  `gstone_kill` int(11) NOT NULL default '0',
+  `sp_heal_potions` int(11) NOT NULL default '0',
+  `hp_heal_potions` int(11) NOT NULL default '0',
+  `yellow_gemstones` int(11) NOT NULL default '0',
+  `red_gemstones` int(11) NOT NULL default '0',
+  `blue_gemstones` int(11) NOT NULL default '0',
+  `poison_bottles` int(11) NOT NULL default '0',
+  `acid_demostration` int(11) NOT NULL default '0',
+  `acid_demostration_fail` int(11) NOT NULL default '0',
+  `support_skills_used` int(11) NOT NULL default '0',
+  `healing_done` int(11) NOT NULL default '0',
+  `wrong_support_skills_used` int(11) NOT NULL default '0',
+  `wrong_healing_done` int(11) NOT NULL default '0',
+  `sp_used` int(11) NOT NULL default '0',
+  `zeny_used` int(11) NOT NULL default '0',
+  `spiritb_used` int(11) NOT NULL default '0',
+  `ammo_used` int(11) NOT NULL default '0',
+  PRIMARY KEY  (`char_id`)
+) ENGINE=InnoDB;
+
+
+DROP TABLE IF EXISTS `rank_skill_count`;
+CREATE TABLE `rank_skill_count` (
+  `char_id` int(11) unsigned NOT NULL default '0',
+  `id` smallint(11) unsigned NOT NULL default '0',
+  `count` int(11) unsigned NOT NULL default '0',
+  PRIMARY KEY  (`char_id`,`id`),
+  KEY `char_id` (`char_id`)
+) ENGINE=InnoDB;
+
+DROP TABLE IF EXISTS `rank_bg_skill_count`;
+CREATE TABLE `rank_bg_skill_count` (
+  `char_id` int(11) unsigned NOT NULL default '0',
+  `id` smallint(11) unsigned NOT NULL default '0',
+  `count` int(11) unsigned NOT NULL default '0',
+  PRIMARY KEY  (`char_id`,`id`),
+  KEY `char_id` (`char_id`)
+) ENGINE=InnoDB;
+
+
+DROP TABLE IF EXISTS `rank_guild`;
+CREATE TABLE `rank_guild` (
+  `guild_id` int(11) NOT NULL,
+  `castle_id` int(11) NOT NULL,
+  `capture` int(11) unsigned NOT NULL default '0',
+  `emperium` int(11) unsigned NOT NULL default '0',
+  `treasure` int(11) unsigned NOT NULL default '0',
+  `top_eco` int(11) unsigned NOT NULL default '0',
+  `top_def` int(11) unsigned NOT NULL default '0',
+  `invest_eco` int(11) unsigned NOT NULL default '0',
+  `invest_def` int(11) unsigned NOT NULL default '0',
+  `offensive_score` int(11) unsigned NOT NULL default '0',
+  `defensive_score` int(11) unsigned NOT NULL default '0',
+  `posesion_time` int(11) unsigned NOT NULL default '0',
+  `zeny_eco` int(11) unsigned NOT NULL default '0',
+  `zeny_def` int(11) unsigned NOT NULL default '0',
+  
+  `skill_battleorder` int(11) unsigned NOT NULL default '0',
+  `skill_regeneration` int(11) unsigned NOT NULL default '0',
+  `skill_restore` int(11) unsigned NOT NULL default '0',
+  `skill_emergencycall` int(11) unsigned NOT NULL default '0',
+
+  `off_kill` int(11) unsigned NOT NULL default '0',
+  `off_death` int(11) unsigned NOT NULL default '0',
+  `def_kill` int(11) unsigned NOT NULL default '0',
+  `def_death` int(11) unsigned NOT NULL default '0',
+  `ext_kill` int(11) unsigned NOT NULL default '0',
+  `ext_death` int(11) unsigned NOT NULL default '0',
+  `ali_kill` int(11) unsigned NOT NULL default '0',
+  `ali_death` int(11) unsigned NOT NULL default '0',
+  
+  PRIMARY KEY  (`guild_id`,`castle_id`),
+  KEY `castle_id` (`castle_id`)
+) ENGINE=InnoDB;
+
+
+DROP TABLE IF EXISTS `rank_bg_log`;
+CREATE TABLE `rank_bg_log` (
+  `id` int(11) NOT NULL auto_increment,
+  `time` datetime NOT NULL default '0000-00-00 00:00:00',
+  `killer` varchar(25) NOT NULL,
+  `killer_id` int(11) NOT NULL,
+  `killed` varchar(25) NOT NULL,
+  `killed_id` int(11) NOT NULL,
+  `map` varchar(11) NOT NULL default '',
+  `skill` int(11) NOT NULL default '0',
+  PRIMARY KEY  (`id`),
+  KEY `killer_id` (`killer_id`),
+  KEY `killed_id` (`killed_id`)
+) ENGINE=MyISAM;
+
+DROP TABLE IF EXISTS `rank_woe_log`;
+CREATE TABLE `rank_woe_log` (
+  `id` int(11) NOT NULL auto_increment,
+  `time` datetime NOT NULL default '0000-00-00 00:00:00',
+  `killer` varchar(25) NOT NULL,
+  `killer_id` int(11) NOT NULL,
+  `killed` varchar(25) NOT NULL,
+  `killed_id` int(11) NOT NULL,
+  `map` varchar(11) NOT NULL default '',
+  `skill` int(11) NOT NULL default '0',
+  PRIMARY KEY  (`id`),
+  KEY `killer_id` (`killer_id`),
+  KEY `killed_id` (`killed_id`)
+) ENGINE=MyISAM;
+
+
+ALTER TABLE `char` ADD COLUMN `bg_gold` int(11) NOT NULL default '0';
+ALTER TABLE `char` ADD COLUMN `bg_silver` int(11) NOT NULL default '0';
+ALTER TABLE `char` ADD COLUMN `bg_bronze` int(11) NOT NULL default '0';
diff --git a/src/char/char.cpp b/src/char/char.cpp
index 3aea9bfeb..87ee35136 100644
--- a/src/char/char.cpp
+++ b/src/char/char.cpp
@@ -46,10 +46,12 @@ struct mmo_map_server map_server[MAX_MAP_SERVERS];
 int fame_list_size_chemist = MAX_FAME_LIST;
 int fame_list_size_smith = MAX_FAME_LIST;
 int fame_list_size_taekwon = MAX_FAME_LIST;
+int fame_list_size_bg = MAX_FAME_LIST;
 // Char-server-side stored fame lists [DracoRPG]
 struct fame_list smith_fame_list[MAX_FAME_LIST];
 struct fame_list chemist_fame_list[MAX_FAME_LIST];
 struct fame_list taekwon_fame_list[MAX_FAME_LIST];
+struct fame_list bg_fame_list[MAX_FAME_LIST];
 
 #define CHAR_MAX_MSG 300	//max number of msg_conf
 static char* msg_table[CHAR_MAX_MSG]; // Login Server messages_conf
@@ -358,6 +360,151 @@ int char_mmo_char_tosql(uint32 char_id, struct mmo_charstatus* p){
 			strcat(save_status, " status2");
 	}
 
+	/* Player Battleground Stadistics */
+	if( memcmp(&p->bgstats, &cp->bgstats, sizeof(struct s_battleground_stats)) )
+	{
+		if( SQL_ERROR == Sql_Query(sql_handle, "REPLACE INTO `rank_bg` ("
+			"`char_id`, "
+			"`top_damage`, `damage_done`, `damage_received`, "
+			"`ctf_taken`, `ctf_captured`, `ctf_droped`, `ctf_wins`, `ctf_lost`, `ctf_tie`, "
+			"`tdm_kills`, `tdm_deaths`, `tdm_wins`, `tdm_lost`, `tdm_tie`, "
+			"`eos_flags`, `eos_bases`, `eos_wins`, `eos_lost`, `eos_tie`, "
+			"`emperium_kill`, `barricade_kill`, `gstone_kill`, `cq_wins`, `cq_lost`, "
+			"`kvm_kills`, `kvm_deaths`, `kvm_wins`, `kvm_lost`, `kvm_tie`, "
+			"`sc_stole`, `sc_captured`, `sc_droped`, `sc_wins`, `sc_lost`, `sc_tie`, "
+			"`dom_bases`, `dom_off_kills`, `dom_def_kills`, `dom_wins`, `dom_lost`, `dom_tie`, "
+			"`ru_captures`, `ru_wins`, `ru_lost`, "
+			"`pb_kills`, `pb_deaths`, `pb_kill_surface`, `pb_death_surface`, `pb_scored`, `pb_score_penalty`, `pb_score_own`, `pb_penalty`, `pb_sixyard`, `pb_wins`, `pb_lost`, `pb_tie`, "
+			"`td_taken`, `td_scored`, `td_kills`, `td_kill_fumbi`, `td_kill_wfumbi`, `td_deaths`, `td_death_fumbi`, `td_death_wfumbi`, `td_wins`, `td_lost`, `td_tie`, "
+			"`kill_count`, `death_count`, `win`, `lost`, `tie`, `leader_win`, `leader_lost`, `leader_tie`, `deserter`, `score`, `points`,"
+			"`sp_heal_potions`, `hp_heal_potions`, `yellow_gemstones`, `red_gemstones`, `blue_gemstones`, `poison_bottles`, `acid_demostration`, `acid_demostration_fail`, "
+			"`support_skills_used`, `healing_done`, `wrong_support_skills_used`, `wrong_healing_done`, "
+			"`sp_used`, `zeny_used`, `spiritb_used`, `ammo_used`)"
+			" VALUES "
+			"('%d',"
+			"'%u','%u','%u',"
+			"'%d','%d','%d','%d','%d','%d',"
+			"'%d','%d','%d','%d','%d',"
+			"'%d','%d','%d','%d','%d',"
+			"'%d','%d','%d','%d','%d',"
+			"'%d','%d','%d','%d','%d',"
+			"'%d','%d','%d','%d','%d','%d',"
+			"'%d','%d','%d','%d','%d','%d',"
+			"'%d','%d','%d',"
+			"'%d','%d','%d','%d','%d','%d','%d','%d','%d','%d','%d','%d',"
+			"'%d','%d','%d','%d','%d','%d','%d','%d','%d','%d','%d',"
+			"'%d','%d','%d','%d','%d','%d','%d','%d','%d','%d','%d',"
+			"'%d','%d','%d','%d','%d','%d','%d','%d',"
+			"'%d','%d','%d','%d',"
+			"'%d','%d','%d','%d')",
+			p->char_id,
+			p->bgstats.top_damage, p->bgstats.damage_done, p->bgstats.damage_received,
+			p->bgstats.ctf_taken,p->bgstats.ctf_captured,p->bgstats.ctf_droped,p->bgstats.ctf_wins,p->bgstats.ctf_lost,p->bgstats.ctf_tie,
+			p->bgstats.tdm_kills,p->bgstats.tdm_deaths,p->bgstats.tdm_wins,p->bgstats.tdm_lost,p->bgstats.tdm_tie,
+			p->bgstats.eos_flags,p->bgstats.eos_bases,p->bgstats.eos_wins,p->bgstats.eos_lost,p->bgstats.eos_tie,
+			p->bgstats.emperium_kill,p->bgstats.barricade_kill,p->bgstats.gstone_kill,p->bgstats.cq_wins,p->bgstats.cq_lost,
+			p->bgstats.kvm_kills,p->bgstats.kvm_deaths,p->bgstats.kvm_wins,p->bgstats.kvm_lost,p->bgstats.kvm_tie,
+			p->bgstats.sc_stole,p->bgstats.sc_captured,p->bgstats.sc_droped,p->bgstats.sc_wins,p->bgstats.sc_lost,p->bgstats.sc_tie,
+			p->bgstats.dom_bases,p->bgstats.dom_off_kills,p->bgstats.dom_def_kills,p->bgstats.dom_wins,p->bgstats.dom_lost,p->bgstats.dom_tie,
+			p->bgstats.ru_captures,p->bgstats.ru_wins,p->bgstats.ru_lost,
+			p->bgstats.pb_kills,p->bgstats.pb_deaths,p->bgstats.pb_kill_surface,p->bgstats.pb_death_surface,p->bgstats.pb_scored,p->bgstats.pb_score_penalty,p->bgstats.pb_score_own,p->bgstats.pb_penalty,p->bgstats.pb_sixyard,p->bgstats.pb_wins,p->bgstats.pb_lost,p->bgstats.pb_tie,
+			p->bgstats.td_taken,p->bgstats.td_scored,p->bgstats.td_kills,p->bgstats.td_kill_fumbi,p->bgstats.td_kill_wfumbi,p->bgstats.td_deaths,p->bgstats.td_death_fumbi,p->bgstats.td_death_wfumbi,p->bgstats.td_wins,p->bgstats.td_lost,p->bgstats.td_tie,
+			p->bgstats.kill_count,p->bgstats.death_count,p->bgstats.win,p->bgstats.lost,p->bgstats.tie,p->bgstats.leader_win,p->bgstats.leader_lost,p->bgstats.leader_tie,p->bgstats.deserter,p->bgstats.score,p->bgstats.points,
+			p->bgstats.sp_heal_potions, p->bgstats.hp_heal_potions, p->bgstats.yellow_gemstones, p->bgstats.red_gemstones, p->bgstats.blue_gemstones, p->bgstats.poison_bottles, p->bgstats.acid_demostration, p->bgstats.acid_demostration_fail,
+			p->bgstats.support_skills_used, p->bgstats.healing_done, p->bgstats.wrong_support_skills_used, p->bgstats.wrong_healing_done,
+			p->bgstats.sp_used, p->bgstats.zeny_used, p->bgstats.spiritb_used, p->bgstats.ammo_used) )
+		{
+			Sql_ShowDebug(sql_handle);
+			errors++;
+		} else
+			strcat(save_status, " bgstats");
+	}
+
+	/* WoE Stadistics */
+	if( memcmp(&p->wstats, &cp->wstats, sizeof(struct s_woestats)) )
+	{
+		if( SQL_ERROR == Sql_Query(sql_handle, "REPLACE INTO `rank_woe` (`char_id`, `kill_count`, `death_count`, `score`, `top_damage`, `damage_done`, `damage_received`, `emperium_damage`, `guardian_damage`, `barricade_damage`, `gstone_damage`, "
+			"`emperium_kill`, `guardian_kill`, `barricade_kill`, `gstone_kill`, "
+			"`sp_heal_potions`, `hp_heal_potions`, `yellow_gemstones`, `red_gemstones`, `blue_gemstones`, `poison_bottles`, `acid_demostration`, `acid_demostration_fail`, "
+			"`support_skills_used`, `healing_done`, `wrong_support_skills_used`, `wrong_healing_done`, "
+			"`sp_used`, `zeny_used`, `spiritb_used`, `ammo_used`) "
+			"VALUES ('%d', '%d', '%d', '%d', '%u', '%u', '%u', '%u', '%u', '%u', '%u', '%d', '%d', '%d', '%d', '%u', '%u', '%u', '%u', '%u', '%u', '%u', '%u', '%u', '%u', '%u', '%u', '%u', '%u', '%u', '%u')",
+			p->char_id, p->wstats.kill_count, p->wstats.death_count, p->wstats.score, p->wstats.top_damage, p->wstats.damage_done, p->wstats.damage_received, p->wstats.emperium_damage, p->wstats.guardian_damage, p->wstats.barricade_damage, p->wstats.gstone_damage,
+			p->wstats.emperium_kill, p->wstats.guardian_kill, p->wstats.barricade_kill, p->wstats.gstone_kill,
+			p->wstats.sp_heal_potions, p->wstats.hp_heal_potions, p->wstats.yellow_gemstones, p->wstats.red_gemstones, p->wstats.blue_gemstones, p->wstats.poison_bottles, p->wstats.acid_demostration, p->wstats.acid_demostration_fail,
+			p->wstats.support_skills_used, p->wstats.healing_done, p->wstats.wrong_support_skills_used, p->wstats.wrong_healing_done,
+			p->wstats.sp_used, p->wstats.zeny_used, p->wstats.spiritb_used, p->wstats.ammo_used) )
+		{
+			Sql_ShowDebug(sql_handle);
+			errors++;
+		} else
+			strcat(save_status, " woestats");
+	}
+
+	/* Skill Usage */
+	if( memcmp(&p->skillcount, &cp->skillcount, sizeof(p->skillcount)) )
+	{
+		if( SQL_ERROR == Sql_Query(sql_handle, "DELETE FROM `rank_skill_count` WHERE `char_id` = '%d'", p->char_id) )
+		{
+			Sql_ShowDebug(sql_handle); // Clear Data
+			errors++;
+		}
+		StringBuf_Clear(&buf);
+		StringBuf_Printf(&buf, "INSERT INTO `rank_skill_count` (`char_id`,`id`,`count`) VALUES ");
+		//insert here.
+		for( i = 0, count = 0; i < MAX_SKILL_TREE; ++i )
+		{
+			if( p->skillcount[i].id && p->skillcount[i].count > 0 )
+			{
+				if( count )
+					StringBuf_AppendStr(&buf, ",");
+				StringBuf_Printf(&buf, "('%d','%d','%d')", char_id, p->skillcount[i].id, p->skillcount[i].count);
+				++count;
+			}
+		}
+		if( count )
+		{
+			if( SQL_ERROR == Sql_QueryStr(sql_handle, StringBuf_Value(&buf)) )
+			{
+				Sql_ShowDebug(sql_handle);
+				errors++;
+			}
+		}
+		strcat(save_status, " skillcount");
+	}
+
+	/* BG Skill Usage */
+	if( memcmp(&p->bg_skillcount, &cp->bg_skillcount, sizeof(p->bg_skillcount)) )
+	{
+		if( SQL_ERROR == Sql_Query(sql_handle, "DELETE FROM `rank_bg_skill_count` WHERE `char_id` = '%d'", p->char_id) )
+		{
+			Sql_ShowDebug(sql_handle); // Clear Data
+			errors++;
+		}
+		StringBuf_Clear(&buf);
+		StringBuf_Printf(&buf, "INSERT INTO `rank_bg_skill_count` (`char_id`,`id`,`count`) VALUES ");
+		//insert here.
+		for( i = 0, count = 0; i < MAX_SKILL_TREE; ++i )
+		{
+			if( p->bg_skillcount[i].id && p->bg_skillcount[i].count > 0 )
+			{
+				if( count )
+					StringBuf_AppendStr(&buf, ",");
+				StringBuf_Printf(&buf, "('%d','%d','%d')", char_id, p->bg_skillcount[i].id, p->bg_skillcount[i].count);
+				++count;
+			}
+		}
+		if( count )
+		{
+			if( SQL_ERROR == Sql_QueryStr(sql_handle, StringBuf_Value(&buf)) )
+			{
+				Sql_ShowDebug(sql_handle);
+				errors++;
+			}
+		}
+		strcat(save_status, " bg_skillcount");
+	}
+
 	/* Mercenary Owner */
 	if( (p->mer_id != cp->mer_id) ||
 		(p->arch_calls != cp->arch_calls) || (p->arch_faith != cp->arch_faith) ||
@@ -1015,6 +1162,7 @@ int char_mmo_char_fromsql(uint32 char_id, struct mmo_charstatus* p, bool load_ev
 	struct s_skill tmp_skill;
 	uint16 skill_count = 0;
 	struct s_friend tmp_friend;
+	struct s_skillcount tmp_skillcount;
 #ifdef HOTKEY_SAVING
 	struct hotkey tmp_hotkey;
 	int hotkey_num;
@@ -1221,6 +1369,173 @@ int char_mmo_char_fromsql(uint32 char_id, struct mmo_charstatus* p, bool load_ev
 	StringBuf_AppendStr(&msg_buf, " hotkeys");
 #endif
 
+	/* Character Battleground Standings */
+	if( SQL_ERROR == SqlStmt_Prepare(stmt, "SELECT `top_damage`,`damage_done`,`damage_received`,`ctf_taken`,`ctf_captured`,`ctf_droped`,`ctf_wins`,`ctf_lost`,`ctf_tie`,`tdm_kills`,`tdm_deaths`,`tdm_wins`,`tdm_lost`,`tdm_tie`,`eos_flags`,`eos_bases`,`eos_wins`,`eos_lost`,`eos_tie`,`emperium_kill`,`barricade_kill`,`gstone_kill`,`cq_wins`,`cq_lost`,`kvm_kills`,`kvm_deaths`,`kvm_wins`,`kvm_lost`,`kvm_tie`,`sc_stole`,`sc_captured`,`sc_droped`,`sc_wins`,`sc_lost`,`sc_tie`,`dom_bases`,`dom_off_kills`,`dom_def_kills`,`dom_wins`,`dom_lost`,`dom_tie`,`ru_captures`,`ru_wins`,`ru_lost`,`pb_kills`,`pb_deaths`,`pb_kill_surface`,`pb_death_surface`,`pb_scored`,`pb_score_penalty`,`pb_score_own`,`pb_penalty`,`pb_sixyard`,`pb_wins`,`pb_lost`,`pb_tie`,`td_taken`,`td_scored`,`td_kills`,`td_kill_fumbi`,`td_kill_wfumbi`,`td_deaths`,`td_death_fumbi`,`td_death_wfumbi`,`td_wins`,`td_lost`,`td_tie`,`kill_count`,`death_count`,`win`,`lost`,`tie`,`leader_win`,`leader_lost`,`leader_tie`,`deserter`,`score`,`points`,`sp_heal_potions`,`hp_heal_potions`,`yellow_gemstones`,`red_gemstones`,`blue_gemstones`,`poison_bottles`,`acid_demostration`,`acid_demostration_fail`,`support_skills_used`,`healing_done`,`wrong_support_skills_used`,`wrong_healing_done`,`sp_used`,`zeny_used`,`spiritb_used`,`ammo_used` FROM `rank_bg` WHERE `char_id` = ?")
+		|| SQL_ERROR == SqlStmt_BindParam(stmt, 0, SQLDT_INT, &char_id, 0)
+		|| SQL_ERROR == SqlStmt_Execute(stmt)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  0, SQLDT_UINT,   &p->bgstats.top_damage, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  1, SQLDT_UINT,   &p->bgstats.damage_done, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  2, SQLDT_UINT,   &p->bgstats.damage_received, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  3, SQLDT_USHORT, &p->bgstats.ctf_taken, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  4, SQLDT_USHORT, &p->bgstats.ctf_captured, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  5, SQLDT_USHORT, &p->bgstats.ctf_droped, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  6, SQLDT_USHORT, &p->bgstats.ctf_wins, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  7, SQLDT_USHORT, &p->bgstats.ctf_lost, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  8, SQLDT_USHORT, &p->bgstats.ctf_tie, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  9, SQLDT_USHORT, &p->bgstats.tdm_kills, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 10, SQLDT_USHORT, &p->bgstats.tdm_deaths, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 11, SQLDT_USHORT, &p->bgstats.tdm_wins, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 12, SQLDT_USHORT, &p->bgstats.tdm_lost, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 13, SQLDT_USHORT, &p->bgstats.tdm_tie, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 14, SQLDT_USHORT, &p->bgstats.eos_flags, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 15, SQLDT_USHORT, &p->bgstats.eos_bases, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 16, SQLDT_USHORT, &p->bgstats.eos_wins, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 17, SQLDT_USHORT, &p->bgstats.eos_lost, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 18, SQLDT_USHORT, &p->bgstats.eos_tie, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 19, SQLDT_USHORT, &p->bgstats.emperium_kill, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 20, SQLDT_USHORT, &p->bgstats.barricade_kill, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 21, SQLDT_USHORT, &p->bgstats.gstone_kill, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 22, SQLDT_USHORT, &p->bgstats.cq_wins, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 23, SQLDT_USHORT, &p->bgstats.cq_lost, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 24, SQLDT_USHORT, &p->bgstats.kvm_kills, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 25, SQLDT_USHORT, &p->bgstats.kvm_deaths, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 26, SQLDT_USHORT, &p->bgstats.kvm_wins, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 27, SQLDT_USHORT, &p->bgstats.kvm_lost, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 28, SQLDT_USHORT, &p->bgstats.kvm_tie, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 29, SQLDT_USHORT, &p->bgstats.sc_stole, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 30, SQLDT_USHORT, &p->bgstats.sc_captured, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 31, SQLDT_USHORT, &p->bgstats.sc_droped, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 32, SQLDT_USHORT, &p->bgstats.sc_wins, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 33, SQLDT_USHORT, &p->bgstats.sc_lost, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 34, SQLDT_USHORT, &p->bgstats.sc_tie, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 35, SQLDT_USHORT, &p->bgstats.dom_bases, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 36, SQLDT_USHORT, &p->bgstats.dom_off_kills, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 37, SQLDT_USHORT, &p->bgstats.dom_def_kills, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 38, SQLDT_USHORT, &p->bgstats.dom_wins, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 39, SQLDT_USHORT, &p->bgstats.dom_lost, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 40, SQLDT_USHORT, &p->bgstats.dom_tie, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 41, SQLDT_USHORT, &p->bgstats.ru_captures, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 42, SQLDT_USHORT, &p->bgstats.ru_wins, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 43, SQLDT_USHORT, &p->bgstats.ru_lost, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 44, SQLDT_USHORT, &p->bgstats.pb_kills, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 45, SQLDT_USHORT, &p->bgstats.pb_deaths, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 46, SQLDT_USHORT, &p->bgstats.pb_kill_surface, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 47, SQLDT_USHORT, &p->bgstats.pb_death_surface, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 48, SQLDT_USHORT, &p->bgstats.pb_scored, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 49, SQLDT_USHORT, &p->bgstats.pb_score_penalty, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 50, SQLDT_USHORT, &p->bgstats.pb_score_own, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 51, SQLDT_USHORT, &p->bgstats.pb_penalty, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 52, SQLDT_USHORT, &p->bgstats.pb_sixyard, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 53, SQLDT_USHORT, &p->bgstats.pb_wins, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 54, SQLDT_USHORT, &p->bgstats.pb_lost, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 55, SQLDT_USHORT, &p->bgstats.pb_tie, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 56, SQLDT_USHORT, &p->bgstats.td_taken, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 57, SQLDT_USHORT, &p->bgstats.td_scored, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 58, SQLDT_USHORT, &p->bgstats.td_kills, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 59, SQLDT_USHORT, &p->bgstats.td_kill_fumbi, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 60, SQLDT_USHORT, &p->bgstats.td_kill_wfumbi, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 61, SQLDT_USHORT, &p->bgstats.td_deaths, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 62, SQLDT_USHORT, &p->bgstats.td_death_fumbi, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 63, SQLDT_USHORT, &p->bgstats.td_death_wfumbi, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 64, SQLDT_USHORT, &p->bgstats.td_wins, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 65, SQLDT_USHORT, &p->bgstats.td_lost, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 66, SQLDT_USHORT, &p->bgstats.td_tie, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 67, SQLDT_USHORT, &p->bgstats.kill_count, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 68, SQLDT_USHORT, &p->bgstats.death_count, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 69, SQLDT_USHORT, &p->bgstats.win, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 70, SQLDT_USHORT, &p->bgstats.lost, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 71, SQLDT_USHORT, &p->bgstats.tie, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 72, SQLDT_USHORT, &p->bgstats.leader_win, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 73, SQLDT_USHORT, &p->bgstats.leader_lost, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 74, SQLDT_USHORT, &p->bgstats.leader_tie, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 75, SQLDT_USHORT, &p->bgstats.deserter, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 76, SQLDT_USHORT, &p->bgstats.score, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 77, SQLDT_INT,    &p->bgstats.points, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 78, SQLDT_UINT,   &p->bgstats.sp_heal_potions, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 79, SQLDT_UINT,   &p->bgstats.hp_heal_potions, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 80, SQLDT_UINT,   &p->bgstats.yellow_gemstones, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 81, SQLDT_UINT,   &p->bgstats.red_gemstones, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 82, SQLDT_UINT,   &p->bgstats.blue_gemstones, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 83, SQLDT_UINT,   &p->bgstats.poison_bottles, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 84, SQLDT_UINT,   &p->bgstats.acid_demostration, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 85, SQLDT_UINT,   &p->bgstats.acid_demostration_fail, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 86, SQLDT_UINT,   &p->bgstats.support_skills_used, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 87, SQLDT_UINT,   &p->bgstats.healing_done, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 88, SQLDT_UINT,   &p->bgstats.wrong_support_skills_used, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 89, SQLDT_UINT,   &p->bgstats.wrong_healing_done, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 90, SQLDT_UINT,   &p->bgstats.sp_used, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 91, SQLDT_UINT,   &p->bgstats.zeny_used, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 92, SQLDT_UINT,   &p->bgstats.spiritb_used, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 93, SQLDT_UINT,   &p->bgstats.ammo_used, 0, NULL, NULL)
+		|| SQL_SUCCESS != SqlStmt_NextRow(stmt) )
+	{
+		p->bgstats.score = 2000;
+	}
+	StringBuf_AppendStr(&msg_buf, " bgstats");
+
+	/* Character WoE Standings */
+	if( SQL_ERROR == SqlStmt_Prepare(stmt, "SELECT `top_damage`, `damage_done`, `damage_received`, `emperium_damage`, `guardian_damage`, `barricade_damage`, `gstone_damage`, `emperium_kill`, `guardian_kill`, `barricade_kill`, `gstone_kill`, `sp_heal_potions`, `hp_heal_potions`, `yellow_gemstones`, `red_gemstones`, `blue_gemstones`, `poison_bottles`, `acid_demostration`, `acid_demostration_fail`, `support_skills_used`, `healing_done`, `wrong_support_skills_used`, `wrong_healing_done`, `sp_used`, `zeny_used`, `spiritb_used`, `ammo_used`, `kill_count`, `death_count`, `score` FROM `rank_woe` WHERE `char_id` = ?")
+		|| SQL_ERROR == SqlStmt_BindParam(stmt, 0, SQLDT_INT, &char_id, 0)
+		|| SQL_ERROR == SqlStmt_Execute(stmt)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  0, SQLDT_UINT, &p->wstats.top_damage, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  1, SQLDT_UINT, &p->wstats.damage_done, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  2, SQLDT_UINT, &p->wstats.damage_received, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  3, SQLDT_UINT, &p->wstats.emperium_damage, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  4, SQLDT_UINT, &p->wstats.guardian_damage, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  5, SQLDT_UINT, &p->wstats.barricade_damage, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  6, SQLDT_UINT, &p->wstats.gstone_damage, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  7, SQLDT_USHORT, &p->wstats.emperium_kill, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  8, SQLDT_USHORT, &p->wstats.guardian_kill, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  9, SQLDT_USHORT, &p->wstats.barricade_kill, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 10, SQLDT_USHORT, &p->wstats.gstone_kill, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 11, SQLDT_UINT, &p->wstats.sp_heal_potions, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 12, SQLDT_UINT, &p->wstats.hp_heal_potions, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 13, SQLDT_UINT, &p->wstats.yellow_gemstones, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 14, SQLDT_UINT, &p->wstats.red_gemstones, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 15, SQLDT_UINT, &p->wstats.blue_gemstones, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 16, SQLDT_UINT, &p->wstats.poison_bottles, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 17, SQLDT_UINT, &p->wstats.acid_demostration, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 18, SQLDT_UINT, &p->wstats.acid_demostration_fail, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 19, SQLDT_UINT, &p->wstats.support_skills_used, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 20, SQLDT_UINT, &p->wstats.healing_done, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 21, SQLDT_UINT, &p->wstats.wrong_support_skills_used, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 22, SQLDT_UINT, &p->wstats.wrong_healing_done, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 23, SQLDT_UINT, &p->wstats.sp_used, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 24, SQLDT_UINT, &p->wstats.zeny_used, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 25, SQLDT_UINT, &p->wstats.spiritb_used, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 26, SQLDT_UINT, &p->wstats.ammo_used, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 27, SQLDT_USHORT, &p->wstats.kill_count, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 28, SQLDT_USHORT, &p->wstats.death_count, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 29, SQLDT_USHORT, &p->wstats.score, 0, NULL, NULL)
+		|| SQL_SUCCESS != SqlStmt_NextRow(stmt) )
+	{
+		p->wstats.score = 2000;
+	}
+	StringBuf_AppendStr(&msg_buf, " woestats");
+
+	/* Skill Usage */
+	if( SQL_ERROR == SqlStmt_Prepare(stmt, "SELECT `id`, `count` FROM `rank_skill_count` WHERE `char_id` = ? LIMIT %d", MAX_SKILL_TREE)
+	||	SQL_ERROR == SqlStmt_BindParam(stmt, 0, SQLDT_INT, &char_id, 0)
+	||	SQL_ERROR == SqlStmt_Execute(stmt)
+	||	SQL_ERROR == SqlStmt_BindColumn(stmt, 0, SQLDT_USHORT, &tmp_skillcount.id, 0, NULL, NULL)
+	||	SQL_ERROR == SqlStmt_BindColumn(stmt, 1, SQLDT_USHORT, &tmp_skillcount.count, 0, NULL, NULL) )
+		SqlStmt_ShowDebug(stmt);
+
+	for( i = 0; i < MAX_SKILL_TREE && SQL_SUCCESS == SqlStmt_NextRow(stmt); ++i )
+		memcpy(&p->skillcount[i], &tmp_skillcount, sizeof(tmp_skillcount));
+
+	/* BG Skill Usage */
+	if( SQL_ERROR == SqlStmt_Prepare(stmt, "SELECT `id`, `count` FROM `rank_bg_skill_count` WHERE `char_id` = ? LIMIT %d", MAX_SKILL_TREE)
+	||	SQL_ERROR == SqlStmt_BindParam(stmt, 0, SQLDT_INT, &char_id, 0)
+	||	SQL_ERROR == SqlStmt_Execute(stmt)
+	||	SQL_ERROR == SqlStmt_BindColumn(stmt, 0, SQLDT_USHORT, &tmp_skillcount.id, 0, NULL, NULL)
+	||	SQL_ERROR == SqlStmt_BindColumn(stmt, 1, SQLDT_USHORT, &tmp_skillcount.count, 0, NULL, NULL) )
+		SqlStmt_ShowDebug(stmt);
+
+	for( i = 0; i < MAX_SKILL_TREE && SQL_SUCCESS == SqlStmt_NextRow(stmt); ++i )
+		memcpy(&p->bg_skillcount[i], &tmp_skillcount, sizeof(tmp_skillcount));
+	StringBuf_AppendStr(&msg_buf, " skillcount");
+
 	/* Mercenary Owner DataBase */
 	mercenary_owner_fromsql(char_id, p);
 	StringBuf_AppendStr(&msg_buf, " mercenary");
@@ -1650,6 +1965,16 @@ enum e_char_del_response char_delete(struct char_session_data* sd, uint32 char_i
 	/* remove mercenary data */
 	mercenary_owner_delete(char_id);
 
+	/* Char Ranking */
+	if( SQL_ERROR == Sql_Query(sql_handle, "DELETE FROM `rank_bg` WHERE `char_id` = '%d'", char_id) )
+		Sql_ShowDebug(sql_handle);
+	if( SQL_ERROR == Sql_Query(sql_handle, "DELETE FROM `rank_bg_log` WHERE `killer_id` = '%d' OR `killed_id` = '%d'", char_id, char_id) )
+		Sql_ShowDebug(sql_handle);
+	if( SQL_ERROR == Sql_Query(sql_handle, "DELETE FROM `rank_woe` WHERE `char_id` = '%d'", char_id) )
+		Sql_ShowDebug(sql_handle);
+	if( SQL_ERROR == Sql_Query(sql_handle, "DELETE FROM `rank_woe_log` WHERE `killer_id` = '%d' OR `killed_id` = '%d'", char_id, char_id) )
+		Sql_ShowDebug(sql_handle);
+	
 	/* delete char's friends list */
 	if( SQL_ERROR == Sql_Query(sql_handle, "DELETE FROM `%s` WHERE `char_id` = '%d'", schema_config.friend_db, char_id) )
 		Sql_ShowDebug(sql_handle);
@@ -2016,6 +2341,7 @@ void char_read_fame_list(void)
 	memset(smith_fame_list, 0, sizeof(smith_fame_list));
 	memset(chemist_fame_list, 0, sizeof(chemist_fame_list));
 	memset(taekwon_fame_list, 0, sizeof(taekwon_fame_list));
+	memset(bg_fame_list, 0, sizeof(bg_fame_list));
 	// Build Blacksmith ranking list
 	if( SQL_ERROR == Sql_Query(sql_handle, "SELECT `char_id`,`fame`,`name` FROM `%s` WHERE `fame`>0 AND (`class`='%d' OR `class`='%d' OR `class`='%d' OR `class`='%d' OR `class`='%d' OR `class`='%d') ORDER BY `fame` DESC LIMIT 0,%d", schema_config.char_db, JOB_BLACKSMITH, JOB_WHITESMITH, JOB_BABY_BLACKSMITH, JOB_MECHANIC, JOB_MECHANIC_T, JOB_BABY_MECHANIC, fame_list_size_smith) )
 		Sql_ShowDebug(sql_handle);
@@ -2061,6 +2387,18 @@ void char_read_fame_list(void)
 		Sql_GetData(sql_handle, 2, &data, &len);
 		memcpy(taekwon_fame_list[i].name, data, zmin(len, NAME_LENGTH));
 	}
+	// Build BG Normal ranking list [Zephyrus]
+	if( SQL_ERROR == Sql_Query(sql_handle, "SELECT `rank_bg`.`char_id`, `rank_bg`.`points`, `%s`.`name` FROM `rank_bg` LEFT JOIN `%s` ON `%s`.`char_id` = `rank_bg`.`char_id` WHERE `rank_bg`.`points` > '0' ORDER BY `rank_bg`.`points` DESC LIMIT 0,%d", schema_config.char_db, schema_config.char_db, schema_config.char_db, fame_list_size_bg) )
+		Sql_ShowDebug(sql_handle);
+	for( i = 0; i < fame_list_size_bg && SQL_SUCCESS == Sql_NextRow(sql_handle); ++i )
+	{
+		Sql_GetData(sql_handle, 0, &data, NULL); 
+		bg_fame_list[i].id = atoi(data);
+		Sql_GetData(sql_handle, 1, &data, &len); 
+		bg_fame_list[i].fame = atoi(data);
+		Sql_GetData(sql_handle, 2, &data, &len); 
+		memcpy(bg_fame_list[i].name, data, zmin(len, NAME_LENGTH));
+	}
 	Sql_FreeResult(sql_handle);
 }
 
@@ -2789,6 +3127,11 @@ void char_set_defaults(){
 	charserv_config.mail_return_days = 14;
 	charserv_config.mail_delete_days = 14;
 	charserv_config.mail_retrieve = 1;
+	
+	for( int i = 0; i < 3; i++ )
+	{
+		charserv_config.bg_regular_rewards[i] = 0;
+	}
 
 #if defined(RENEWAL) && PACKETVER >= 20151001
 	charserv_config.allowed_job_flag = 3;
@@ -3034,6 +3377,12 @@ bool char_config_read(const char* cfgName, bool normal){
 				ShowWarning("Max fame list size is %d (fame_list_taekwon)\n", MAX_FAME_LIST);
 				fame_list_size_taekwon = MAX_FAME_LIST;
 			}
+		} else if (strcmpi(w1, "bg_regular_rewards") == 0 ) {
+			int i;
+			memset(charserv_config.bg_regular_rewards, 0, sizeof(charserv_config.bg_regular_rewards));
+			sscanf(w2, "%d,%d,%d", &charserv_config.bg_regular_rewards[0], &charserv_config.bg_regular_rewards[1], &charserv_config.bg_regular_rewards[2]);
+			for( i = 0; i < 3; i++ )
+				if( charserv_config.bg_regular_rewards[i] < 0 ) charserv_config.bg_regular_rewards[i] = 0;
 		} else if (strcmpi(w1, "guild_exp_rate") == 0) {
 			charserv_config.guild_exp_rate = atoi(w2);
 		} else if (strcmpi(w1, "pincode_enabled") == 0) {
diff --git a/src/char/char.hpp b/src/char/char.hpp
index 437095d60..9fd170df4 100644
--- a/src/char/char.hpp
+++ b/src/char/char.hpp
@@ -180,7 +180,8 @@ struct CharServ_Config {
 	int autosave_interval;
 	int start_zeny;
 	int guild_exp_rate;
-
+	int bg_regular_rewards[3];
+	
 	char default_map[MAP_NAME_LENGTH];
 	unsigned short default_map_x;
 	unsigned short default_map_y;
@@ -264,10 +265,14 @@ DBMap* char_get_chardb(); // uint32 char_id -> struct mmo_charstatus*
 extern int fame_list_size_chemist;
 extern int fame_list_size_smith;
 extern int fame_list_size_taekwon;
+// BG extended
+extern int fame_list_size_bg;
 // Char-server-side stored fame lists [DracoRPG]
 extern struct fame_list smith_fame_list[MAX_FAME_LIST];
 extern struct fame_list chemist_fame_list[MAX_FAME_LIST];
 extern struct fame_list taekwon_fame_list[MAX_FAME_LIST];
+// BG extended
+extern struct fame_list bg_fame_list[MAX_FAME_LIST];
 
 #define DEFAULT_AUTOSAVE_INTERVAL 300*1000
 #define MAX_CHAR_BUF 150 //Max size (for WFIFOHEAD calls)
@@ -295,6 +300,8 @@ int char_divorce_char_sql(int partner_id1, int partner_id2);
 int char_memitemdata_to_sql(const struct item items[], int max, int id, enum storage_type tableswitch, uint8 stor_id);
 bool char_memitemdata_from_sql(struct s_storage* p, int max, int id, enum storage_type tableswitch, uint8 stor_id);
 
+int char_ranking_reset(int type);
+
 int char_married(int pl1,int pl2);
 int char_child(int parent_id, int child_id);
 int char_family(int pl1,int pl2,int pl3);
diff --git a/src/char/char_mapif.cpp b/src/char/char_mapif.cpp
index ef635e9b6..9bc68e8ba 100644
--- a/src/char/char_mapif.cpp
+++ b/src/char/char_mapif.cpp
@@ -86,8 +86,6 @@ int chmapif_send(int fd, unsigned char *buf, unsigned int len){
 	return 0;
 }
 
-
-
 /**
  * Send map-servers fames ranking lists
  *  Defaut fame list are 32B, (id+point+names)
@@ -1093,57 +1091,57 @@ int chmapif_parse_updmapip(int fd, int id){
  * @return : 0 not enough data received, 1 success
  */
 int chmapif_parse_updfamelist(int fd){
-    if (RFIFOREST(fd) < 11)
-        return 0;
-    {
-            int cid = RFIFOL(fd, 2);
-            int fame = RFIFOL(fd, 6);
-            char type = RFIFOB(fd, 10);
-            int size;
-            struct fame_list* list;
-            int player_pos;
-            int fame_pos;
-
-            switch(type)
-            {
-				case RANK_BLACKSMITH:	size = fame_list_size_smith;	list = smith_fame_list;		break;
-				case RANK_ALCHEMIST:	size = fame_list_size_chemist;	list = chemist_fame_list;	break;
-				case RANK_TAEKWON:		size = fame_list_size_taekwon;	list = taekwon_fame_list;	break;
-				default:				size = 0;						list = NULL;				break;
-            }
-
-            ARR_FIND(0, size, player_pos, list[player_pos].id == cid);// position of the player
-            ARR_FIND(0, size, fame_pos, list[fame_pos].fame <= fame);// where the player should be
-
-            if( player_pos == size && fame_pos == size )
-                    ;// not on list and not enough fame to get on it
-            else if( fame_pos == player_pos )
-            {// same position
-                    list[player_pos].fame = fame;
-                    chmapif_update_fame_list(type, player_pos, fame);
-            }
-            else
-            {// move in the list
-                    if( player_pos == size )
-                    {// new ranker - not in the list
-                            ARR_MOVE(size - 1, fame_pos, list, struct fame_list);
-                            list[fame_pos].id = cid;
-                            list[fame_pos].fame = fame;
-                            char_loadName(cid, list[fame_pos].name);
-                    }
-                    else
-                    {// already in the list
-                            if( fame_pos == size )
-                                    --fame_pos;// move to the end of the list
-                            ARR_MOVE(player_pos, fame_pos, list, struct fame_list);
-                            list[fame_pos].fame = fame;
-                    }
-                    chmapif_send_fame_list(-1);
-            }
-
-            RFIFOSKIP(fd,11);
-    }
-    return 1;
+	if (RFIFOREST(fd) < 11)
+		return 0;
+	{
+		int cid = RFIFOL(fd, 2);
+		int fame = RFIFOL(fd, 6);
+		char type = RFIFOB(fd, 10);
+		int size;
+		struct fame_list* list;
+		int player_pos;
+		int fame_pos;
+
+		switch (type)
+		{
+		case RANK_BLACKSMITH:	size = fame_list_size_smith;	list = smith_fame_list;		break;
+		case RANK_ALCHEMIST:	size = fame_list_size_chemist;	list = chemist_fame_list;	break;
+		case RANK_TAEKWON:		size = fame_list_size_taekwon;	list = taekwon_fame_list;	break;
+		default:				size = 0;						list = NULL;				break;
+		}
+
+		ARR_FIND(0, size, player_pos, list[player_pos].id == cid);// position of the player
+		ARR_FIND(0, size, fame_pos, list[fame_pos].fame <= fame);// where the player should be
+
+		if (player_pos == size && fame_pos == size)
+			;// not on list and not enough fame to get on it
+		else if (fame_pos == player_pos)
+		{// same position
+			list[player_pos].fame = fame;
+			chmapif_update_fame_list(type, player_pos, fame);
+		}
+		else
+		{// move in the list
+			if (player_pos == size)
+			{// new ranker - not in the list
+				ARR_MOVE(size - 1, fame_pos, list, struct fame_list);
+				list[fame_pos].id = cid;
+				list[fame_pos].fame = fame;
+				char_loadName(cid, list[fame_pos].name);
+			}
+			else
+			{// already in the list
+				if (fame_pos == size)
+					--fame_pos;// move to the end of the list
+				ARR_MOVE(player_pos, fame_pos, list, struct fame_list);
+				list[fame_pos].fame = fame;
+			}
+			chmapif_send_fame_list(-1);
+		}
+
+		RFIFOSKIP(fd, 11);
+	}
+	return 1;
 }
 
 /*
diff --git a/src/char/char_mapif.hpp b/src/char/char_mapif.hpp
index 2bfb1a69e..e03f691f8 100644
--- a/src/char/char_mapif.hpp
+++ b/src/char/char_mapif.hpp
@@ -10,6 +10,7 @@ int chmapif_sendall(unsigned char *buf, unsigned int len);
 int chmapif_sendallwos(int sfd, unsigned char *buf, unsigned int len);
 int chmapif_send(int fd, unsigned char *buf, unsigned int len);
 int chmapif_send_fame_list(int fd);
+
 void chmapif_update_fame_list(int type, int index, int fame);
 void chmapif_sendall_playercount(int users);
 int chmapif_parse_getmapname(int fd, int id);
diff --git a/src/char/int_guild.cpp b/src/char/int_guild.cpp
index fa1ad1edd..c387f3a6f 100644
--- a/src/char/int_guild.cpp
+++ b/src/char/int_guild.cpp
@@ -229,6 +229,29 @@ int inter_guild_tosql(struct guild *g,int flag)
 			Sql_ShowDebug(sql_handle);
 		StringBuf_Destroy(&buf);
 	}
+	
+	if( flag&GS_RANKING )
+	{
+		strcat(t_info, " ranking");
+		for( i = 0; i < RANK_CASTLES; i++ )
+		{
+			if( g->castle[i].changed )
+			{
+				if( SQL_ERROR == Sql_Query(sql_handle, "REPLACE INTO `rank_guild` (`guild_id`, `castle_id`, "
+					"`capture`, `emperium`, `treasure`, `top_eco`, `top_def`, `invest_eco`, `invest_def`, `offensive_score`, `defensive_score`, "
+					"`posesion_time`, `zeny_eco`, `zeny_def`, `skill_battleorder`, `skill_regeneration`, `skill_restore`, `skill_emergencycall`, "
+					"`off_kill`, `off_death`, `def_kill`, `def_death`, `ext_kill`, `ext_death`, `ali_kill`, `ali_death`) "
+					"VALUES ('%d', '%d', '%d', '%d', '%d', '%d', '%d', '%d', '%d', '%d', '%d', '%u', '%u', '%u', '%d', '%d', '%d', '%d', '%d', '%d', '%d', '%d', '%d', '%d', '%d', '%d')",
+					g->guild_id, i,
+					g->castle[i].capture, g->castle[i].emperium, g->castle[i].treasure, g->castle[i].top_eco, g->castle[i].top_def, g->castle[i].invest_eco, g->castle[i].invest_def, g->castle[i].offensive_score, g->castle[i].defensive_score,
+					g->castle[i].posesion_time, g->castle[i].zeny_eco, g->castle[i].zeny_def, g->castle[i].skill_battleorder, g->castle[i].skill_regeneration, g->castle[i].skill_restore, g->castle[i].skill_emergencycall,
+					g->castle[i].off.kill_count, g->castle[i].off.death_count, g->castle[i].def.kill_count, g->castle[i].def.death_count, g->castle[i].ext.kill_count, g->castle[i].ext.death_count, g->castle[i].ali.kill_count, g->castle[i].ali.death_count) )
+					Sql_ShowDebug(sql_handle);
+
+				g->castle[i].changed = false;
+			}
+		}
+	}
 
 	if (flag&GS_MEMBER)
 	{
@@ -407,6 +430,67 @@ struct guild * inter_guild_fromsql(int guild_id)
 			*p |= *data - 'A' + 10;
 		++data;
 	}
+	
+	/* Guild Ranking */
+	for( i = 0; i < RANK_CASTLES; i++ )
+		g->castle[i].changed = true;
+	
+	if( SQL_ERROR == Sql_Query(sql_handle,
+		"SELECT "
+		"`castle_id`, `capture`, `emperium`, `treasure`, `top_eco`, `top_def`, `invest_eco`, `invest_def`, `offensive_score`, `defensive_score`, "
+		"`posesion_time`, `zeny_eco`, `zeny_def`, `skill_battleorder`, `skill_regeneration`, `skill_restore`, `skill_emergencycall`, "
+		"`off_kill`, `off_death`, `def_kill`, `def_death`, `ext_kill`, `ext_death`, `ali_kill`, `ali_death` "
+		"FROM `rank_guild` WHERE `guild_id` = '%d'", g->guild_id) )
+		Sql_ShowDebug(sql_handle);
+	else
+	{
+		while( SQL_SUCCESS == Sql_NextRow(sql_handle) )
+		{
+			Sql_GetData(sql_handle, 0, &data, NULL); i = atoi(data);
+			if( i >= RANK_CASTLES || i < 0 )
+				continue;
+
+			Sql_GetData(sql_handle, 1, &data, NULL); g->castle[i].capture = atoi(data);
+			Sql_GetData(sql_handle, 2, &data, NULL); g->castle[i].emperium = atoi(data);
+			Sql_GetData(sql_handle, 3, &data, NULL); g->castle[i].treasure = atoi(data);
+			Sql_GetData(sql_handle, 4, &data, NULL); g->castle[i].top_eco = atoi(data);
+			Sql_GetData(sql_handle, 5, &data, NULL); g->castle[i].top_def = atoi(data);
+			Sql_GetData(sql_handle, 6, &data, NULL); g->castle[i].invest_eco = atoi(data);
+			Sql_GetData(sql_handle, 7, &data, NULL); g->castle[i].invest_def = atoi(data);
+			Sql_GetData(sql_handle, 8, &data, NULL); g->castle[i].offensive_score = atoi(data);
+			Sql_GetData(sql_handle, 9, &data, NULL); g->castle[i].defensive_score = atoi(data);
+
+			Sql_GetData(sql_handle,10, &data, NULL); g->castle[i].posesion_time = strtoul(data, NULL, 0);
+			Sql_GetData(sql_handle,11, &data, NULL); g->castle[i].zeny_eco = strtoul(data, NULL, 0);
+			Sql_GetData(sql_handle,12, &data, NULL); g->castle[i].zeny_def = strtoul(data, NULL, 0);
+
+			Sql_GetData(sql_handle,13, &data, NULL); g->castle[i].skill_battleorder = atoi(data);
+			Sql_GetData(sql_handle,14, &data, NULL); g->castle[i].skill_regeneration = atoi(data);
+			Sql_GetData(sql_handle,15, &data, NULL); g->castle[i].skill_restore = atoi(data);
+			Sql_GetData(sql_handle,16, &data, NULL); g->castle[i].skill_emergencycall = atoi(data);
+
+			Sql_GetData(sql_handle,17, &data, NULL); g->castle[i].off.kill_count = atoi(data);
+			Sql_GetData(sql_handle,18, &data, NULL); g->castle[i].off.death_count = atoi(data);
+			Sql_GetData(sql_handle,19, &data, NULL); g->castle[i].def.kill_count = atoi(data);
+			Sql_GetData(sql_handle,20, &data, NULL); g->castle[i].def.death_count = atoi(data);
+			Sql_GetData(sql_handle,21, &data, NULL); g->castle[i].ext.kill_count = atoi(data);
+			Sql_GetData(sql_handle,22, &data, NULL); g->castle[i].ext.death_count = atoi(data);
+			Sql_GetData(sql_handle,23, &data, NULL); g->castle[i].ali.kill_count = atoi(data);
+			Sql_GetData(sql_handle,24, &data, NULL); g->castle[i].ali.death_count = atoi(data);
+
+			g->castle[i].changed = false;
+		}
+	}
+
+	for( i = 0; i < RANK_CASTLES; i++ )
+	{
+		if( i >= RANK_CASTLES || !g->castle[i].changed )
+			continue;
+
+		g->castle[i].offensive_score = 2000;
+		g->save_flag |= GS_RANKING;
+	}
+
 
 	// load guild member info
 	if( SQL_ERROR == Sql_Query(sql_handle, "SELECT `c`.`account_id`,`m`.`char_id`,`c`.`hair`,`c`.`hair_color`,`c`.`sex`,`c`.`class`,`c`.`base_level`,`m`.`exp`,`c`.`online`,`m`.`position`,`c`.`name`,coalesce(UNIX_TIMESTAMP(`c`.`last_login`),0) "
@@ -1145,6 +1229,17 @@ int mapif_guild_notice(struct guild *g)
 	return 0;
 }
 
+// [Zephyrus] Guild Rank
+int mapif_Guild_Save_Score(int guild_id, int index)
+{
+	unsigned char buf[8];
+	WBUFW(buf,0) = 0x3844;
+	WBUFL(buf,2) = guild_id;
+	WBUFW(buf,6) = index;
+	chmapif_sendall(buf,8);
+	return 0;
+}
+
 // Send emblem data
 int mapif_guild_emblem(struct guild *g)
 {
@@ -1255,6 +1350,12 @@ int mapif_parse_CreateGuild(int fd,uint32 account_id,char *name,struct guild_mem
 	g->average_lv=master->lv;
 	g->connect_member=1;
 
+	for( i = 0; i < RANK_CASTLES; i++ )
+	{
+		g->castle[i].offensive_score = 2000;
+		g->castle[i].changed = true;
+	}
+
 	for(i=0;i<MAX_GUILDSKILL;i++)
 		g->skill[i].id=i + GD_SKILLBASE;
 	g->guild_id= -1; //Request to create guild.
@@ -1944,6 +2045,19 @@ int mapif_parse_GuildEmblemVersion(int fd, int guild_id, int version)
 // Must Return
 //	1 : ok
 //  0 : error
+int mapif_parse_Guild_Save_Score(int fd, int guild_id, int index, struct guild_rank_data *grd)
+{
+	struct guild *g;
+	if( index < 0 || index >= RANK_CASTLES )
+		return 0;
+	if( (g = inter_guild_fromsql(guild_id)) == NULL )
+		return 0;
+	memcpy(&g->castle[index], grd, sizeof(struct guild_rank_data));
+	g->save_flag |= GS_RANKING;
+
+	return mapif_Guild_Save_Score(guild_id, index);
+}
+
 int inter_guild_parse_frommap(int fd)
 {
 	RFIFOHEAD(fd);
@@ -1966,6 +2080,7 @@ int inter_guild_parse_frommap(int fd)
 	case 0x3040: mapif_parse_GuildCastleDataLoad(fd,RFIFOW(fd,2),(int *)RFIFOP(fd,4)); break;
 	case 0x3041: mapif_parse_GuildCastleDataSave(fd,RFIFOW(fd,2),RFIFOB(fd,4),RFIFOL(fd,5)); break;
 	case 0x3042: mapif_parse_GuildEmblemVersion(fd, RFIFOL(fd, 2), RFIFOL(fd, 6)); break;
+	case 0x3043: mapif_parse_Guild_Save_Score(fd,RFIFOL(fd,4),RFIFOW(fd,8),(struct guild_rank_data *)RFIFOP(fd,10)); break;
 
 	default:
 		return 0;
diff --git a/src/char/int_guild.hpp b/src/char/int_guild.hpp
index bc2198ec0..cee3ebccf 100644
--- a/src/char/int_guild.hpp
+++ b/src/char/int_guild.hpp
@@ -20,6 +20,7 @@ enum e_guild_action : uint32 {
 	GS_LEVEL = 0x0100,
 	GS_MES = 0x0200,
 	GS_MASK = 0x03FF,
+	GS_RANKING = 0x0400,
 	GS_BASIC_MASK = (GS_BASIC | GS_EMBLEM | GS_CONNECT | GS_LEVEL | GS_MES),
 	GS_REMOVE = 0x8000,
 };
diff --git a/src/char/inter.cpp b/src/char/inter.cpp
index a87f8a43c..f8ed91c98 100644
--- a/src/char/inter.cpp
+++ b/src/char/inter.cpp
@@ -58,7 +58,7 @@ int inter_recv_packet_length[] = {
 	 6,-1, 0, 0,  0, 0, 0, 0, 10,-1, 0, 0,  0, 0,  0, 0,	// 3010-
 	-1,10,-1,14, 15+NAME_LENGTH,19, 6,-1, 14,14, 6, 0,  0, 0,  0, 0,	// 3020- Party
 	-1, 6,-1,-1, 55,19, 6,-1, 14,-1,-1,-1, 18,19,186,-1,	// 3030-
-	-1, 9,10, 0,  0, 0, 0, 0,  8, 6,11,10, 10,-1,6+NAME_LENGTH, 0,	// 3040-
+	-1, 9, 10, -1, 0, 0, 0, 0,  8, 6,11,10, 10,-1,6+NAME_LENGTH, 0,	// 3040-  [BG] 0x3043 Guild Rank
 	-1,-1,10,10,  0,-1,12, 0,  0, 0, 0, 0,  0, 0,  0, 0,	// 3050-  Auction System [Zephyrus]
 	 6,-1, 6,-1, 16+NAME_LENGTH+ACHIEVEMENT_NAME_LENGTH, 0, 0, 0,  0, 0, 0, 0,  0, 0,  0, 0,	// 3060-  Quest system [Kevin] [Inkfish] / Achievements [Aleos]
 	-1,10, 6,-1,  0, 0, 0, 0,  0, 0, 0, 0, -1,10,  6,-1,	// 3070-  Mercenary packets [Zephyrus], Elemental packets [pakpil]
diff --git a/src/common/mmo.hpp b/src/common/mmo.hpp
index dd5fdf2a3..b104c7ad2 100644
--- a/src/common/mmo.hpp
+++ b/src/common/mmo.hpp
@@ -67,6 +67,9 @@ typedef uint32 t_itemid;
 #define DEFAULT_WALK_SPEED 150 ///Default walk speed
 #define MIN_WALK_SPEED 20 ///Min walk speed
 #define MAX_WALK_SPEED 1000 ///Max walk speed
+//Update this max as necessary. 55 is the value needed for Super Baby currently
+//Raised to 105 since Expanded Super Baby needs it.
+#define MAX_SKILL_TREE 105
 #define MAX_STORAGE 600 ///Max number of storage slots a player can have
 #define MAX_GUILD_STORAGE 600 ///Max number of storage slots a guild
 #define MAX_PARTY 12 ///Max party member
@@ -510,6 +513,128 @@ struct hotkey {
 };
 #endif
 
+struct s_battleground_stats {
+	unsigned int
+		top_damage,
+		damage_done,
+		damage_received;
+	unsigned short
+		// Capture The Flag
+		ctf_taken,
+		ctf_captured,
+		ctf_droped,
+		ctf_wins, ctf_lost, ctf_tie,
+		// Team Death Match
+		tdm_kills,
+		tdm_deaths,
+		tdm_wins, tdm_lost, tdm_tie,
+		// Eye of Storm
+		eos_flags,
+		eos_bases,
+		eos_wins, eos_lost, eos_tie,
+		// Conquest
+		emperium_kill,
+		barricade_kill,
+		gstone_kill,
+		cq_wins, cq_lost,
+		// KVM
+		kvm_kills,
+		kvm_deaths,
+		kvm_wins, kvm_lost, kvm_tie,
+		// Stone Control
+		sc_stole,
+		sc_captured,
+		sc_droped,
+		sc_wins, sc_lost, sc_tie,
+		// Domination
+		dom_bases,
+		dom_off_kills,
+		dom_def_kills,
+		dom_wins, dom_lost, dom_tie,
+		// Rush
+		ru_captures,
+		ru_wins, ru_lost,
+		// Poring Ball
+		pb_kills, pb_deaths, pb_kill_surface, pb_death_surface,
+		pb_scored, pb_score_penalty, pb_score_own,
+		pb_penalty, pb_sixyard,
+		pb_wins, pb_lost, pb_tie,
+		// Touch Down
+		td_taken,
+		td_scored,
+		td_kills, td_kill_fumbi, td_kill_wfumbi,
+		td_deaths, td_death_fumbi, td_death_wfumbi,
+		td_wins, td_lost, td_tie;
+
+	unsigned int // Ammo
+		sp_heal_potions,
+		hp_heal_potions,
+		yellow_gemstones,
+		red_gemstones,
+		blue_gemstones,
+		poison_bottles,
+		acid_demostration,
+		acid_demostration_fail,
+		support_skills_used,
+		healing_done,
+		wrong_support_skills_used,
+		wrong_healing_done,
+		sp_used,
+		zeny_used,
+		spiritb_used,
+		ammo_used;
+	unsigned short
+		kill_count,
+		death_count,
+		win, lost, tie,
+		leader_win, leader_lost, leader_tie,
+		deserter;
+
+	int score, points;
+};
+
+struct s_woestats {
+	int score;
+	unsigned short
+		kill_count,
+		death_count;
+	unsigned int
+		top_damage,
+		damage_done,
+		damage_received;
+	unsigned int
+		emperium_damage,
+		guardian_damage,
+		barricade_damage,
+		gstone_damage;
+	unsigned short
+		emperium_kill,
+		guardian_kill,
+		barricade_kill,
+		gstone_kill;
+	unsigned int // Ammo
+		sp_heal_potions,
+		hp_heal_potions,
+		yellow_gemstones,
+		red_gemstones,
+		blue_gemstones,
+		poison_bottles,
+		acid_demostration,
+		acid_demostration_fail,
+		support_skills_used,
+		healing_done,
+		wrong_support_skills_used,
+		wrong_healing_done,
+		sp_used,
+		zeny_used,
+		spiritb_used,
+		ammo_used;
+};
+
+struct s_skillcount {
+	unsigned short id,count;
+};
+
 struct mmo_charstatus {
 	uint32 char_id;
 	uint32 account_id;
@@ -549,6 +674,12 @@ struct mmo_charstatus {
 	uint32 mapip;
 	uint16 mapport;
 
+	// Ranking Data
+	struct s_battleground_stats bgstats;
+	struct s_skillcount bg_skillcount[MAX_SKILL_TREE]; // BG Limited
+	struct s_woestats wstats;
+	struct s_skillcount skillcount[MAX_SKILL_TREE]; // WoE Limited
+	
 	struct point last_point,save_point,memo_point[MAX_MEMOPOINTS];
 	struct s_skill skill[MAX_SKILL];
 
@@ -692,6 +823,35 @@ struct guild_expulsion {
 struct guild_skill {
 	int id,lv;
 };
+ 
+#define RANK_CASTLES 34
+struct guild_rank_data {
+	unsigned short
+		capture, // Number of times you have captured this castle
+		emperium, // Number of times you have break an emperium on this castle
+		treasure, // Number of opened treasures
+		top_eco, // Max economy reach on this castle
+		top_def, // Max defense reach on this castle
+		invest_eco, // Total of Economy points
+		invest_def, // Total of Defense points
+		offensive_score,
+		defensive_score;
+	unsigned int
+		posesion_time,
+		zeny_eco,
+		zeny_def;
+	unsigned short
+		skill_battleorder,
+		skill_regeneration,
+		skill_restore,
+		skill_emergencycall;
+	struct {
+		unsigned int
+			kill_count,
+			death_count;
+	} off, def, ext, ali;
+	bool changed;
+};
 
 struct Channel;
 struct guild {
@@ -700,6 +860,7 @@ struct guild {
 	t_exp exp;
 	t_exp next_exp;
 	int skill_point;
+	struct guild_rank_data castle[RANK_CASTLES];
 	char name[NAME_LENGTH],master[NAME_LENGTH];
 	struct guild_member member[MAX_GUILD];
 	struct guild_position position[MAX_GUILDPOSITION];
@@ -733,6 +894,7 @@ struct guild_castle {
 	int payTime;
 	int createTime;
 	int visibleC;
+	time_t capture_tick; // [WoE Ranking] 
 	struct {
 		unsigned visible : 1;
 		int id; // object id
@@ -1042,7 +1204,8 @@ enum e_rank {
 	RANK_BLACKSMITH = 0,
 	RANK_ALCHEMIST = 1,
 	RANK_TAEKWON = 2,
-	RANK_KILLER = 3
+	RANK_KILLER = 3,
+	RANK_BG = 4
 };
 
 struct clan_alliance {
diff --git a/src/common/utils.hpp b/src/common/utils.hpp
index 5fedcf013..778657ab7 100644
--- a/src/common/utils.hpp
+++ b/src/common/utils.hpp
@@ -25,6 +25,24 @@ bool exists(const char* filename);
 /// Apply rate for val, divided by per
 #define apply_rate2(val, rate, per) (((rate) == (per)) ? (val) : ((val) > 100000) ? ((val) / (per) * (rate)) : ((val) * (rate) / (per)))
 
+#define add2limit(a, b, max) \
+	do { \
+		if( (max - a) < b ) { \
+			a = max; \
+		} else { \
+			a += b; \
+		} \
+	} while(0)
+
+#define sub2limit(a, b, min) \
+	do { \
+		if( (b + min) > a ) { \
+			a = min; \
+		} else { \
+			a -= b; \
+		} \
+	} while(0)
+	
 /// calculates the value of A / B, in percent (rounded down)
 unsigned int get_percentage(const unsigned int A, const unsigned int B);
 uint32 get_percentage_exp(const uint64 a, const uint64 b);
diff --git a/src/custom/script.inc b/src/custom/script.inc
index 4692607b6..c990c93ac 100644
--- a/src/custom/script.inc
+++ b/src/custom/script.inc
@@ -704,7 +704,7 @@ BUILDIN_FUNC(bg_reward)
 	add_value = script_getnum(st,8);
 	bg_arena = script_getnum(st,9);
 
-	bg_team_rewards(team_id, nameid, amount, kafrapoints, quest_id, var, add_value, bg_arena);
+	bg_team_rewards(team_id, nameid, amount, kafrapoints, quest_id, var, add_value, bg_arena, 0);
 	return SCRIPT_CMD_SUCCESS;
 }
 
@@ -863,3 +863,216 @@ BUILDIN_FUNC(bg_premature_end)
 
 	return SCRIPT_CMD_SUCCESS;
 }
+
+/*==========================================
+ * Ranking Reset
+ *------------------------------------------*/
+BUILDIN_FUNC(bg_rankpoints)
+{
+	struct map_session_data *sd;
+	std::shared_ptr<s_battleground_data> bg;
+	const char *type;
+	int i, add_value;
+
+	if( script_hasdata(st,4) )
+		sd = map_id2sd(script_getnum(st,4));
+	else
+		script_rid2sd(sd);
+
+	if( sd == NULL )
+		return 0;
+
+	if( !sd->bg_id || !(bg = util::umap_find(bg_team_db, sd->bg_id)) )
+		return 0;
+	ARR_FIND(0,MAX_BG_MEMBERS,i,bg->members[i].sd == sd);
+	if( i >= MAX_BG_MEMBERS )
+		return 0;
+
+	type = script_getstr(st,2);
+	add_value = script_getnum(st,3);
+
+	// Just +1 Fame Point
+	if( !strcmpi(type,"fame") )
+		pc_addfame(sd,add_value,3);
+	// Normal Ranking actions
+	else if( !strcmpi(type,"eos_flags") )
+	{
+		add2limit(sd->status.bgstats.eos_flags,add_value,USHRT_MAX);
+		pc_addfame(sd,5,3);
+	}
+	else if( !strcmpi(type,"sc_stole") )
+	{
+		add2limit(sd->status.bgstats.sc_stole,add_value,USHRT_MAX);
+		pc_addfame(sd,1,3);
+	}
+	else if( !strcmpi(type,"sc_captured") )
+	{
+		add2limit(sd->status.bgstats.sc_captured,add_value,USHRT_MAX);
+		pc_addfame(sd,5,3);
+	}
+	else if( !strcmpi(type,"sc_droped") )
+	{
+		add2limit(sd->status.bgstats.sc_droped,add_value,USHRT_MAX);
+	}
+	else if( !strcmpi(type,"ctf_taken") )
+	{
+		add2limit(sd->status.bgstats.ctf_taken,add_value,USHRT_MAX);
+		pc_addfame(sd,1,3);
+	}
+	else if( !strcmpi(type,"ctf_captured") )
+	{
+		add2limit(sd->status.bgstats.ctf_captured,add_value,USHRT_MAX);
+		pc_addfame(sd,25,3);
+	}
+	else if( !strcmpi(type,"ctf_droped") )
+	{
+		add2limit(sd->status.bgstats.ctf_droped,add_value,USHRT_MAX);
+	}
+	else if( !strcmpi(type,"dom_off_kills") )
+	{
+		add2limit(sd->status.bgstats.dom_off_kills,add_value,USHRT_MAX);
+	}
+	else if( !strcmpi(type,"dom_def_kills") )
+	{
+		add2limit(sd->status.bgstats.dom_def_kills,add_value,USHRT_MAX);
+	}
+	else if( !strcmpi(type,"pb_kills") )
+	{
+		add2limit(sd->status.bgstats.pb_kills,add_value,USHRT_MAX);
+		pc_addfame(sd,3,3);
+	}
+	else if( !strcmpi(type,"pb_kill_surface") )
+	{
+		add2limit(sd->status.bgstats.pb_kill_surface,add_value,USHRT_MAX);
+		pc_addfame(sd,15,3);
+	}
+	else if( !strcmpi(type,"pb_scored") )
+	{
+		add2limit(sd->status.bgstats.pb_scored,add_value,USHRT_MAX);
+		pc_addfame(sd,25,3);
+	}
+	else if( !strcmpi(type,"pb_score_own") )
+	{
+		add2limit(sd->status.bgstats.pb_score_own,add_value,USHRT_MAX);
+	}
+	else if( !strcmpi(type,"pb_score_penalty") )
+	{
+		add2limit(sd->status.bgstats.pb_score_penalty,add_value,USHRT_MAX);
+		pc_addfame(sd,20,3);
+	}
+	else if( !strcmpi(type,"pb_deaths") )
+	{
+		add2limit(sd->status.bgstats.pb_deaths,add_value,USHRT_MAX);
+	}
+	else if( !strcmpi(type,"pb_death_surface") )
+	{
+		add2limit(sd->status.bgstats.pb_death_surface,add_value,USHRT_MAX);
+	}
+	else if( !strcmpi(type,"td_death_wfumbi") )
+	{
+		add2limit(sd->status.bgstats.td_death_wfumbi,add_value,USHRT_MAX);
+	}
+	else if( !strcmpi(type,"td_death_fumbi") )
+	{
+		add2limit(sd->status.bgstats.td_death_fumbi,add_value,USHRT_MAX);
+	}
+	else if( !strcmpi(type,"td_deaths") )
+	{
+		add2limit(sd->status.bgstats.td_deaths,add_value,USHRT_MAX);
+	}
+	else if( !strcmpi(type,"td_scored") )
+	{
+		add2limit(sd->status.bgstats.td_scored,add_value,USHRT_MAX);
+		pc_addfame(sd,25,3);
+	}
+	else if( !strcmpi(type,"td_taken") )
+	{
+		add2limit(sd->status.bgstats.td_taken,add_value,USHRT_MAX);
+		pc_addfame(sd,1,3);
+	}
+	else if( !strcmpi(type,"td_kill_wfumbi") )
+	{
+		add2limit(sd->status.bgstats.td_kill_wfumbi,add_value,USHRT_MAX);
+		pc_addfame(sd,6,3);
+	}
+	else if( !strcmpi(type,"td_kill_fumbi") )
+	{
+		add2limit(sd->status.bgstats.td_kill_fumbi,add_value,USHRT_MAX);
+		pc_addfame(sd,5,3);
+	}
+	else if( !strcmpi(type,"td_kills") )
+	{
+		add2limit(sd->status.bgstats.td_kills,add_value,USHRT_MAX);
+		pc_addfame(sd,1,3);
+	}
+
+	return 0;
+}
+
+BUILDIN_FUNC(bg_rankpoints_area)
+{
+	const char *str, *type;
+	int m, x0, y0, x1, y1, bg_id;
+	int i = 0, add_value;
+	int type_val;
+	std::shared_ptr<s_battleground_data> bg;
+	struct map_session_data *sd;
+
+	bg_id = script_getnum(st,2);
+	str = script_getstr(st,3);
+
+	if( !(bg = util::umap_find(bg_team_db, bg_id)) || (m = map_mapname2mapid(str)) < 0 )
+	{
+		script_pushint(st,0);
+		return 0;
+	}
+
+	x0 = script_getnum(st,4);
+	y0 = script_getnum(st,5);
+	x1 = script_getnum(st,6);
+	y1 = script_getnum(st,7);
+	type = script_getstr(st,8);
+
+	if( !strcmpi(type,"eos_bases") )
+		type_val = 1;
+	else if( !strcmpi(type,"dom_bases") )
+		type_val = 2;
+	else if( !strcmpi(type,"pb_sixyard") )
+		type_val = 3;
+	else if( !strcmpi(type,"pb_penalty") )
+		type_val = 4;
+	else return 0; // Invalid Type
+
+	add_value = script_getnum(st,9);
+	
+	for (const auto& pl_sd : bg->members) {
+		sd = pl_sd.sd;
+
+		if( sd == NULL )
+			continue;
+		if( sd->bl.m != m || sd->bl.x < x0 || sd->bl.y < y0 || sd->bl.x > x1 || sd->bl.y > y1 )
+			continue;
+
+		switch( type_val )
+		{
+		case 1:
+			add2limit(sd->status.bgstats.eos_bases,add_value,USHRT_MAX);
+			pc_addfame(sd,10,3);
+			break;
+		case 2:
+			add2limit(sd->status.bgstats.dom_bases,add_value,USHRT_MAX);
+			pc_addfame(sd,10,3);
+			break;
+		case 3:
+			add2limit(sd->status.bgstats.pb_sixyard,add_value,USHRT_MAX);
+			pc_addfame(sd,10,3);
+			break;
+		case 4:
+			add2limit(sd->status.bgstats.pb_penalty,add_value,USHRT_MAX);
+			pc_addfame(sd,10,3);
+			break;
+		}
+	}
+
+	return 0;
+}
diff --git a/src/custom/script_def.inc b/src/custom/script_def.inc
index e2e5d6fc6..d7b435f84 100644
--- a/src/custom/script_def.inc
+++ b/src/custom/script_def.inc
@@ -38,3 +38,6 @@
 	BUILDIN_DEF(bg_modeselection, ""),
 	BUILDIN_DEF(bg_leavebg, "s"),
 	BUILDIN_DEF(bg_premature_end, "i"),
+
+	BUILDIN_DEF(bg_rankpoints,"si?"),
+	BUILDIN_DEF(bg_rankpoints_area,"isiiiisi"),
\ No newline at end of file
diff --git a/src/map/battle.cpp b/src/map/battle.cpp
index a3c5f0f11..58f9cf31a 100644
--- a/src/map/battle.cpp
+++ b/src/map/battle.cpp
@@ -2365,8 +2365,13 @@ void battle_consume_ammo(struct map_session_data*sd, int skill, int lv)
 	}
 
 	if (sd->equip_index[EQI_AMMO] >= 0) //Qty check should have been done in skill_check_condition
+	{
 		pc_delitem(sd,sd->equip_index[EQI_AMMO],qty,0,1,LOG_TYPE_CONSUME);
-
+		if( sd->status.guild_id && map_allowed_woe(sd->bl.m) )
+			add2limit(sd->status.wstats.ammo_used, qty, UINT_MAX);
+		else if( sd->bg_id && map_getmapflag(sd->bl.m, MF_BATTLEGROUND))
+			add2limit(sd->status.bgstats.ammo_used, qty, UINT_MAX);
+	}
 	sd->state.arrow_atk = 0;
 }
 
diff --git a/src/map/battleground.cpp b/src/map/battleground.cpp
index 549a6c675..aa6224f62 100644
--- a/src/map/battleground.cpp
+++ b/src/map/battleground.cpp
@@ -872,6 +872,8 @@ int bg_team_leave(struct map_session_data *sd, bool quit, bool deserter, int fla
 		if (deserter) {
 			std::shared_ptr<s_battleground_type> bg = battleground_db.find(bg_id);
 
+			sd->status.bgstats.deserter++;
+
 			if (bg)
 				sc_start(nullptr, &sd->bl, SC_ENTRY_QUEUE_NOTIFY_ADMISSION_TIME_OUT, 100, 1, static_cast<t_tick>(bg->deserter_time) * 1000); // Deserter timer
 		}
@@ -2130,16 +2132,16 @@ void bg_team_rewards_all(const char* bg_map, int team_id1, int team_id2, int nam
 		return;
 
 	if (bg_result == 1) {
-		bg_team_rewards(team_id1, nameid, bgdata->reward_winner + amount, 0, 0, bgdata->variable.c_str(), 1, bgdata->id);
-		bg_team_rewards(team_id2, nameid, bgdata->reward_looser + amount, 0, 0, bgdata->variable.c_str(), 1, bgdata->id);
+		bg_team_rewards(team_id1, nameid, bgdata->reward_winner + amount, 0, 0, bgdata->variable.c_str(), 1, bgdata->id, 0);
+		bg_team_rewards(team_id2, nameid, bgdata->reward_looser + amount, 0, 0, bgdata->variable.c_str(), 1, bgdata->id, 2);
 	}
 	else if (bg_result == 2) {
-		bg_team_rewards(team_id1, nameid, bgdata->reward_looser + amount, 0, 0, bgdata->variable.c_str(), 1, bgdata->id);
-		bg_team_rewards(team_id2, nameid, bgdata->reward_winner + amount, 0, 0, bgdata->variable.c_str(), 1, bgdata->id);
+		bg_team_rewards(team_id1, nameid, bgdata->reward_looser + amount, 0, 0, bgdata->variable.c_str(), 1, bgdata->id, 2);
+		bg_team_rewards(team_id2, nameid, bgdata->reward_winner + amount, 0, 0, bgdata->variable.c_str(), 1, bgdata->id, 0);
 	}
 	else {
-		bg_team_rewards(team_id1, nameid, bgdata->reward_draw + amount, 0, 0, bgdata->variable.c_str(), 1, bgdata->id);
-		bg_team_rewards(team_id2, nameid, bgdata->reward_draw + amount, 0, 0, bgdata->variable.c_str(), 1, bgdata->id);
+		bg_team_rewards(team_id1, nameid, bgdata->reward_draw + amount, 0, 0, bgdata->variable.c_str(), 1, bgdata->id, 1);
+		bg_team_rewards(team_id2, nameid, bgdata->reward_draw + amount, 0, 0, bgdata->variable.c_str(), 1, bgdata->id, 1);
 	}
 
 }
@@ -2147,17 +2149,17 @@ void bg_team_rewards_all(const char* bg_map, int team_id1, int team_id2, int nam
    bg_arena (0 EoS | 1 Boss | 2 TI | 3 CTF | 4 TD | 5 SC | 6 CON | 7 RUSH | 8 DOM)
    bg_result (0 Draw | 1 Team1 win | 2 Team2 win)
    ============================================================== */
-void bg_team_rewards(int bg_id, int nameid, int amount, int kafrapoints, int quest_id, const char *var, int add_value, int bg_arena)
+void bg_team_rewards(int bg_id, int nameid, int amount, int kafrapoints, int quest_id, const char *var, int add_value, int bg_arena, int bg_result)
 {
 	struct map_session_data *sd;
 	struct item_data *id;
 	struct item it;
-	int flag, get_amount, rank = 0;
+	int flag, get_amount, rank = 0, fame;
 
 	std::shared_ptr<s_battleground_data> bg = util::umap_find(bg_team_db, bg_id);
 	std::shared_ptr<s_battleground_type> bgdata = battleground_db.find(bg_arena);
 
-	if( amount < 1 || !bg || !bgdata || (id = itemdb_exists(nameid)) == NULL )
+	if( !bg || !bgdata || (id = itemdb_exists(nameid)) == NULL )
 		return;
 
 	if( battle_config.bg_reward_rates != 100 )
@@ -2207,6 +2209,75 @@ void bg_team_rewards(int bg_id, int nameid, int amount, int kafrapoints, int que
 					clif_additem(sd, 0, 0, flag);
 				}
 			}
+			
+			switch( bg_result ) {
+				
+				case 0: // Won
+					add2limit(sd->status.bgstats.win,1,USHRT_MAX);
+					fame = 100;
+					if( sd->bmaster_flag ) {
+						add2limit(sd->status.bgstats.leader_win,1,USHRT_MAX);
+						fame += 25;
+					}
+					pc_addfame(sd,fame,3);
+					switch( bg_arena )
+					{
+						case 0:	add2limit(sd->status.bgstats.ctf_wins,1,USHRT_MAX);	break;
+						case 1: add2limit(sd->status.bgstats.tdm_wins,1,USHRT_MAX); break;
+						case 2: add2limit(sd->status.bgstats.eos_wins,1,USHRT_MAX); break;
+						case 3: add2limit(sd->status.bgstats.cq_wins,1,USHRT_MAX); break;
+						case 4: add2limit(sd->status.bgstats.kvm_wins,1,USHRT_MAX); break;
+						case 5: add2limit(sd->status.bgstats.sc_wins,1,USHRT_MAX); break;
+						case 6: add2limit(sd->status.bgstats.dom_wins,1,USHRT_MAX); break;
+						case 7: add2limit(sd->status.bgstats.ru_wins,1,USHRT_MAX); break;
+						case 8: add2limit(sd->status.bgstats.pb_wins,1,USHRT_MAX); break;
+						case 9: add2limit(sd->status.bgstats.td_wins,1,USHRT_MAX); break;
+					}
+					break;
+					
+				case 1: // Tie
+					add2limit(sd->status.bgstats.tie,1,USHRT_MAX);
+					fame = 75;
+					if( sd->bmaster_flag ) {
+						add2limit(sd->status.bgstats.leader_tie,1,USHRT_MAX);
+						fame += 10;
+					}
+					pc_addfame(sd,fame,3);
+					switch( bg_arena )
+					{
+						case 0:	add2limit(sd->status.bgstats.ctf_tie,1,USHRT_MAX);	break;
+						case 1: add2limit(sd->status.bgstats.tdm_tie,1,USHRT_MAX); break;
+						case 2: add2limit(sd->status.bgstats.eos_tie,1,USHRT_MAX); break;
+						case 4: add2limit(sd->status.bgstats.kvm_tie,1,USHRT_MAX); break;
+						case 5: add2limit(sd->status.bgstats.sc_tie,1,USHRT_MAX); break;
+						case 6: add2limit(sd->status.bgstats.dom_tie,1,USHRT_MAX); break;
+						case 8: add2limit(sd->status.bgstats.pb_tie,1,USHRT_MAX); break;
+						case 9: add2limit(sd->status.bgstats.td_tie,1,USHRT_MAX); break;
+					}
+					break;
+					
+				case 2: // Lost
+					add2limit(sd->status.bgstats.lost,1,USHRT_MAX);
+					fame = 50;
+					if( sd->bmaster_flag ) {
+						add2limit(sd->status.bgstats.leader_lost,1,USHRT_MAX);
+					}
+					pc_addfame(sd,fame,3);
+					switch( bg_arena )
+					{
+						case 0:	add2limit(sd->status.bgstats.ctf_lost,1,USHRT_MAX);	break;
+						case 1: add2limit(sd->status.bgstats.tdm_lost,1,USHRT_MAX); break;
+						case 2: add2limit(sd->status.bgstats.eos_lost,1,USHRT_MAX); break;
+						case 3: add2limit(sd->status.bgstats.cq_lost,1,USHRT_MAX); break;
+						case 4: add2limit(sd->status.bgstats.kvm_lost,1,USHRT_MAX); break;
+						case 5: add2limit(sd->status.bgstats.sc_lost,1,USHRT_MAX); break;
+						case 6: add2limit(sd->status.bgstats.dom_lost,1,USHRT_MAX); break;
+						case 7: add2limit(sd->status.bgstats.ru_lost,1,USHRT_MAX); break;
+						case 8: add2limit(sd->status.bgstats.pb_lost,1,USHRT_MAX); break;
+						case 9: add2limit(sd->status.bgstats.td_lost,1,USHRT_MAX); break;
+					}
+					break;
+			}
 		}
 	}
 }
diff --git a/src/map/battleground.hpp b/src/map/battleground.hpp
index 36074fc40..dfeb719bc 100644
--- a/src/map/battleground.hpp
+++ b/src/map/battleground.hpp
@@ -193,7 +193,7 @@ void bg_set_mode(int mode);
 
 void bg_team_getitem(int bg_id, int nameid, int amount);
 void bg_team_get_kafrapoints(int bg_id, int amount);
-void bg_team_rewards(int bg_id, int nameid, int amount, int kafrapoints, int quest_id, const char *var, int add_value, int bg_arena);
+void bg_team_rewards(int bg_id, int nameid, int amount, int kafrapoints, int quest_id, const char *var, int add_value, int bg_arena, int bg_result);
 void bg_team_rewards_all(const char* bg_map, int team_id1, int team_id2, int nameid, int amount, int bg_result);
 
 int bg_team_clean(int bg_id, bool remove);
diff --git a/src/map/chrif.cpp b/src/map/chrif.cpp
index e3f358498..01f01ec45 100644
--- a/src/map/chrif.cpp
+++ b/src/map/chrif.cpp
@@ -39,7 +39,7 @@ static struct eri *auth_db_ers; //For reutilizing player login structures.
 static DBMap* auth_db; // int id -> struct auth_node*
 static bool char_init_done = false; //server already initialized? Used for InterInitOnce and vending loadings
 
-static const int packet_len_table[0x3d] = { // U - used, F - free
+static const int packet_len_table[0x50] = { // U - used, F - free
 	60, 3,-1,-1,10,-1, 6,-1,	// 2af8-2aff: U->2af8, U->2af9, U->2afa, U->2afb, U->2afc, U->2afd, U->2afe, U->2aff
 	 6,-1,18, 7,-1,39,30, 10,	// 2b00-2b07: U->2b00, U->2b01, U->2b02, U->2b03, U->2b04, U->2b05, U->2b06, U->2b07
 	 6,30, 10, -1,86, 7,44,34,	// 2b08-2b0f: U->2b08, U->2b09, U->2b0a, U->2b0b, U->2b0c, U->2b0d, U->2b0e, U->2b0f
@@ -47,6 +47,7 @@ static const int packet_len_table[0x3d] = { // U - used, F - free
 	 2,10, 2,-1,-1,-1, 2, 7,	// 2b18-2b1f: U->2b18, U->2b19, U->2b1a, U->2b1b, U->2b1c, U->2b1d, U->2b1e, U->2b1f
 	-1,10, 8, 2, 2,14,19,19,	// 2b20-2b27: U->2b20, U->2b21, U->2b22, U->2b23, U->2b24, U->2b25, U->2b26, U->2b27
 	-1, 0, 6,15, 0, 6,-1,-1,	// 2b28-2b2f: U->2b28, F->2b29, U->2b2a, U->2b2b, F->2b2c, U->2b2d, U->2b2e, U->2b2f
+	 4, 4, 4, 4,-1, 6, 0, 0,    // 2b30-2b37: U->2b30, U->2b31, U->2b32, U->2b33, U->2b34, F->2b35, F->2b36, F->2b37
  };
 
 //Used Packets:
@@ -105,6 +106,9 @@ static const int packet_len_table[0x3d] = { // U - used, F - free
 //2b2d: Outgoing, chrif_bsdata_request -> request bonus_script for pc_authok'ed char.
 //2b2e: Outgoing, chrif_bsdata_save -> Send bonus_script of player for saving.
 //2b2f: Incoming, chrif_bsdata_received -> received bonus_script of player for loading.
+//2b30: Outgoing, chrif_ranking_reset -> '...'
+//2b31: Incoming, chrif_ranking_reset_ack -> '...'
+//2b34: Incoming, chrif_recvfamelist_single -> '...'
 
 int chrif_connected = 0;
 int char_fd = -1;
@@ -1211,23 +1215,32 @@ int chrif_disconnectplayer(int fd) {
 /*==========================================
  * Request/Receive top 10 Fame character list
  *------------------------------------------*/
-int chrif_updatefamelist(struct map_session_data* sd) {
+int chrif_updatefamelist(struct map_session_data* sd, short flag) {
 	char type;
 
 	chrif_check(-1);
 
-	switch(sd->class_ & MAPID_UPPERMASK) {
-		case MAPID_BLACKSMITH: type = RANK_BLACKSMITH; break;
-		case MAPID_ALCHEMIST:  type = RANK_ALCHEMIST; break;
-		case MAPID_TAEKWON:    type = RANK_TAEKWON; break;
-		default:
-			return 0;
+	if( !flag )
+	{
+		switch(sd->class_ & MAPID_UPPERMASK) 
+		{
+			case MAPID_BLACKSMITH: type = RANK_BLACKSMITH; break;
+			case MAPID_ALCHEMIST:  type = RANK_ALCHEMIST; break;
+			case MAPID_TAEKWON:    type = RANK_TAEKWON; break;
+			default:
+				return 0;
+		}
 	}
+	else type = 3 + flag; // 4 = BG
 
 	WFIFOHEAD(char_fd, 11);
 	WFIFOW(char_fd,0) = 0x2b10;
 	WFIFOL(char_fd,2) = sd->status.char_id;
-	WFIFOL(char_fd,6) = sd->status.fame;
+	switch( flag )
+	{
+	case 1:  WFIFOL(char_fd,6) = sd->status.bgstats.points; break;
+	default: WFIFOL(char_fd,6) = sd->status.fame; break;
+	}
 	WFIFOB(char_fd,10) = type;
 	WFIFOSET(char_fd,11);
 
@@ -1251,9 +1264,9 @@ int chrif_recvfamelist(int fd) {
 	memset (smith_fame_list, 0, sizeof(smith_fame_list));
 	memset (chemist_fame_list, 0, sizeof(chemist_fame_list));
 	memset (taekwon_fame_list, 0, sizeof(taekwon_fame_list));
-
+	
 	size = RFIFOW(fd, 6); //Blacksmith block size
-
+	
 	for (num = 0; len < size && num < MAX_FAME_LIST; num++) {
 		memcpy(&smith_fame_list[num], RFIFOP(fd,len), sizeof(struct fame_list));
  		len += sizeof(struct fame_list);
@@ -1265,7 +1278,7 @@ int chrif_recvfamelist(int fd) {
 
 	for (num = 0; len < size && num < MAX_FAME_LIST; num++) {
 		memcpy(&chemist_fame_list[num], RFIFOP(fd,len), sizeof(struct fame_list));
- 		len += sizeof(struct fame_list);
+		len += sizeof(struct fame_list);
 	}
 
 	total += num;
diff --git a/src/map/chrif.hpp b/src/map/chrif.hpp
index c88144bc0..8e0f9fb39 100644
--- a/src/map/chrif.hpp
+++ b/src/map/chrif.hpp
@@ -68,7 +68,7 @@ int chrif_changemapserver(struct map_session_data* sd, uint32 ip, uint16 port);
 int chrif_searchcharid(uint32 char_id);
 int chrif_changeemail(int id, const char *actual_email, const char *new_email);
 int chrif_req_login_operation(int aid, const char* character_name, enum chrif_req_op operation_type, int32 timediff, int val1, int val2);
-int chrif_updatefamelist(struct map_session_data *sd);
+int chrif_updatefamelist(struct map_session_data *sd, short flag);
 int chrif_buildfamelist(void);
 int chrif_save_scdata(struct map_session_data *sd);
 int chrif_char_offline(struct map_session_data *sd);
@@ -78,7 +78,7 @@ int send_users_tochar(void);
 int chrif_char_online(struct map_session_data *sd);
 int chrif_changesex(struct map_session_data *sd, bool change_account);
 int chrif_divorce(int partner_id1, int partner_id2);
-
+int chrif_ranking_reset(int type);
 int chrif_removefriend(uint32 char_id, int friend_id);
 
 void chrif_parse_ack_vipActive(int fd);
diff --git a/src/map/clif.cpp b/src/map/clif.cpp
index ff69a1819..c85c41cc8 100644
--- a/src/map/clif.cpp
+++ b/src/map/clif.cpp
@@ -4940,6 +4940,8 @@ int clif_damage(struct block_list* src, struct block_list* dst, t_tick tick, int
 	nullpo_ret(src);
 	nullpo_ret(dst);
 
+	pc_record_maxdamage(src, dst, damage + damage2);
+
 	if (type != DMG_MULTI_HIT_CRITICAL)
 		type = clif_calc_delay(type,div,damage+damage2,ddelay);
 	sc = status_get_sc(dst);
@@ -5717,9 +5719,31 @@ int clif_skill_damage(struct block_list *src,struct block_list *dst,t_tick tick,
 	unsigned char buf[64];
 	struct status_change *sc;
 	int damage = (int)cap_value(sdamage,INT_MIN,INT_MAX);
+	struct map_session_data *sd;
 
 	nullpo_ret(src);
 	nullpo_ret(dst);
+	
+	/* WoE Stats */
+	pc_record_maxdamage(src, dst, damage);
+	sd = BL_CAST(BL_PC, src);
+	if( sd && skill_id == CR_ACIDDEMONSTRATION )
+	{
+		if( damage > 0 )
+		{
+			if( sd->status.guild_id && map_allowed_woe(src->m) )
+				add2limit(sd->status.wstats.acid_demostration, 1, UINT32_MAX);
+			else if( map_getmapflag(src->m, MF_BATTLEGROUND) && sd->bg_id )
+				add2limit(sd->status.bgstats.acid_demostration, 1, UINT32_MAX);
+		}
+		else
+		{
+			if( sd->status.guild_id && map_allowed_woe(src->m) )
+				add2limit(sd->status.wstats.acid_demostration_fail, 1, UINT32_MAX);
+			else if( map_getmapflag(src->m, MF_BATTLEGROUND) && sd->bg_id )
+				add2limit(sd->status.bgstats.acid_demostration_fail, 1, UINT32_MAX);
+		}
+	}
 
 	type = clif_calc_delay(type,div,damage,ddelay);
 
@@ -19799,6 +19823,17 @@ void clif_parse_Taekwon( int fd, struct map_session_data *sd ){
 	clif_ranklist(sd,RANK_TAEKWON);
 }
 
+void clif_rank_info(struct map_session_data *sd, int points, int total, int flag)
+{
+	char message[100];
+	if( points <= 0 )
+		return;
+
+	if( flag ) {
+		sprintf(message, "[Your Battleground Rank +%d = %d points]", points, total);
+		clif_displaymessage(sd->fd, message);
+	}
+}
 /// Request for the killer ranklist.
 /// /pk command sends this packet to the server.
 /// 0237 (CZ_KILLER_RANK)
diff --git a/src/map/clif.hpp b/src/map/clif.hpp
index 7ed31a633..20583ee4b 100644
--- a/src/map/clif.hpp
+++ b/src/map/clif.hpp
@@ -587,6 +587,8 @@ uint32 clif_getip(void);
 uint32 clif_refresh_ip(void);
 uint16 clif_getport(void);
 
+void clif_rank_info(struct map_session_data *sd, int points, int total, int flag);
+
 void clif_authok(struct map_session_data *sd);
 void clif_authrefuse(int fd, uint8 error_code);
 void clif_authfail_fd(int fd, int type);
diff --git a/src/map/guild.cpp b/src/map/guild.cpp
index 6fa4ce649..55ba41d94 100644
--- a/src/map/guild.cpp
+++ b/src/map/guild.cpp
@@ -229,6 +229,8 @@ static TBL_PC* guild_sd_check(int guild_id, uint32 account_id, uint32 char_id) {
 	return sd;
 }
 
+int guild_score_saved(int guild_id, int index) { return 0; }
+
 // Modified [Komurka]
 uint16 guild_skill_get_max( uint16 id ){
 	std::shared_ptr<s_guild_skill_tree> skill = guild_skill_tree_db.find( id );
@@ -2125,6 +2127,20 @@ int guild_castledatasave(int castle_id, int index, int value) {
 	case CD_GUILD_ID: // The castle's owner has changed? Update or remove Guardians too. [Skotlex]
 	{
 		int i;
+		struct guild *g;
+		int m = map_mapindex2mapid(gc->mapindex);
+		if( map_allowed_woe(m) && gc->guild_id && (g = guild_search(gc->guild_id)) != NULL )
+		{ // Current WoE
+			int i = gc->castle_id;
+			int addtime = (int)DIFF_TICK(gettick(), gc->capture_tick);
+			int score = (addtime / 300) * (1 + (gc->economy / 25));
+
+			g->castle[i].posesion_time += addtime;
+			g->castle[i].defensive_score += score;
+			g->castle[i].changed = true;
+		}
+
+		gc->capture_tick = gettick();
 		gc->guild_id = value;
 		for (i = 0; i < MAX_GUARDIANS; i++){
 			struct mob_data *gd;
@@ -2133,11 +2149,44 @@ int guild_castledatasave(int castle_id, int index, int value) {
 		}
 		break;
 	}
+	
 	case CD_CURRENT_ECONOMY:
-		gc->economy = value; break;
+	{
+		struct guild *g = gc->guild_id ? guild_search(gc->guild_id) : NULL;
+		if( g && gc->economy < value )
+		{
+			int eco = value - gc->economy;
+			add2limit(g->castle[gc->castle_id].invest_eco, eco, USHRT_MAX);
+			if( g->castle[gc->castle_id].top_eco < value )
+				g->castle[gc->castle_id].top_eco = value;
+			g->castle[gc->castle_id].changed = true;
+			if( !agit_flag )
+			{
+				intif_guild_save_score(g->guild_id, gc->castle_id, &g->castle[gc->castle_id]);
+				g->castle[gc->castle_id].changed = false;
+			}
+		}
+		gc->economy = value; 
+		break;
+	}
+	
 	case CD_CURRENT_DEFENSE: // defense invest change -> recalculate guardian hp
 	{
 		int i;
+		struct guild *g = gc->guild_id ? guild_search(gc->guild_id) : NULL;
+		if( g && gc->defense < value )
+		{
+			int def = value - gc->defense;
+			add2limit(g->castle[gc->castle_id].invest_def, def, USHRT_MAX);
+			if( g->castle[gc->castle_id].top_def < value )
+				g->castle[gc->castle_id].top_def = value;
+			g->castle[gc->castle_id].changed = true;
+			if( !agit_flag )
+			{
+				intif_guild_save_score(g->guild_id, gc->castle_id, &g->castle[gc->castle_id]);
+				g->castle[gc->castle_id].changed = false;
+			}
+		}
 		gc->defense = value;
 		for (i = 0; i < MAX_GUARDIANS; i++){
 			struct mob_data *gd;
@@ -2251,11 +2300,69 @@ int guild_castledataloadack(int len, struct guild_castle *gc) {
 	ShowStatus("Received '" CL_WHITE "%d" CL_RESET "' guild castles from char-server.\n", n);
 	return 0;
 }
+/*------------------------------------------
+ * Guild Ranking System
+ *------------------------------------------*/
+int guild_ranking_save(int flag)
+{
+	struct guild *g;
+	struct map_session_data *sd;
+	int i, j, index;
+	int64 cc;
+
+	for (const auto& it : castle_db) {
+		std::shared_ptr<guild_castle> gc = it.second;
+
+		if( gc->guild_id == 0 )
+			continue;
+		
+		index = gc->castle_id;
+
+		if( index >= RANK_CASTLES || (flag == 1 && index >= 24) || (flag == 2 && index < 24) )
+			continue;
+
+		if( (g = guild_search(gc->guild_id)) != NULL )
+		{
+			int addtime = (int)DIFF_TICK(gettick(), gc->capture_tick);
+			int score = (addtime / 300) * (1 + (gc->economy / 25));
+
+			g->castle[index].capture++;
+			g->castle[index].posesion_time += addtime;
+			g->castle[index].defensive_score += score;
+			g->castle[index].changed = true;
+
+			// Capture counter for members
+			for( j = 0; j < MAX_GUILD; j++ )
+			{
+				if( (sd = g->member[j].sd) == NULL )
+					continue;
+
+				cc = pc_readaccountreg(sd, add_str("#GC_CAPTURES"));
+				pc_setaccountreg(sd, add_str("#GC_CAPTURES"),++cc);
+			}
+		}
+	}
+
+	for (const auto& it : castle_db) {
+		std::shared_ptr<guild_castle> gc = it.second;
+
+		for( i = 0; i < RANK_CASTLES; i++ )
+		{
+			if( i >= RANK_CASTLES || !g->castle[i].changed )
+				continue;
+
+			intif_guild_save_score(g->guild_id, i, &g->castle[i]);
+			g->castle[i].changed = false;
+		}
+	}
+	return 0;
+}
 
 /**
  * Start WoE:FE and triggers all npc OnAgitStart
  */
-bool guild_agit_start(void){
+bool guild_agit_start(void){	
+
 	if( agit_flag ){
 		return false;
 	}
@@ -2264,6 +2371,17 @@ bool guild_agit_start(void){
 
 	npc_event_runall( script_config.agit_start_event_name );
 
+	for (const auto& it : castle_db) {
+		std::shared_ptr<guild_castle> gc = it.second;
+
+		if( gc->castle_id >= 24 )
+			continue; // WoE SE Castle
+		if( !gc->guild_id )
+			continue; // No owner
+
+		gc->capture_tick = gettick();
+	}
+
 	return true;
 }
 
@@ -2278,7 +2396,8 @@ bool guild_agit_end(void){
 	agit_flag = false;
 
 	npc_event_runall( script_config.agit_end_event_name );
-
+	guild_ranking_save(1);
+	
 	return true;
 }
 
@@ -2293,7 +2412,16 @@ bool guild_agit2_start(void){
 	agit2_flag = true;
 
 	npc_event_runall( script_config.agit_start2_event_name );
+	for (const auto& it : castle_db) {
+		std::shared_ptr<guild_castle> gc = it.second;
 
+		if( gc->castle_id < 24 )
+			continue; // Non WoE SE Castle
+		if( !gc->guild_id )
+			continue; // No owner
+
+		gc->capture_tick = gettick();
+	}
 	return true;
 }
 
@@ -2308,7 +2436,7 @@ bool guild_agit2_end(void){
 	agit2_flag = false;
 
 	npc_event_runall( script_config.agit_end2_event_name );
-
+	guild_ranking_save(2);
 	return true;
 }
 
diff --git a/src/map/guild.hpp b/src/map/guild.hpp
index d0637d905..aa17bc000 100644
--- a/src/map/guild.hpp
+++ b/src/map/guild.hpp
@@ -69,6 +69,7 @@ int guild_allianceack(int guild_id1,int guild_id2,uint32 account_id1,uint32 acco
 int guild_delalliance(struct map_session_data *sd,int guild_id,int flag);
 int guild_opposition(struct map_session_data *sd,struct map_session_data *tsd);
 int guild_check_alliance(int guild_id1, int guild_id2, int flag);
+int guild_score_saved(int guild_id, int index);
 
 int guild_send_memberinfoshort(struct map_session_data *sd,int online);
 int guild_recv_memberinfoshort(int guild_id,uint32 account_id,uint32 char_id,int online,int lv,int class_);
diff --git a/src/map/intif.cpp b/src/map/intif.cpp
index f18e045b1..79231d0a2 100644
--- a/src/map/intif.cpp
+++ b/src/map/intif.cpp
@@ -39,7 +39,7 @@ static const int packet_len_table[] = {
 	 0, 0, 0, 0,  0, 0, 0, 0, -1,11, 0, 0,  0, 0,  0, 0, //0x3810
 	39,-1,15,15, 15+NAME_LENGTH,19, 7,-1,  0, 0, 0, 0,  0, 0,  0, 0, //0x3820
 	10,-1,15, 0, 79,19, 7,-1,  0,-1,-1,-1, 14,67,186,-1, //0x3830
-	-1,10, 0,18,  0, 0, 0, 0, -1,75,-1,11, 11,-1, 38, 0, //0x3840
+	-1,10, 0,18,  8, 0, 0, 0, -1,75,-1,11, 11,-1, 38, 0, //0x3840  3844 - Guild Rank
 	-1,-1, 7, 7,  7,11, 8,-1,  0, 0, 0, 0,  0, 0,  0, 0, //0x3850  Auctions [Zephyrus] itembound[Akinari]
 	-1, 7,-1, 7, 14, 0, 0, 0,  0, 0, 0, 0,  0, 0,  0, 0, //0x3860  Quests [Kevin] [Inkfish] / Achievements [Aleos]
 	-1, 3, 3, 0,  0, 0, 0, 0,  0, 0, 0, 0, -1, 3,  3, 0, //0x3870  Mercenaries [Zephyrus] / Elemental [pakpil]
@@ -1107,8 +1107,21 @@ int intif_guild_notice(int guild_id,const char *mes1,const char *mes2)
 	memcpy(WFIFOP(inter_fd,66),mes2,MAX_GUILDMES2);
 	WFIFOSET(inter_fd,186);
 	return 1;
-}
+} 
+int intif_guild_save_score(int guild_id, int castle, struct guild_rank_data *grd)
+{
+	if( CheckForCharServer() )
+		return 0;
 
+	WFIFOHEAD(inter_fd,14);
+	WFIFOW(inter_fd,0) = 0x3043;
+	WFIFOW(inter_fd,2) = sizeof(struct guild_rank_data) + 10;
+	WFIFOL(inter_fd,4) = guild_id;
+	WFIFOW(inter_fd,8) = castle;
+	memcpy(WFIFOP(inter_fd,10), grd, sizeof(struct guild_rank_data));
+	WFIFOSET(inter_fd,WFIFOW(inter_fd,2));
+	return 1;
+}
 /**
  * Request to change guild emblem
  * @param guild_id
@@ -1876,6 +1889,12 @@ int intif_parse_GuildMasterChanged(int fd)
 	return guild_gm_changed(RFIFOL(fd,2),RFIFOL(fd,6),RFIFOL(fd,10),RFIFOL(fd,14));
 }
 
+int intif_parse_Guild_score_saved(int fd)
+{
+	guild_score_saved(RFIFOL(fd,2),RFIFOW(fd,6));
+	return 1;
+}
+
 /**
  * Request pet creation
  * @param fd : char-serv link
@@ -3817,6 +3836,7 @@ int intif_parse(int fd)
 	case 0x3840:	intif_parse_GuildCastleDataLoad(fd); break;
 	case 0x3841:	intif_parse_GuildEmblemVersionChanged(fd); break;
 	case 0x3843:	intif_parse_GuildMasterChanged(fd); break;
+	case 0x3844:	intif_parse_Guild_score_saved(fd); break;
 
 	// Mail System
 	case 0x3848:	intif_parse_Mail_inboxreceived(fd); break;
diff --git a/src/map/intif.hpp b/src/map/intif.hpp
index b2c4de1a6..cdff8e6c0 100644
--- a/src/map/intif.hpp
+++ b/src/map/intif.hpp
@@ -50,6 +50,8 @@ int intif_party_message(int party_id, uint32 account_id, const char *mes,int len
 int intif_party_leaderchange(int party_id,uint32 account_id,uint32 char_id);
 int intif_party_sharelvlupdate(unsigned int share_lvl);
 
+int intif_guild_save_score(int guild_id, int castle, struct guild_rank_data *grd);
+
 int intif_guild_create(const char *name, const struct guild_member *master);
 int intif_guild_request_info(int guild_id);
 int intif_guild_addmember(int guild_id, struct guild_member *m);
diff --git a/src/map/itemdb.hpp b/src/map/itemdb.hpp
index fdff83fa3..6dfbd561d 100644
--- a/src/map/itemdb.hpp
+++ b/src/map/itemdb.hpp
@@ -58,6 +58,7 @@ enum item_itemid : t_itemid
 	ITEMID_POISON_BOTTLE				= 678,
 	ITEMID_EMPTY_BOTTLE					= 713,
 	ITEMID_EMPERIUM						= 714,
+	ITEMID_YELLOW_GEMSTONE				= 715,
 	ITEMID_RED_GEMSTONE					= 716,
 	ITEMID_BLUE_GEMSTONE				= 717,
 	ITEMID_ORIDECON_STONE				= 756,
diff --git a/src/map/log.cpp b/src/map/log.cpp
index 8c0ba2c8f..98bddede1 100644
--- a/src/map/log.cpp
+++ b/src/map/log.cpp
@@ -198,7 +198,33 @@ void log_branch(struct map_session_data* sd)
 		fclose(logfp);
 	}
 }
+void log_bg_kill(struct map_session_data* ssd, struct map_session_data* tsd, uint16 skill_id)
+{
+	char esc_sname[NAME_LENGTH*2+1];
+	char esc_tname[NAME_LENGTH*2+1];
+
+	Sql_EscapeStringLen(mmysql_handle, esc_sname, ssd->status.name, strnlen(ssd->status.name, NAME_LENGTH));
+	Sql_EscapeStringLen(mmysql_handle, esc_tname, tsd->status.name, strnlen(tsd->status.name, NAME_LENGTH));
+
+	if( SQL_ERROR == Sql_Query(mmysql_handle,LOG_QUERY " INTO `rank_bg_log` (`time`,`killer`,`killer_id`,`killed`,`killed_id`,`map`,`skill`) VALUES (NOW(), '%s', '%d', '%s', '%d', '%s', '%d')", esc_sname, ssd->status.char_id, esc_tname, tsd->status.char_id, map[tsd->bl.m].name, skill_id) )
+		Sql_ShowDebug(mmysql_handle);
 
+	return;
+}
+ 
+void log_woe_kill(struct map_session_data* ssd, struct map_session_data* tsd, uint16 skill_id)
+{
+	char esc_sname[NAME_LENGTH*2+1];
+	char esc_tname[NAME_LENGTH*2+1];
+
+	Sql_EscapeStringLen(mmysql_handle, esc_sname, ssd->status.name, strnlen(ssd->status.name, NAME_LENGTH));
+	Sql_EscapeStringLen(mmysql_handle, esc_tname, tsd->status.name, strnlen(tsd->status.name, NAME_LENGTH));
+
+	if( SQL_ERROR == Sql_Query(mmysql_handle,LOG_QUERY " INTO `rank_woe_log` (`time`,`killer`,`killer_id`,`killed`,`killed_id`,`map`,`skill`) VALUES (NOW(), '%s', '%d', '%s', '%d', '%s', '%d')", esc_sname, ssd->status.char_id, esc_tname, tsd->status.char_id, map[tsd->bl.m].name, skill_id) )
+		Sql_ShowDebug(mmysql_handle);
+
+	return;
+}
 /// logs item transactions (generic)
 void log_pick(int id, int16 m, e_log_pick_type type, int amount, struct item* itm)
 {
diff --git a/src/map/log.hpp b/src/map/log.hpp
index 86d262c05..d6d9cfea0 100644
--- a/src/map/log.hpp
+++ b/src/map/log.hpp
@@ -80,6 +80,9 @@ void log_chat(e_log_chat_type type, int type_id, int src_charid, int src_accid,
 void log_atcommand(struct map_session_data* sd, const char* message);
 void log_feeding(struct map_session_data *sd, e_log_feeding_type type, t_itemid nameid);
 
+void log_bg_kill(struct map_session_data* ssd, struct map_session_data* tsd, uint16 skill_id);
+void log_woe_kill(struct map_session_data* ssd, struct map_session_data* tsd, uint16 skill_id);
+
 /// old, but useful logs
 void log_branch(struct map_session_data* sd);
 void log_mvpdrop(struct map_session_data* sd, int monster_id, t_itemid nameid, t_exp exp);
diff --git a/src/map/map.hpp b/src/map/map.hpp
index a8fdb4b76..29ab893ea 100644
--- a/src/map/map.hpp
+++ b/src/map/map.hpp
@@ -916,6 +916,16 @@ inline bool mapdata_flag_gvg2_no_te(struct map_data *mapdata) {
 	return false;
 }
 
+inline bool mapdata_allowed_woe(struct map_data *mapdata) {
+	if (mapdata == nullptr)
+		return false;
+	
+	if((agit_flag || agit2_flag) && mapdata->flag[MF_GVG] && mapdata->flag[MF_GVG_CASTLE])
+		return true;
+
+	return false;
+}
+
 inline bool mapdata_gvg_items(struct map_data *mapdata) {
 	if (mapdata == nullptr)
 		return false;
@@ -1000,6 +1010,15 @@ inline bool map_flag_gvg2_no_te(int16 m) {
 	return mapdata_flag_gvg2_no_te(mapdata);
 }
 
+inline bool map_allowed_woe(int16 m) {
+	if (m < 0)
+		return false;
+
+	struct map_data *mapdata = &map[m];
+
+	return mapdata_allowed_woe(mapdata);
+}
+
 inline bool map_gvg_items(int16 m) {
 	if (m < 0)
 		return false;
diff --git a/src/map/mob.cpp b/src/map/mob.cpp
index 75e0dd95e..682c35371 100644
--- a/src/map/mob.cpp
+++ b/src/map/mob.cpp
@@ -3071,7 +3071,7 @@ int mob_dead(struct mob_data *md, struct block_list *src, int type)
 			{ //TK_MISSION [Skotlex]
 				if (++(sd->mission_count) >= 100 && (temp = mob_get_random_id(MOBG_BRANCH_OF_DEAD_TREE, static_cast<e_random_monster_flags>(RMF_CHECK_MOB_LV|RMF_MOB_NOT_BOSS|RMF_MOB_NOT_SPAWN), sd->status.base_level)))
 				{
-					pc_addfame(sd, battle_config.fame_taekwon_mission);
+					pc_addfame(sd, battle_config.fame_taekwon_mission,0);
 					sd->mission_mobid = temp;
 					pc_setglobalreg(sd, add_str(TKMISSIONID_VAR), temp);
 					sd->mission_count = 0;
@@ -3095,6 +3095,8 @@ int mob_dead(struct mob_data *md, struct block_list *src, int type)
 			// The master or Mercenary can increase the kill count
 			if (sd->md && src && (src->type == BL_PC || src->type == BL_MER) && mob->lv > sd->status.base_level / 2)
 				mercenary_kills(sd->md);
+
+			pc_record_mobkills(sd,md);
 		}
 
 		if( md->npc_event[0] && !md->state.npc_killmonster ) {
diff --git a/src/map/pc.cpp b/src/map/pc.cpp
index f98814a83..b654a291d 100755
--- a/src/map/pc.cpp
+++ b/src/map/pc.cpp
@@ -82,6 +82,7 @@ int pc_expiration_tid = INVALID_TIMER;
 struct fame_list smith_fame_list[MAX_FAME_LIST];
 struct fame_list chemist_fame_list[MAX_FAME_LIST];
 struct fame_list taekwon_fame_list[MAX_FAME_LIST];
+struct fame_list bg_fame_list[MAX_FAME_LIST];
 
 struct s_job_info job_info[CLASS_COUNT];
 
@@ -742,10 +743,23 @@ int pc_delsoulball(map_session_data *sd, int count, bool type)
 * @param sd Player
 * @param count Fame point
 */
-void pc_addfame(struct map_session_data *sd,int count)
+void pc_addfame(struct map_session_data *sd,int count,short flag)
 {
 	enum e_rank ranktype;
 	nullpo_retv(sd);
+	switch( flag )
+	{
+	case 3: // Bg Normal Matchs
+		sd->status.bgstats.points += count;
+		if( sd->status.bgstats.points > MAX_FAME )
+			sd->status.bgstats.points = MAX_FAME;
+
+		clif_rank_info(sd,count,sd->status.bgstats.points,0);
+		chrif_updatefamelist(sd,1);
+		return;
+	}
+
+	// Normal Rankings
 	sd->status.fame += count;
 	if(sd->status.fame > MAX_FAME)
 		sd->status.fame = MAX_FAME;
@@ -760,7 +774,7 @@ void pc_addfame(struct map_session_data *sd,int count)
 	}
 
 	clif_update_rankingpoint(sd,ranktype,count);
-	chrif_updatefamelist(sd);
+	chrif_updatefamelist(sd,0);
 }
 
 /**
@@ -8499,10 +8513,290 @@ void pc_close_npc(struct map_session_data *sd,int flag)
 	}
 }
 
+void pc_record_mobkills(struct map_session_data *sd, struct mob_data *md)
+{
+	struct guild *g;
+	std::shared_ptr<guild_castle> gc;
+	std::shared_ptr<s_battleground_data> bg;
+
+	if( !sd ) return;
+	if( map_getmapflag(sd->bl.m, MF_BATTLEGROUND) && sd->bg_id )
+	{
+		int i;
+		bg = util::umap_find(bg_team_db, sd->bg_id);
+		if( !bg )
+			return;
+		ARR_FIND(0,MAX_BG_MEMBERS,i,bg->members[i].sd == sd);
+		if( i >= MAX_BG_MEMBERS )
+			return;
+	}
+
+	if( map_allowed_woe(sd->bl.m) )
+	{
+		switch( md->mob_id )
+		{
+		case 1288:
+			add2limit(sd->status.wstats.emperium_kill, 1, USHRT_MAX);
+			if( (g = guild_search(sd->status.guild_id)) && (gc = castle_db.mapindex2gc(map[sd->bl.m].index)) )
+			{
+				add2limit(g->castle[gc->castle_id].emperium, 1, USHRT_MAX);
+				g->castle[gc->castle_id].changed = true;
+			}
+			break;
+		case 1905:
+			add2limit(sd->status.wstats.barricade_kill, 1, USHRT_MAX);
+			break;
+		case 1907:
+		case 1908:
+			add2limit(sd->status.wstats.gstone_kill, 1, USHRT_MAX);
+			break;
+		case 1285:
+		case 1286:
+		case 1287:
+		case 1899:
+		case 1900:
+			add2limit(sd->status.wstats.guardian_kill, 1, USHRT_MAX);
+			break;
+		}
+	}
+	else if( map_getmapflag(sd->bl.m, MF_BATTLEGROUND) )
+	{
+		switch( md->mob_id )
+		{
+		case 1907:
+		case 1908:
+			add2limit(sd->status.bgstats.gstone_kill, 1, USHRT_MAX);
+			pc_addfame(sd,10,3);
+			break;
+		case 1288:
+			if( map_getmapflag(sd->bl.m, MF_BATTLEGROUND) == 2 )
+				add2limit(sd->status.bgstats.ru_captures, 1, USHRT_MAX);
+			else
+				add2limit(sd->status.bgstats.emperium_kill, 1, USHRT_MAX);
+			pc_addfame(sd,30,3);
+			break;
+		case 1905:
+			add2limit(sd->status.bgstats.barricade_kill, 1, USHRT_MAX);
+			pc_addfame(sd,1,3);
+			break;
+		}
+	}
+
+	if( map_getmapflag(sd->bl.m, MF_GVG_CASTLE) && ((md->mob_id >= 1324 && md->mob_id <= 1363) || (md->mob_id >= 1938 && md->mob_id <= 1946)) && (g = guild_search(sd->status.guild_id)) && (gc = castle_db.mapindex2gc(map[sd->bl.m].index)) )
+	{
+		add2limit(g->castle[gc->castle_id].treasure, 1, USHRT_MAX); // Treasure opened on Castle
+		g->castle[gc->castle_id].changed = true;
+		if( !(agit_flag || agit2_flag) )
+		{
+			intif_guild_save_score(g->guild_id, gc->castle_id, &g->castle[gc->castle_id]);
+			g->castle[gc->castle_id].changed = false;
+		}
+	}
+}
+
+void pc_record_maxdamage(struct block_list *src, struct block_list *dst, int damage)
+{
+	struct block_list *s_bl;
+	struct map_session_data *sd;
+
+	if( !src || !dst || src == dst || dst->type != BL_PC || damage <= 0 )
+		return;
+
+	if( (s_bl = battle_get_master(src)) == NULL )
+		s_bl = src;
+
+	if( s_bl->type != BL_PC )
+		return;
+
+	if( (sd = BL_CAST(BL_PC, s_bl)) != NULL )
+	{
+		if( map_getmapflag(src->m, MF_BATTLEGROUND) && sd->bg_id && sd->status.bgstats.top_damage < damage )
+			sd->status.bgstats.top_damage = damage;
+		else if( map_allowed_woe(src->m) && sd->status.wstats.top_damage < damage )
+			sd->status.wstats.top_damage = damage;
+	}
+}
+
+void pc_record_damage(struct block_list *src, struct block_list *dst, int damage)
+{
+	struct block_list *s_bl;
+	struct map_session_data *sd;
+
+	if( !src || !dst || src == dst || damage <= 0 )
+		return;
+
+	if( (s_bl = battle_get_master(src)) == NULL )
+		s_bl = src;
+
+	if( s_bl->type != BL_PC )
+		return;
+
+	sd = BL_CAST(BL_PC, s_bl);
+
+	switch( dst->type )
+	{
+		case BL_PC:
+			if( map_getmapflag(src->m, MF_BATTLEGROUND) && sd->bg_id )
+			{
+				add2limit(sd->status.bgstats.damage_done, damage, UINT_MAX);
+				add2limit(((TBL_PC*)dst)->status.bgstats.damage_received, damage, UINT_MAX);
+			}
+			else if( map_allowed_woe(src->m) )
+			{
+				add2limit(sd->status.wstats.damage_done, damage, UINT_MAX);
+				add2limit(((TBL_PC*)dst)->status.wstats.damage_received, damage, UINT_MAX);
+			}
+			break;
+		case BL_MOB:
+		{
+			struct mob_data *md = BL_CAST(BL_MOB, dst);
+			if( map_allowed_woe(src->m) && md->guardian_data )
+			{
+				switch( md->mob_id )
+				{
+					case 1288:
+						add2limit(sd->status.wstats.emperium_damage, damage, UINT_MAX);
+						break;
+					case 1905:
+					case 1906:
+						add2limit(sd->status.wstats.barricade_damage, damage, UINT_MAX);
+						break;
+					case 1907:
+					case 1908:
+						add2limit(sd->status.wstats.gstone_damage, damage, UINT_MAX);
+						break;
+					default:
+						add2limit(sd->status.wstats.guardian_damage, damage, UINT_MAX);
+						break;
+				}
+			}
+			break;
+		}
+	}
+}
+
+void pc_calc_ranking(struct map_session_data *tsd, struct map_session_data *ssd, uint16 skill_id)
+{
+	int m, i, Elo;
+
+	if( !tsd || !ssd || tsd == ssd )
+		return;
+
+	m = ssd->bl.m;
+
+	if( map_allowed_woe(m) )
+	{
+		/*==========================================
+		 * Guild Ranking - War of Emperium
+		 *------------------------------------------*/
+		struct guild *tg, *sg;
+		std::shared_ptr<guild_castle> gc = castle_db.mapindex2gc(map[m].index);
+
+		if( gc == NULL || gc->guild_id <= 0 )
+			return;
+
+		if( (tg = guild_search(tsd->status.guild_id)) == NULL || (sg = guild_search(ssd->status.guild_id)) == NULL )
+			return;
+
+		i = gc->castle_id;
+		Elo = (int)(10. / (1 + pow(10., (int)(sg->castle[i].offensive_score - tg->castle[i].offensive_score) / 2000.)));
+		add2limit(sg->castle[i].offensive_score, Elo, 4000);
+		sub2limit(tg->castle[i].offensive_score, Elo, 0);
+
+		// Single Player Ranking WoE
+		Elo = (int)(50. / (1 + pow(10., (int)(ssd->status.wstats.score - tsd->status.wstats.score) / 2000.)));
+		add2limit(ssd->status.wstats.score, Elo, 4000);
+		sub2limit(tsd->status.wstats.score, Elo, 0);
+		add2limit(ssd->status.wstats.kill_count, 1, USHRT_MAX);
+		add2limit(tsd->status.wstats.death_count, 1, USHRT_MAX);
+
+		log_woe_kill(ssd,tsd,skill_id);
+
+		if( tsd->status.guild_id == gc->guild_id )
+		{ // Offensive Ranking - Killing Castle Owners
+			add2limit(sg->castle[i].off.kill_count, 1, UINT_MAX);
+			add2limit(tg->castle[i].def.death_count, 1, UINT_MAX);
+		}
+		else if( guild_isallied(gc->guild_id, tsd->status.guild_id) )
+		{ // Offensive Ranking - Killing Castle Allied
+			add2limit(sg->castle[i].off.kill_count, 1, UINT_MAX);
+			add2limit(tg->castle[i].ali.death_count, 1, UINT_MAX);
+		}
+		else if( ssd->status.guild_id == gc->guild_id )
+		{ // Defensive Ranking - Killing Castle Invaders
+			add2limit(sg->castle[i].def.kill_count, 1, UINT_MAX);
+			add2limit(tg->castle[i].off.death_count, 1, UINT_MAX);
+		}
+		else if( guild_isallied(gc->guild_id, ssd->status.guild_id) )
+		{ // Defensive Ranking - Allied killing Invaders
+			add2limit(sg->castle[i].ali.kill_count, 1, UINT_MAX);
+			add2limit(tg->castle[i].off.death_count, 1, UINT_MAX);
+		}
+		else
+		{ // Killing other guilds invaders
+			add2limit(sg->castle[i].ext.kill_count, 1, UINT_MAX);
+			add2limit(tg->castle[i].ext.death_count, 1, UINT_MAX);
+		}
+
+		tg->castle[i].changed = true;
+		sg->castle[i].changed = true;
+	}
+	else if( ssd->bg_id && map_getmapflag(m, MF_BATTLEGROUND) && tsd->bg_id )
+	{
+		/*==========================================
+ 		* BattleGround Ranking
+ 		*------------------------------------------*/
+		struct map_session_data* s_pl[MAX_BG_MEMBERS], * t_pl[MAX_BG_MEMBERS];
+		unsigned int s_rate = 0, t_rate = 0;
+		int sc = 0, tc = 0, s_Elo, t_Elo;
+
+		std::shared_ptr<s_battleground_data> s_bg = util::umap_find(bg_team_db, ssd->bg_id);
+		std::shared_ptr<s_battleground_data> t_bg = util::umap_find(bg_team_db, tsd->bg_id);
+
+		if (!s_bg || !t_bg)
+			return;
+
+		// Source
+		for (const auto& pl_sd : s_bg->members) {
+			if ((s_pl[sc] = pl_sd.sd) == NULL || s_pl[sc]->bl.m != m)
+				continue;
+			s_rate += s_pl[sc]->status.bgstats.score;
+			sc++;
+		}
+		if (sc < 1) return;
+		else s_rate /= sc; // Avergate Source Rate
+
+		// Target
+		for (const auto& pl_sd : t_bg->members) {
+			if ((t_pl[tc] = pl_sd.sd) == NULL || t_pl[tc]->bl.m != m)
+				continue;
+			t_rate += t_pl[tc]->status.bgstats.score;
+			tc++;
+		}
+		if (tc < 1) return;
+		else t_rate /= tc; // Avergate Target Rate
+
+		Elo = (int)(50. / (1 + pow(10., (int)(s_rate - t_rate) / 2000.)));
+		s_Elo = Elo / sc;
+		for (i = 0; i < sc; i++)
+			add2limit(s_pl[i]->status.bgstats.score, s_Elo, 4000);
+
+		t_Elo = Elo / tc;
+		for (i = 0; i < tc; i++)
+			sub2limit(t_pl[i]->status.bgstats.score, t_Elo, 0);
+
+		log_bg_kill(ssd, tsd, skill_id);
+
+		add2limit(ssd->status.bgstats.kill_count, 1, USHRT_MAX);
+		add2limit(tsd->status.bgstats.death_count, 1, USHRT_MAX);
+		ssd->bg_kills++; // This BG Kills
+	}
+
+}
 /*==========================================
  * Invoked when a player has negative current hp
  *------------------------------------------*/
-int pc_dead(struct map_session_data *sd,struct block_list *src)
+int pc_dead(struct map_session_data *sd,struct block_list *src, uint16 skill_id)
 {
 	int i=0,k=0;
 	t_tick tick = gettick();
@@ -8658,6 +8952,7 @@ int pc_dead(struct map_session_data *sd,struct block_list *src)
 
 	if (src && src->type == BL_PC) {
 		struct map_session_data *ssd = (struct map_session_data *)src;
+		pc_calc_ranking(sd, ssd, skill_id); // Ranking System
 		pc_setparam(ssd, SP_KILLEDRID, sd->bl.id);
 		npc_script_event(ssd, NPCE_KILLPC);
 
@@ -9368,6 +9663,12 @@ int pc_itemheal(struct map_session_data *sd, t_itemid itemid, int hp, int sp)
 		tmp = hp * bonus / 100; // Overflow check
 		if (bonus != 100 && tmp > hp)
 			hp = tmp;
+		
+		if( sd->status.guild_id && map_allowed_woe(sd->bl.m) )
+			add2limit(sd->status.wstats.hp_heal_potions, 1, UINT_MAX);
+		else if( map_getmapflag(sd->bl.m, MF_BATTLEGROUND) && sd->bg_id )
+			add2limit(sd->status.bgstats.hp_heal_potions, 1, UINT_MAX);
+
 	}
 	if (sp) {
 		bonus = 100 + (sd->battle_status.int_ << 1) + pc_checkskill(sd, MG_SRECOVERY) * 10 + pc_checkskill(sd, AM_LEARNINGPOTION) * 5;
@@ -9390,6 +9691,11 @@ int pc_itemheal(struct map_session_data *sd, t_itemid itemid, int hp, int sp)
 		tmp = sp * bonus / 100; // Overflow check
 		if (bonus != 100 && tmp > sp)
 			sp = tmp;
+
+		if( sd->status.guild_id && map_allowed_woe(sd->bl.m) )
+			add2limit(sd->status.wstats.sp_heal_potions, 1, UINT_MAX);
+		else if( map_getmapflag(sd->bl.m, MF_BATTLEGROUND) && sd->bg_id )
+			add2limit(sd->status.bgstats.sp_heal_potions, 1, UINT_MAX);
 	}
 	if (sd->sc.count) {
 		// Critical Wound and Death Hurt stack
diff --git a/src/map/pc.hpp b/src/map/pc.hpp
index 8768f313f..73215d0e2 100644
--- a/src/map/pc.hpp
+++ b/src/map/pc.hpp
@@ -59,9 +59,6 @@ enum sc_type : int16;
 #define ATTENDANCE_COUNT_VAR "#AttendanceCounter"
 #define ACHIEVEMENTLEVEL "AchievementLevel"
 
-//Update this max as necessary. 55 is the value needed for Super Baby currently
-//Raised to 105 since Expanded Super Baby needs it.
-#define MAX_SKILL_TREE 105
 //Total number of classes (for data storage)
 #define CLASS_COUNT (JOB_MAX - JOB_NOVICE_HIGH + JOB_MAX_BASIC)
 
@@ -707,6 +704,7 @@ struct map_session_data {
 	int tid_queue_active; ///< Timer ID associated with players joining an active BG
 	std::shared_ptr<s_battleground_data> bmaster_flag;
 	unsigned short bg_team;
+	unsigned short bg_kills;
 
 #ifdef SECURE_NPCTIMEOUT
 	/**
@@ -1316,7 +1314,7 @@ int pc_skillheal_bonus(struct map_session_data *sd, uint16 skill_id);
 int pc_skillheal2_bonus(struct map_session_data *sd, uint16 skill_id);
 
 void pc_damage(struct map_session_data *sd,struct block_list *src,unsigned int hp, unsigned int sp);
-int pc_dead(struct map_session_data *sd,struct block_list *src);
+int pc_dead(struct map_session_data *sd,struct block_list *src,uint16 skill_id);
 void pc_revive(struct map_session_data *sd,unsigned int hp, unsigned int sp);
 bool pc_revive_item(struct map_session_data *sd);
 void pc_heal(struct map_session_data *sd,unsigned int hp,unsigned int sp, int type);
@@ -1417,13 +1415,14 @@ void pc_delspiritball(struct map_session_data *sd,int count,int type);
 int pc_addsoulball(map_session_data *sd, int max);
 int pc_delsoulball(map_session_data *sd, int count, bool type);
 
-void pc_addfame(struct map_session_data *sd,int count);
+void pc_addfame(struct map_session_data *sd,int count,short flag);
 unsigned char pc_famerank(uint32 char_id, int job);
 bool pc_set_hate_mob(struct map_session_data *sd, int pos, struct block_list *bl);
 
 extern struct fame_list smith_fame_list[MAX_FAME_LIST];
 extern struct fame_list chemist_fame_list[MAX_FAME_LIST];
 extern struct fame_list taekwon_fame_list[MAX_FAME_LIST];
+extern struct fame_list bg_fame_list[MAX_FAME_LIST];
 
 void pc_readdb(void);
 void do_init_pc(void);
@@ -1442,6 +1441,11 @@ void pc_inventory_rentals(struct map_session_data *sd);
 void pc_inventory_rental_clear(struct map_session_data *sd);
 void pc_inventory_rental_add(struct map_session_data *sd, unsigned int seconds);
 
+// WoE Ranking Stats
+void pc_record_damage(struct block_list *src, struct block_list *dst, int damage);
+void pc_record_maxdamage(struct block_list *src, struct block_list *dst, int damage);
+void pc_record_mobkills(struct map_session_data *sd, struct mob_data *md);
+
 int pc_read_motd(void); // [Valaris]
 int pc_disguise(struct map_session_data *sd, int class_);
 bool pc_isautolooting(struct map_session_data *sd, t_itemid nameid);
diff --git a/src/map/script.cpp b/src/map/script.cpp
index b7fc6fb0b..959774c03 100644
--- a/src/map/script.cpp
+++ b/src/map/script.cpp
@@ -9375,13 +9375,13 @@ BUILDIN_FUNC(successrefitem) {
 		{ // Fame point system [DracoRPG]
 			switch( sd->inventory_data[i]->weapon_level ){
 				case 1:
-					pc_addfame(sd, battle_config.fame_refine_lv1); // Success to refine to +10 a lv1 weapon you forged = +1 fame point
+					pc_addfame(sd, battle_config.fame_refine_lv1, 0); // Success to refine to +10 a lv1 weapon you forged = +1 fame point
 					break;
 				case 2:
-					pc_addfame(sd, battle_config.fame_refine_lv2); // Success to refine to +10 a lv2 weapon you forged = +25 fame point
+					pc_addfame(sd, battle_config.fame_refine_lv2, 0); // Success to refine to +10 a lv2 weapon you forged = +25 fame point
 					break;
 				case 3:
-					pc_addfame(sd, battle_config.fame_refine_lv3); // Success to refine to +10 a lv3 weapon you forged = +1000 fame point
+					pc_addfame(sd, battle_config.fame_refine_lv3, 0); // Success to refine to +10 a lv3 weapon you forged = +1000 fame point
 					break;
 			 }
 		}
diff --git a/src/map/skill.cpp b/src/map/skill.cpp
index bcb7f0cce..b1eccb678 100755
--- a/src/map/skill.cpp
+++ b/src/map/skill.cpp
@@ -6547,12 +6547,28 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
 			if( tsc && tsc->data[SC_AKAITSUKI] && heal && skill_id != HLIF_HEAL )
 				heal = ~heal + 1;
 			t_exp heal_get_jobexp = status_heal(bl,heal,0,0);
-
-			if(sd && dstsd && heal > 0 && sd != dstsd && battle_config.heal_exp > 0){
-				heal_get_jobexp = heal_get_jobexp * battle_config.heal_exp / 100;
-				if (heal_get_jobexp <= 0)
-					heal_get_jobexp = 1;
-				pc_gainexp (sd, bl, 0, heal_get_jobexp, 0);
+				
+			if(sd && dstsd && heal > 0 && sd != dstsd) {
+				if( sd->status.guild_id && map_allowed_woe(src->m) )
+				{
+					if( sd->status.guild_id == dstsd->status.guild_id)
+						add2limit(sd->status.wstats.healing_done, (unsigned int)heal_get_jobexp, UINT_MAX);
+					else
+						add2limit(sd->status.wstats.wrong_healing_done, (unsigned int)heal_get_jobexp, UINT_MAX);
+				}
+				else if(map_getmapflag(src->m, MF_BATTLEGROUND) && sd->bg_id && dstsd->bg_id )
+				{
+					if( sd->bg_id == dstsd->bg_id )
+						add2limit(sd->status.bgstats.healing_done, (unsigned int)heal_get_jobexp, UINT_MAX);
+					else
+						add2limit(sd->status.bgstats.wrong_healing_done, (unsigned int)heal_get_jobexp, UINT_MAX);
+				}
+				if(battle_config.heal_exp > 0){
+					heal_get_jobexp = heal_get_jobexp * battle_config.heal_exp / 100;
+					if (heal_get_jobexp <= 0)
+						heal_get_jobexp = 1;
+					pc_gainexp (sd, bl, 0, heal_get_jobexp, 0);
+				}
 			}
 		}
 		break;
@@ -9366,8 +9382,12 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
 						sc_start(src,bl,type,100,skill_lv,skill_get_time(skill_id, skill_lv));
 				}
 			}
-		} else if ((map_getmapflag(src->m, MF_BATTLEGROUND) && bg_team_get_id(src)) 
-			|| (!map_getmapflag(src->m, MF_BATTLEGROUND) && status_get_guild_id(src))) {
+		} else if ((map_getmapflag(src->m, MF_BATTLEGROUND) && (i = bg_team_get_id(src))) 
+			|| (!map_getmapflag(src->m, MF_BATTLEGROUND) && (i = status_get_guild_id(src)))) {
+
+			struct guild *g = guild_search(i);
+			std::shared_ptr<guild_castle> gc;
+
 			clif_skill_nodamage(src,bl,skill_id,skill_lv,1);
 			map_foreachinallrange(skill_area_sub, src,
 				skill_get_splash(skill_id, skill_lv), BL_PC,
@@ -9379,6 +9399,17 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
 #else
 				guild_block_skill(sd, skill_get_time2(skill_id, skill_lv));
 #endif
+			if( !map_getmapflag(src->m, MF_BATTLEGROUND) && (i = status_get_guild_id(src)) && g && (gc = castle_db.mapindex2gc(map[src->m].index)) != NULL )
+			{
+				switch( skill_id )
+				{
+				case GD_BATTLEORDER:  add2limit(g->castle[gc->castle_id].skill_battleorder, 1, USHRT_MAX); break;
+				case GD_REGENERATION: add2limit(g->castle[gc->castle_id].skill_regeneration, 1, USHRT_MAX); break;
+				case GD_RESTORE:      add2limit(g->castle[gc->castle_id].skill_restore, 1, USHRT_MAX); break;
+				}
+				g->castle[gc->castle_id].changed = true;
+			}
+
 		}
 		break;
 	case GD_EMERGENCYCALL:
@@ -9389,6 +9420,7 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
 			uint8 j = 0, calls = 0, called = 0;
 			struct guild *g;
 			std::shared_ptr<s_battleground_data> bg;
+			std::shared_ptr<guild_castle> gc;
 			
 			if( map_getmapflag(src->m, MF_BATTLEGROUND) )
 			{
@@ -9429,7 +9461,11 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
 						case 3:	calls = 20; break;
 						default: calls = 0;	break;
 					}
-
+				if( (gc = castle_db.mapindex2gc(map[src->m].index)) != NULL )
+				{
+					add2limit(g->castle[gc->castle_id].skill_emergencycall, 1, USHRT_MAX);
+					g->castle[gc->castle_id].changed = true;
+				}
 				clif_skill_nodamage(src,bl,skill_id,skill_lv,1);
 				for (i = 0; i < g->max_member && (!calls || (calls && called < calls)); i++, j++) {
 					if (j > 8)
@@ -11535,7 +11571,24 @@ int skill_castend_nodamage_id (struct block_list *src, struct block_list *bl, ui
 		map_freeblock_unlock();
 		return 1;
 	}
-
+	
+	if( skill_get_inf(skill_id)&INF_SUPPORT_SKILL && sd && dstsd && sd != dstsd )
+	{
+		if( sd->status.guild_id )
+		{
+			if( sd->status.guild_id == dstsd->status.guild_id )
+				add2limit(sd->status.wstats.support_skills_used, 1, UINT_MAX);
+			else
+				add2limit(sd->status.wstats.wrong_support_skills_used, 1, UINT_MAX);
+		}
+		else if( map_getmapflag(src->m, MF_BATTLEGROUND) && sd->bg_id && dstsd->bg_id )
+		{
+			if( sd->bg_id == dstsd->bg_id )
+				add2limit(sd->status.bgstats.support_skills_used, 1, UINT_MAX);
+			else
+				add2limit(sd->status.bgstats.wrong_support_skills_used, 1, UINT_MAX);
+		}
+	}
 	if (skill_id != SR_CURSEDCIRCLE) {
 		struct status_change *sc = status_get_sc(src);
 
@@ -11885,6 +11938,28 @@ TIMER_FUNC(skill_castend_id){
 		}
 		if( battle_config.display_status_timers && sd )
 			clif_status_change(src, EFST_POSTDELAY, 1, skill_delayfix(src, ud->skill_id, ud->skill_lv), 0, 0, 0);
+		if( sd && sd->skillitem != ud->skill_id )
+		{ // Skill Usage Counter
+			int i;
+			if( map_allowed_woe(sd->bl.m) )
+			{
+				ARR_FIND(0,MAX_SKILL_TREE,i,sd->status.skillcount[i].id == ud->skill_id || !sd->status.skillcount[i].id);
+				if( i < MAX_SKILL_TREE )
+				{
+					sd->status.skillcount[i].id = ud->skill_id;
+					sd->status.skillcount[i].count++;
+				}
+			}
+			else if( map_getmapflag(sd->bl.m, MF_BATTLEGROUND) && sd->bg_id )
+			{
+				ARR_FIND(0,MAX_SKILL_TREE,i,sd->status.bg_skillcount[i].id == ud->skill_id || !sd->status.bg_skillcount[i].id);
+				if( i < MAX_SKILL_TREE )
+				{
+					sd->status.bg_skillcount[i].id = ud->skill_id;
+					sd->status.bg_skillcount[i].count++;
+				}
+			}
+		}
 		if( sd )
 		{
 			switch( ud->skill_id )
@@ -12103,6 +12178,28 @@ TIMER_FUNC(skill_castend_pos){
 		}
 		if( battle_config.display_status_timers && sd )
 			clif_status_change(src, EFST_POSTDELAY, 1, skill_delayfix(src, ud->skill_id, ud->skill_lv), 0, 0, 0);
+		if( sd && sd->skillitem != ud->skill_id )
+		{ // Skill Usage Counter
+			int i;
+			if( map_allowed_woe(sd->bl.m) )
+			{
+				ARR_FIND(0,MAX_SKILL_TREE,i,sd->status.skillcount[i].id == ud->skill_id || !sd->status.skillcount[i].id);
+				if( i < MAX_SKILL_TREE )
+				{
+					sd->status.skillcount[i].id = ud->skill_id;
+					sd->status.skillcount[i].count++;
+				}
+			}
+			else if( map_getmapflag(sd->bl.m, MF_BATTLEGROUND) && sd->bg_id )
+			{
+				ARR_FIND(0,MAX_SKILL_TREE,i,sd->status.bg_skillcount[i].id == ud->skill_id || !sd->status.bg_skillcount[i].id);
+				if( i < MAX_SKILL_TREE )
+				{
+					sd->status.bg_skillcount[i].id = ud->skill_id;
+					sd->status.bg_skillcount[i].count++;
+				}
+			}
+		}
 //		if( sd )
 //		{
 //			switch( ud->skill_id )
@@ -16660,9 +16757,15 @@ bool skill_check_condition_castend(struct map_session_data* sd, uint16 skill_id,
 void skill_consume_requirement(struct map_session_data *sd, uint16 skill_id, uint16 skill_lv, short type)
 {
 	struct s_skill_condition require;
+	int rankFlag = 0;
 
 	nullpo_retv(sd);
 
+	if( map_allowed_woe(sd->bl.m) && sd->status.guild_id )
+		rankFlag = 1;
+	else if( map_getmapflag(sd->bl.m, MF_BATTLEGROUND) && sd->bg_id )
+		rankFlag = 2;
+
 	require = skill_get_requirement(sd,skill_id,skill_lv);
 
 	if( type&1 ) {
@@ -16682,7 +16785,15 @@ void skill_consume_requirement(struct map_session_data *sd, uint16 skill_id, uin
 		}
 		if(require.hp || require.sp)
 			status_zap(&sd->bl, require.hp, require.sp);
-
+		
+		if( require.sp )
+		{
+			if( rankFlag == 1 )
+				add2limit(sd->status.wstats.sp_used, require.sp, UINT_MAX);
+			else if( rankFlag == 2 )
+				add2limit(sd->status.bgstats.sp_used, require.sp, UINT_MAX);
+		}
+		
 		if(require.spiritball > 0) { // Skills that require certain types of spheres to use
 			switch (skill_id) { // Skills that require soul spheres.
 				case SP_SOULGOLEM:
@@ -16705,10 +16816,18 @@ void skill_consume_requirement(struct map_session_data *sd, uint16 skill_id, uin
 					pc_delspiritball(sd, require.spiritball, 0);
 					break;
 			}
+			if( rankFlag == 1 )
+				add2limit(sd->status.wstats.spiritb_used, require.spiritball, UINT_MAX);
+			else if( rankFlag == 2 )
+				add2limit(sd->status.bgstats.spiritb_used, require.spiritball, UINT_MAX);
 		}
 		else if(require.spiritball == -1) {
 			sd->spiritball_old = sd->spiritball;
 			pc_delspiritball(sd,sd->spiritball,0);
+			if( sd->spiritball > 0 && rankFlag == 1 )
+				add2limit(sd->status.wstats.spiritb_used, sd->spiritball, UINT_MAX);
+			else if( sd->spiritball > 0 &&  rankFlag == 2 )
+				add2limit(sd->status.bgstats.spiritb_used, sd->spiritball, UINT_MAX);
 		}
 
 		if(require.zeny > 0)
@@ -16717,6 +16836,12 @@ void skill_consume_requirement(struct map_session_data *sd, uint16 skill_id, uin
 				require.zeny = 0; //Zeny is reduced on skill_attack.
 			if( sd->status.zeny < require.zeny )
 				require.zeny = sd->status.zeny;
+			
+			if( rankFlag == 1 )
+				add2limit(sd->status.wstats.zeny_used, require.zeny, UINT_MAX);
+			else if( rankFlag == 2 )
+				add2limit(sd->status.bgstats.zeny_used, require.zeny, UINT_MAX);
+			
 			pc_payzeny(sd,require.zeny,LOG_TYPE_CONSUME,NULL);
 		}
 	}
@@ -16760,6 +16885,36 @@ void skill_consume_requirement(struct map_session_data *sd, uint16 skill_id, uin
 
 			if( (n = pc_search_inventory(sd,require.itemid[i])) >= 0 )
 				pc_delitem(sd,n,require.amount[i],0,1,LOG_TYPE_CONSUME);
+			
+			if( rankFlag ) {
+				switch( require.itemid[i] )
+				{
+				case ITEMID_POISON_BOTTLE:
+					if( rankFlag == 1 )
+						add2limit(sd->status.wstats.poison_bottles, require.amount[i], UINT_MAX);
+					else
+						add2limit(sd->status.bgstats.poison_bottles, require.amount[i], UINT_MAX);
+					break;
+				case ITEMID_YELLOW_GEMSTONE:
+					if( rankFlag == 1 )
+						add2limit(sd->status.wstats.yellow_gemstones, require.amount[i], UINT_MAX);
+					else
+						add2limit(sd->status.bgstats.yellow_gemstones, require.amount[i], UINT_MAX);
+					break;
+				case ITEMID_RED_GEMSTONE:
+					if( rankFlag == 1 )
+						add2limit(sd->status.wstats.red_gemstones, require.amount[i], UINT_MAX);
+					else
+						add2limit(sd->status.bgstats.red_gemstones, require.amount[i], UINT_MAX);
+					break;
+				case ITEMID_BLUE_GEMSTONE:
+					if( rankFlag == 1 )
+						add2limit(sd->status.wstats.blue_gemstones, require.amount[i], UINT_MAX);
+					else
+						add2limit(sd->status.bgstats.blue_gemstones, require.amount[i], UINT_MAX);
+					break;
+				}
+			}
 		}
 	}
 }
@@ -17665,13 +17820,13 @@ void skill_weaponrefine(struct map_session_data *sd, int idx)
 				{ // Fame point system [DracoRPG]
 					switch(ditem->weapon_level){
 						case 1:
-							pc_addfame(sd, battle_config.fame_refine_lv1); // Success to refine to +10 a lv1 weapon you forged = +1 fame point
+							pc_addfame(sd, battle_config.fame_refine_lv1,0); // Success to refine to +10 a lv1 weapon you forged = +1 fame point
 							break;
 						case 2:
-							pc_addfame(sd, battle_config.fame_refine_lv2); // Success to refine to +10 a lv2 weapon you forged = +25 fame point
+							pc_addfame(sd, battle_config.fame_refine_lv2,0); // Success to refine to +10 a lv2 weapon you forged = +25 fame point
 							break;
 						case 3:
-							pc_addfame(sd, battle_config.fame_refine_lv3); // Success to refine to +10 a lv3 weapon you forged = +1000 fame point
+							pc_addfame(sd, battle_config.fame_refine_lv3,0); // Success to refine to +10 a lv3 weapon you forged = +1000 fame point
 							break;
 					}
 				}
@@ -20260,7 +20415,7 @@ bool skill_produce_mix(struct map_session_data *sd, uint16 skill_id, t_itemid na
 			clif_produceeffect(sd,0,nameid);
 			clif_misceffect(&sd->bl,3);
 			if (wlv >= 3 && ((ele? 1 : 0) + sc) >= 3) // Fame point system [DracoRPG]
-				pc_addfame(sd, battle_config.fame_forge); // Success to forge a lv3 weapon with 3 additional ingredients = +10 fame point
+				pc_addfame(sd, battle_config.fame_forge,0); // Success to forge a lv3 weapon with 3 additional ingredients = +10 fame point
 		} else {
 			int fame = 0;
 			tmp_item.amount = 0;
@@ -20300,7 +20455,7 @@ bool skill_produce_mix(struct map_session_data *sd, uint16 skill_id, t_itemid na
 			}
 
 			if (fame)
-				pc_addfame(sd,fame);
+				pc_addfame(sd,fame,0);
 			//Visual effects and the like.
 			switch (skill_id) {
 				case AM_PHARMACY:
diff --git a/src/map/status.cpp b/src/map/status.cpp
index fe86cd65f..564e71723 100644
--- a/src/map/status.cpp
+++ b/src/map/status.cpp
@@ -2406,6 +2406,8 @@ int status_damage(struct block_list *src,struct block_list *target,int64 dhp, in
 		unit_stop_walking( target, 1 );
 	}
 
+	pc_record_damage(src, target, hp);
+
 	if( status->hp || (flag&8) ) { // Still lives or has been dead before this damage.
 		if (walkdelay)
 			unit_set_walkdelay(target, gettick(), walkdelay, 0);
@@ -2421,7 +2423,7 @@ int status_damage(struct block_list *src,struct block_list *target,int64 dhp, in
 	* &4: Delete object from memory. (One time spawn mobs)
 	**/
 	switch (target->type) {
-		case BL_PC:  flag = pc_dead((TBL_PC*)target,src); break;
+		case BL_PC:  flag = pc_dead((TBL_PC*)target,src,skill_id); break;
 		case BL_MOB: flag = mob_dead((TBL_MOB*)target, src, flag&4?3:0); break;
 		case BL_HOM: flag = hom_dead((TBL_HOM*)target); break;
 		case BL_MER: flag = mercenary_dead((TBL_MER*)target); break;
@@ -2493,12 +2495,43 @@ int status_damage(struct block_list *src,struct block_list *target,int64 dhp, in
 	//FIXME those ain't always run if a player die if he was resurrect meanwhile
 	//cf SC_REBIRTH, SC_KAIZEL, pc_dead...
 	if(target->type == BL_PC) {
-		TBL_PC *sd = BL_CAST(BL_PC,target);
+		TBL_PC *ssd, *sd = BL_CAST(BL_PC,target);
+		// Real Killer
+		struct block_list *master = NULL;
+		if( src ) master = battle_get_master(src);
+		ssd = BL_CAST(BL_PC,master);
+		
 		if( sd->bg_id ) {
+
 			std::shared_ptr<s_battleground_data> bg = util::umap_find(bg_team_db, sd->bg_id);
 
-			if( bg && !(bg->die_event.empty()) )
+			if( map_getmapflag(sd->bl.m, MF_BATTLEGROUND) && bg && !(bg->die_event.empty()) ) {
 				npc_event(sd, bg->die_event.c_str(), 0);
+				pc_setreg(sd,add_str("@killer_bg_src"),ssd && ssd->bg_id ? ssd->bl.id : 0);
+				if( ssd && ssd->bg_id != sd->bg_id && (!strcmpi(map[sd->bl.m].name,"bg_tdm") || !strcmpi(map[sd->bl.m].name,"bg_kvm")))
+				{
+					// Team DeathMatch / KVM
+					if(!strcmpi(map[sd->bl.m].name,"bg_kvm"))
+						add2limit(sd->status.bgstats.kvm_deaths, 1, USHRT_MAX);
+					else
+						add2limit(sd->status.bgstats.tdm_deaths, 1, USHRT_MAX);
+					
+					if( ssd->bg_id)
+					{
+						bg = util::umap_find(bg_team_db, ssd->bg_id);
+						if ( bg ) {
+							int i;						
+							if(!strcmpi(map[sd->bl.m].name,"bg_kvm"))
+								add2limit(ssd->status.bgstats.kvm_kills, 1, USHRT_MAX);
+							else
+								add2limit(ssd->status.bgstats.tdm_kills, 1, USHRT_MAX);
+							ARR_FIND(0,MAX_BG_MEMBERS,i,bg->members[i].sd == ssd);
+							if( i < MAX_BG_MEMBERS )
+								pc_addfame(ssd,1,3);
+						}
+					}
+				}
+			}
 		}
 
 		npc_script_event(sd,NPCE_DIE);
